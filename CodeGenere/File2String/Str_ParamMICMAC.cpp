#include "StdAfx.h"
const char * theNameVar_ParamMICMAC[2186] = {
"<?xml version=\"1.0\" ?>\n",
"<GenCpp>\n",
"\n",
"<Verbatim File=\".h.cpp\">\n",
"#include \"StdAfx.h\"\n",
"</Verbatim>\n",
"<Verbatim  File=\".h\">\n",
"#ifndef Define_NotMicMac\n",
"#define Define_NotMicMac\n",
"</Verbatim>\n",
"<Verbatim File=\".cpp\">\n",
"// UNUSED\n",
"</Verbatim>\n",
"\n",
"<Verbatim File=\".h\">\n",
"// NO MORE\n",
"</Verbatim>\n",
"\n",
"<Verbatim File=\".h.cpp\">\n",
"// Quelque chose\n",
"</Verbatim>\n",
"\n",
"\n",
"\n",
"\n",
"<!--\n",
"       Trois type de geometrie interviennent\n",
"\n",
"\n",
"       - La geometrie image est liee a l'instrument d'acquisition\n",
"       (conique ou barette, calibration ...); elle est definie\n",
"       dans la section <Section_PriseDeVue> par le champss\n",
"      GeomImages qui doit etre dans l'enumeration eGeomImage.\n",
"\n",
"       - La geometrie de mise en correspondance qui\n",
"       a une influence forte sur l'algorithmie, elle\n",
"       est definie dans  <section_MEC>, par le champs\n",
"       GeomMEC qui doit etre dans l'enumeration eModeGeomMEC\n",
"	\n",
"       - la geometrie du MNT resultat (par exemple\n",
"       cartographique ou euclidien local), elle est\n",
"       definie dans  <Section_Results> par le champs\n",
"       GeoMNT qui doit etre dans l'enumeration\n",
"       eModeGeomMNT\n",
"	\n",
"-->\n",
"\n",
"\n",
"\n",
"   <!--  eModeGeomMEC\n",
"\n",
"       elle peut\n",
"       prendre essentiellement deux valeur eGeomMECIm1 et \n",
"       eGeomMECTerrain\n",
"   -->\n",
"\n",
"\n",
"   <enum Name=\"eModeGeomMEC\">\n",
"	   <eGeomMECIm1 >     </eGeomMECIm1>\n",
"           <eGeomMECTerrain > </eGeomMECTerrain>\n",
"           <eNoGeomMEC >      </eNoGeomMEC>\n",
"   </enum>\n",
"   <enum Name=\"eModeCensusCost\">\n",
"	   <eMCC_GrCensus >          </eMCC_GrCensus>\n",
"           <eMCC_CensusBasic >       </eMCC_CensusBasic>\n",
"           <eMCC_CensusCorrel >      </eMCC_CensusCorrel>\n",
"           <eMCC_CensusQuantitatif >      </eMCC_CensusQuantitatif>  <!-- Somme des ratio / pix central -->\n",
"           <eMCC_CensusMixCorrelBasic >      </eMCC_CensusMixCorrelBasic>\n",
"   </enum>\n",
"\n",
"\n",
"   <enum Name=\"eTypeModeleAnalytique\">\n",
"	 <eTMA_Homologues>     </eTMA_Homologues>  \n",
"         <!--  En eTMAHomographie1D, si il y a export pour les\n",
"             deux Px, le quotient est != pour X et Y\n",
"         -->\n",
"	 <eTMA_DHomD >     </eTMA_DHomD>  \n",
"         <!--  En mode TMA_Ori, on recalcule l'orientation relative de Im2/Im1 -->\n",
"	 <eTMA_Ori >     </eTMA_Ori>  \n",
"\n",
"\n",
"          <!-- Ce mode n'est plus vraiment analytique, on exporte un nuage de point\n",
"	  3D en geomrtrie euclidienne, pour chaque point de la grille terrain, on le\n",
"	  met la pour profiter de certaine fonctionnalites trouvees dans cModeleAnalytiqueComp::GetMatr\n",
"	  -->\n",
"	 <eTMA_Nuage3D> </eTMA_Nuage3D>\n",
"   </enum>\n",
"\n",
"\n",
"   <!--   eModeGeomImage\n",
"\n",
"        Beaucoup de geometrie image existaient dans\n",
"   le mode 2D de MecAutoCal, je ne les reinterfaceraient qu'au fur et\n",
"   a mesure des besoins, en cherchant a simplifier et si\n",
"   possible a tout faire rentrer dans quelques modes :\n",
"\n",
"          DHD_Px :  Dist1 o  Hom o Dist2 o Paralaxe, modele qui\n",
"          prend en compte  toutes les deformation\n",
"          \"molles\",  notamment l'autocalibration sur mur,\n",
"          la superposition des cannaux de la camera numerique,\n",
"\n",
"          DH_Px_HD :  Distorsion1 o Homographie1 o Paralaxe o \n",
"          Homographie2 o Distorsion2; \n",
"          modele general pour toutes les perspectives coniques\n",
"\n",
"          Differents modeles \"physiques\" de capteurs : .ori\n",
"          puis grilles\n",
"\n",
"        \n",
"	 Pour le mode Terrain, aujourd'hui seul les ori sont\n",
"    supportés mais il n'y aurait  pas de pb a rajouter\n",
"    par exemple les formats grilles.\n",
"\n",
"    Mode derive :\n",
"	   eGeomImage_Hom_Px : la geométrie est une homographie\n",
"         implemente comme un cas particulier de DHD\n",
"\n",
"	   eGeomImage_Epip : la geométrie epipolaire classique (mais en 2D)\n",
"         implemente comme un cas particulier de DHD\n",
"   -->\n",
"   \n",
"   <enum Name=\"eModeGeomImage\">\n",
"	   <eGeomImageOri>          </eGeomImageOri>\n",
"           <eGeomImageModule>       </eGeomImageModule>\n",
"	   <eGeomImageGrille>       </eGeomImageGrille>\n",
"           <eGeomImageRTO>       </eGeomImageRTO>\n",
"           <eGeomImageCON>       </eGeomImageCON>\n",
"\n",
"	   <eGeomImageDHD_Px>       </eGeomImageDHD_Px>\n",
"	   <eGeomImage_Hom_Px>      </eGeomImage_Hom_Px>\n",
"	   <eGeomImageDH_Px_HD>     </eGeomImageDH_Px_HD>\n",
"	   <eGeomImage_Epip>        </eGeomImage_Epip>\n",
"	   <eGeomImage_EpipolairePure>        </eGeomImage_EpipolairePure>\n",
"\n",
"           <!-- Peut lire un Stenop ou un bundle gen -->\n",
"	   <eGeomGen>          </eGeomGen>\n",
"	   <eNoGeomIm>              </eNoGeomIm>\n",
"           <!-- Pas encore implementée -->\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eOnEmptyImSecApero\">\n",
"           <eOEISA_error> </eOEISA_error>\n",
"           <eOEISA_exit> </eOEISA_exit>\n",
"           <eOEISA_goon> </eOEISA_goon>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eModeAggregCorr\">\n",
"         <eAggregSymetrique> </eAggregSymetrique>\n",
"	 <eAggregIm1Maitre>  </eAggregIm1Maitre>\n",
"         <eAggregInfoMut>    </eAggregInfoMut>\n",
"         <!-- Max des correls a l'image 1; teste pour resoudre pb de parties cachees -->\n",
"	 <eAggregMaxIm1Maitre>  </eAggregMaxIm1Maitre>\n",
"	 <eAggregMinIm1Maitre>  </eAggregMinIm1Maitre>\n",
"         <!-- Pas vrai median, moyenne - Min et Max -->\n",
"	 <eAggregMoyMedIm1Maitre>  </eAggregMoyMedIm1Maitre>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eModeDynamiqueCorrel\">\n",
"         <eCoeffCorrelStd> </eCoeffCorrelStd>\n",
"	 <eCoeffAngle>     </eCoeffAngle>\n",
"	 <eCoeffGamma>     </eCoeffGamma>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eTypeImPyram\">\n",
"         <eUInt8Bits>   </eUInt8Bits>\n",
"         <eUInt16Bits>  </eUInt16Bits>\n",
"         <eFloat32Bits> </eFloat32Bits>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eAlgoRegul\">\n",
"         <eAlgoCoxRoy>      </eAlgoCoxRoy>\n",
"         <eAlgo2PrgDyn>     </eAlgo2PrgDyn>\n",
"	 <eAlgoMaxOfScore>  </eAlgoMaxOfScore>\n",
"         <!-- Dans ce mode l'algo de CoxRoy est utilise quand cela est possible, cad\n",
"         qd la dimension de paralaxe est 1, sinon c'est l'algo AlgoWenCxRImpossible\n",
"         qui est utilise, sa Valeur par defaut est eAlgo2PrgDyn\n",
"         -->\n",
"         <eAlgoCoxRoySiPossible>      </eAlgoCoxRoySiPossible>\n",
"\n",
"\n",
"         <!--\n",
"             Cet algorithme est totalement different des autres, il \n",
"             ne discretise pas les paralaxes et fonctionne par differenciation.\n",
"             A priori, il ne s'utilise qu'en derniere etape.\n",
"         -->\n",
"         <eAlgoOptimDifferentielle> </eAlgoOptimDifferentielle>\n",
"         <eAlgoDequant> </eAlgoDequant>\n",
"         <eAlgoLeastSQ> </eAlgoLeastSQ>\n",
"         <eAlgoTestGPU>  </eAlgoTestGPU>\n",
" <!-- Peut sembler bizare, l'interet est lorque l'on veut utiliser des fonctionnalités\n",
"     annexes t.q les partie cachees, en reentrant d'un MNT externe -->\n",
"         <eAlgoIdentite> </eAlgoIdentite>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eModeInterpolation\">\n",
"        <eInterpolPPV>   </eInterpolPPV>\n",
"        <eInterpolBiLin> </eInterpolBiLin>\n",
"        <eInterpolBiCub> </eInterpolBiCub>\n",
"        <eInterpolSinCard> </eInterpolSinCard>\n",
"\n",
"        <!-- Ancienne version de D Boldo, jamais recettee -->\n",
"        <eOldInterpolSinCard> </eOldInterpolSinCard>\n",
"\n",
"        <!-- Pseudo interpolateurs pour regler les problemes de biais\n",
"             de partie fractionnaire (marches,franges ...), \n",
"             maintenant interpolateur par defaut de MicMac-->\n",
"        <eInterpolMPD>  </eInterpolMPD>\n",
"\n",
"        <!-- Interpolateurs optimises en temps de calc,\n",
"            a priori tout benef -->\n",
"        <eInterpolBicubOpt>  </eInterpolBicubOpt>\n",
"   </enum>\n",
"\n",
"\n",
"   <enum Name=\"eTypeFiltrage\">\n",
"        <eFiltrageMedian>  </eFiltrageMedian>\n",
"        <eFiltrageMoyenne> </eFiltrageMoyenne>\n",
"        <eFiltrageDeriche> </eFiltrageDeriche>\n",
"        <eFiltrageGamma>   </eFiltrageGamma>\n",
"        <eFiltrageEqLoc>   </eFiltrageEqLoc>\n",
"   </enum>\n",
" \n",
"   <enum Name=\"ePxApply\">\n",
"         <eApplyPx1>   </eApplyPx1>\n",
"         <eApplyPx2>   </eApplyPx2>\n",
"         <eApplyPx12>   </eApplyPx12>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eModeAggregProgDyn\">\n",
"         <ePrgDAgrSomme>      </ePrgDAgrSomme>\n",
"         <ePrgDAgrMax>        </ePrgDAgrMax>\n",
"         <ePrgDAgrReinject>   </ePrgDAgrReinject>\n",
"         <ePrgDAgrProgressif>   </ePrgDAgrProgressif>\n",
"   </enum>\n",
"\n",
"\n",
"   <enum Name=\"eMicMacCodeRetourErreur\">\n",
"         <eErrNbPointInEqOriRel>      </eErrNbPointInEqOriRel>\n",
"         <eErrImageFileEmpty>         </eErrImageFileEmpty>\n",
"         <eErrPtHomHorsImage>         </eErrPtHomHorsImage>\n",
"         <eErrRecouvrInsuffisant>     </eErrRecouvrInsuffisant>\n",
"         <eErrGrilleInverseNonDisponible>     </eErrGrilleInverseNonDisponible>\n",
"   </enum>\n",
"\n",
"   <enum Name=\"eTypeWinCorrel\">\n",
"       <eWInCorrelFixe>  </eWInCorrelFixe>\n",
"       <eWInCorrelExp>   </eWInCorrelExp>\n",
"       <!-- Il s'agit de fenetre rectangulaire \"bete\", donc a priori\n",
"       pas d'interet particulier / eWInCorrelFixe; si ce n'est que\n",
"       l'implementation passe par le mecanisme general FiltrageW\n",
"       qui permet de prendre en compte des option nouvelles telles\n",
"       par exemple que, Nb Iteration!=1,  SzWx!=SzWy, taille reelle pas encore \n",
"       pris par les autres\n",
"       -->\n",
"       <eWInCorrelRectSpec>   </eWInCorrelRectSpec>\n",
"   </enum>\n",
"\n",
"\n",
"\n",
"  <enum Name=\"eTypeModeEchantPtsI\">\n",
"       <eModeEchantRegulier>  </eModeEchantRegulier>  <!--  Type besoin IGN-E -->\n",
"       <eModeEchantNonAutoCor>  </eModeEchantNonAutoCor>  <!--  Type besoin aero -->\n",
"       <eModeEchantAleatoire> </eModeEchantAleatoire> <!--  A des fins de Test -->\n",
"       <eModeEchantPtsIntByComandeExterne> </eModeEchantPtsIntByComandeExterne>\n",
"  </enum>\n",
"\n",
"\n",
"  <enum Name=\"eSemantiqueLL\">\n",
"         <!--  Geometrie -->\n",
"      <eSLL_Geom_X> </eSLL_Geom_X>\n",
"      <eSLL_Geom_Y> </eSLL_Geom_Y>\n",
"      <eSLL_Geom_Z> </eSLL_Geom_Z>\n",
"      <eSLL_Geom_dir_X> </eSLL_Geom_dir_X>\n",
"      <eSLL_Geom_dir_Y> </eSLL_Geom_dir_Y>\n",
"      <eSLL_Geom_dir_Z> </eSLL_Geom_dir_Z>\n",
"         <!--  Radiometrie -->\n",
"      <eSLL_Radiom_R> </eSLL_Radiom_R>\n",
"      <eSLL_Radiom_G> </eSLL_Radiom_G>\n",
"      <eSLL_Radiom_B> </eSLL_Radiom_B>\n",
"      <eSLL_Radiom_Panchro> </eSLL_Radiom_Panchro>\n",
"      <eSLL_Radiom_Pir> </eSLL_Radiom_Pir>\n",
"      <eSLL_Radiom_Lidar> </eSLL_Radiom_Lidar>\n",
"      <eSLL_Radiom_Unknown> </eSLL_Radiom_Unknown>\n",
"         <!--  Inconnue -->\n",
"      <eSLL_Unknown> </eSLL_Unknown>\n",
"  </enum>\n",
"\n",
"  <SpecFitrageImage Nb=\"1\" Class=\"true\" ToReference=\"true\">\n",
"      <TypeFiltrage Nb=\"1\" Type=\"eTypeFiltrage\">   </TypeFiltrage>\n",
"      <SzFiltrage   Nb=\"1\"  Type=\"double\">            </SzFiltrage>\n",
"      <!-- Taille en + qui ne tient pas compte du SRA etc .. -->\n",
"      <SzFiltrNonAd   Nb=\"?\"  Type=\"double\" Def=\"0.0\"> </SzFiltrNonAd>\n",
"      <PxApply      Nb=\"?\"  Type=\"ePxApply\" Def=\"eApplyPx12\">       </PxApply>\n",
"      <PatternSelFiltre Nb=\"?\" Type=\"cElRegex_Ptr\">    </PatternSelFiltre>\n",
"      <NbIteration Nb=\"?\" Type=\"int\" Def=\"1\"> </NbIteration>\n",
"      <NbItereIntern Nb=\"?\" Type=\"int\" Def=\"1\"> </NbItereIntern>\n",
"      <AmplitudeSignal Nb=\"?\" Type=\"double\" Def=\"255\"> </AmplitudeSignal>\n",
"      <UseIt Nb=\"?\" Type=\"bool\" Def=\"true\"> </UseIt>\n",
"  </SpecFitrageImage>\n",
"\n",
"<!--  Permet de memoriser sous forme d'une image tabuler, les corrections de geom\n",
"-->\n",
"\n",
"<!--\n",
"  <MetaDataPartiesCachees Nb=\"1\" Class=\"true\" ToReference=\"true\">\n",
"       <Done  Nb=\"1\" Type=\"bool\"> </Done>\n",
"       <Offset Nb=\"1\" Type=\"Pt2di\"> </Offset>\n",
"       <Sz Nb=\"1\" Type=\"Pt2di\"> </Sz>\n",
"       <Pas Nb=\"1\" Type=\"double\">  </Pas>\n",
"       <SeuilUse  Nb=\"1\" Type=\"int\">  </SeuilUse>\n",
"  </MetaDataPartiesCachees>\n",
"-->\n",
"  <XML_RatioCorrImage Nb=\"1\" Class=\"true\" ToReference=\"true\">\n",
"      <Ratio Nb=\"1\" Type=\"double\"> </Ratio>\n",
"      <NbPt Nb=\"?\" Type=\"int\"> </NbPt>\n",
"  </XML_RatioCorrImage>\n",
"\n",
"\n",
"  <CorrectionPxTransverse Nb=\"1\" Class=\"true\" ToReference=\"true\">\n",
"       <DirPx Nb=\"1\" Type=\"Pt2dr\">          </DirPx>\n",
"       <ValeurPx Nb=\"1\" Type=\"Im2D_REAL4\">  </ValeurPx>\n",
"       <SsResol  Nb=\"1\" Type=\"double\">      </SsResol>\n",
"  </CorrectionPxTransverse>\n",
"\n",
"  <LidarFlight Nb=\"1\" Class=\"true\">\n",
"<!-- D'un cote, il semble indispensable que la donnee \"vol-lidar\" soit complete\n",
" et puisse contenuir aussi les meta-donnees permettant de savoir dans quel referentiel sont\n",
"exprimees les coordonnees. D'un autre cote, je n'ai pas du tout envie de mettre le\n",
"doigt dans la geodesie. \n",
"    Pour l'instant, le moins mauvais compromis me semble etre d'avoir une chaine\n",
"    de caractere SystemeCoordonnees qui peut etre :\n",
"          - une valeur dans un dictionnaire a definir (= LambertZone1 , ...)\n",
"          - un nom de fichier \"xml\" selon un format utilisateur dont je veux\n",
"            tout ignorer;\n",
"          - la valeur conventionnelle SystemeCoordonneesIndefini\n",
"-->\n",
"      <SystemeCoordonnees Nb=\"1\" Type=\"std::string\" > </SystemeCoordonnees>\n",
"      <LidarStrip Nb=\"+\">\n",
"           <LidarLayer Nb=\"+\">  <!-- En fait >= 3 -->\n",
"                <NameFile Nb=\"1\" Type=\"std::string\"> </NameFile>\n",
"                <Semantic Nb=\"1\" Type=\"eSemantiqueLL\"> </Semantic>\n",
"                \n",
"                <LongueurDOnde Nb=\"?\" Type=\"double\"> </LongueurDOnde>\n",
"<!-- Permet par exemple de stocker les coordonnes sur des float, sans perte significative\n",
"     de precision, meme en lambert\n",
"-->\n",
"                <OffsetValues Nb=\"?\" Type=\"double\" Def=\"0.0\"> </OffsetValues>\n",
"                <StepValues Nb=\"?\" Type=\"double\" Def=\"0.0\"> </StepValues>\n",
"\n",
"<!--  Permet l'utilisation du fichier tiff comme un raw\n",
"   par les lecteur n'ayant pas de gestionnaire Tiff ;\n",
"-->\n",
"                <IntegerValues Nb=\"1\" Type=\"bool\"> </IntegerValues>\n",
"                <SignedValues Nb=\"1\" Type=\"bool\"> </SignedValues>\n",
"                <BytePerValues Nb=\"1\" Type=\"int\"> </BytePerValues>\n",
"                <OffsetDataInFile Nb=\"1\" Type=\"int\"> </OffsetDataInFile>\n",
"           </LidarLayer>  \n",
"\n",
"<!-- Indique si la structure 2D du fichier est pertinente. Si true le fichier\n",
"est obligatoirement un Tiff; si false ce peut etre eventuellement un raw data,\n",
"\n",
"-->\n",
"            <FileIs2DStructured Nb=\"1\" Type=\"bool\"> </FileIs2DStructured>\n",
"<!--\n",
"   Formule approchee permettant  de convertir les coordonnees \"image\" \n",
"   en coordonnees terrain; Utilisee de la maniere suivante :\n",
"    Terrain(i,j) = ImTerain_P00 + i *DerImTerain_Di + j *DerImTerain_Dj\n",
"   N'a de sens que si FileIs2DStructured=true\n",
"-->\n",
"           <GeometrieAffineApprochee Nb=\"?\">\n",
"                 <ImTerain_P00 Nb=\"1\" Type=\"Pt2dr\"> </ImTerain_P00>\n",
"                 <DerImTerain_Di Nb=\"1\" Type=\"Pt2dr\"> </DerImTerain_Di>\n",
"                 <DerImTerain_Dj Nb=\"1\" Type=\"Pt2dr\"> </DerImTerain_Dj>\n",
"           </GeometrieAffineApprochee>\n",
"           <BoiteEnglob Nb=\"1\" Type=\"Box2dr\"> </BoiteEnglob>\n",
"      </LidarStrip>\n",
"      <BoiteEnglob Nb=\"1\" Type=\"Box2dr\"> </BoiteEnglob>\n",
"  </LidarFlight>\n",
"<!--\n",
"-->\n",
"\n",
"   <!--\n",
"        Cette classe permet de partager des resultats entre les\n",
"     process MICMAC. Pour ne surtout pas avoir a gerer de pb\n",
"     d'acces concurent, on s'arrange pour que seul le process\n",
"     maitre ecrive dedans et qu'il le fasse avant d'avoir\n",
"     ouvert un quelconque process fils (ou a la rigueur apres\n",
"     avoir fermes tous ceux en // d'une etape);\n",
"   -->\n",
"   <MemPartMICMAC Nb=\"1\" Class=\"true\">\n",
"       <NbMaxImageOn1Point Nb=\"?\" Type=\"int\"> </NbMaxImageOn1Point>\n",
"       <BSurHGlob  Nb=\"?\" Type=\"double\"> </BSurHGlob>\n",
"       <DeZoomLast  Nb=\"?\" Type=\"int\"> </DeZoomLast>\n",
"       <NumLastEtape  Nb=\"?\" Type=\"int\"> </NumLastEtape>\n",
"   </MemPartMICMAC>\n",
"\n",
"\n",
"   <ParamMasqAnam Nb=\"1\" Class=\"true\">\n",
"        <BoxTer Nb=\"1\" Type=\"Box2dr\"> </BoxTer>\n",
"        <Resol  Nb=\"1\" Type=\"double\"> </Resol>\n",
"   </ParamMasqAnam>\n",
"\n",
"\n",
"   <MM_EtatAvancement Nb=\"1\" Class=\"true\">\n",
"         <AllDone Nb=\"1\" Type=\"bool\"> </AllDone>\n",
"   </MM_EtatAvancement>\n",
"\n",
"\n",
"   <!--  \n",
"        Pour eventuellement generer un fichier vecteur de description \n",
"       du chantier.\n",
"   -->\n",
"   <FileDescriptionChantier Nb=\"1\" Class=\"true\">\n",
"	  <ImageFDC Nb=\"*\">\n",
"	      <FDCIm  Nb=\"1\" Type=\"std::string\"> </FDCIm>\n",
"	      <DirEpipTransv Nb=\"?\" Type=\"Pt2dr\"> </DirEpipTransv>\n",
"	  </ImageFDC>\n",
"          <CouplesFDC Nb=\"*\">\n",
"                <FDCIm1 Nb=\"1\" Type=\"std::string\"> </FDCIm1>\n",
"                <FDCIm2 Nb=\"1\" Type=\"std::string\"> </FDCIm2>\n",
"                <BSurH Nb=\"?\" Type=\"double\">    </BSurH>\n",
"          </CouplesFDC>\n",
"   </FileDescriptionChantier>\n",
"\n",
"   <BoxMasqIsBoxTer Nb=\"1\" Class=\"true\">\n",
"       <Box Nb=\"1\" Type=\"Box2dr\"> </Box>\n",
"   </BoxMasqIsBoxTer>\n",
"\n",
"\n",
"   <ParamMICMAC Nb=\"1\" Class=\"true\">\n",
"\n",
"        <DicoLoc  Nb=\"?\" RefType=\"ChantierDescripteur\"\n",
"                         RefFile=\"ParamChantierPhotogram.xml\"\n",
"        >\n",
"        </DicoLoc>\n",
"\n",
"\n",
"<!-- *************************************************************     \n",
"         Parametres lies au terrain \"physique\" \n",
"         independamment de la prise de vue\n",
"-->\n",
"     <Section_Terrain Nb=\"1\">  \n",
"\n",
"       <!-- Completement redondant avec ZIncIsProp, mais plus general et arrive apres -->\n",
"       <IntervalPaxIsProportion Type=\"bool\" Nb=\"?\" Def=\"false\"> </IntervalPaxIsProportion>\n",
"\n",
"       <!-- En general aucun interet a le fixer soif meme; exception on lance plusieurs MicMac\n",
"           en Faisceau Z Terrain et on veut les compare facile -->\n",
"       <RatioAltiPlani Nb=\"?\" Type=\"double\"> </RatioAltiPlani>\n",
"\n",
"       <!--\n",
"           En mode eGeomMECTerrain, IntervAltimetrie doit etre remplis\n",
"        et IntervParalaxe doit etre vide.\n",
"           Vice-vers en mode eGeomMECIm1.\n",
"\n",
"           Z,Px1,Px2 Calc sont les incertitude utilisée pour définir\n",
"        l'intervalle de recherche initiale (\"nappe englobante\").\n",
"\n",
"          Z,Px1,Px2 Zonage sont les incertitudes utilisees pour definir\n",
"        les espaces objets. Si il ne sont pas precises ils seront egaux\n",
"        a leur equivalent calc.\n",
"\n",
"           Si ZMoyen n'est pas precise, il sera recherche dans les fichier\n",
"         de geometrie si il le contiennent (altisol des \".ori\").\n",
"       -->\n",
"\n",
"       <EstimPxPrefZ2Prof Nb=\"?\" Type=\"bool\" Def=\"false\"> </EstimPxPrefZ2Prof>\n",
"       <IntervAltimetrie Nb=\"?\">\n",
"          <!-- Si vrai, pour la geometrie faisceau privilegie le Z sur la profondeur\n",
"	       pour la calcul de paralaxe moyenne, adaptee au bas relief -->\n",
"          <!-- Incertitude en Z -->\n",
"             <ZMoyen Nb=\"?\" Type=\"double\">       </ZMoyen>\n",
"             <ZIncCalc Nb=\"1\" Type=\"double\">     </ZIncCalc>\n",
"             <!-- Si Vrai, le ZIncCalc est une prop / a la distance sol -->\n",
"             <ZIncIsProp Nb=\"?\" Type=\"bool\"> </ZIncIsProp>\n",
"             <ZIncZonage Nb=\"?\" Type=\"double\">   </ZIncZonage>\n",
"             <MNT_Init Nb=\"?\"> \n",
"                  <MNT_Init_Image Nb=\"1\" Type=\"std::string\"> </MNT_Init_Image>\n",
"                  <MNT_Init_Xml Nb=\"1\" Type=\"std::string\">   </MNT_Init_Xml>\n",
"                  <!-- Se rajoute a MNT_Init_Image, permet de gerer de maniere\n",
"                       assymetrique le ZIncCalc -->\n",
"                  <MNT_Offset Nb=\"?\"  Type=\"double\" Def=\"0.0\"> </MNT_Offset>\n",
"             </MNT_Init>\n",
"\n",
"             <EnveloppeMNT_INIT Nb=\"?\">\n",
"                  <ZInf Nb=\"1\" Type=\"std::string\"> </ZInf>\n",
"                  <ZSup Nb=\"1\" Type=\"std::string\"> </ZSup>\n",
"             </EnveloppeMNT_INIT>\n",
"\n",
"\n",
"             \n",
"       </IntervAltimetrie>\n",
"\n",
"       <IntervParalaxe Nb=\"?\">\n",
"          <!-- Incertitude en Paralaxe -->\n",
"             <Px1Moy Nb=\"?\" Type=\"double\">      </Px1Moy>\n",
"             <Px2Moy Nb=\"?\" Type=\"double\">      </Px2Moy>\n",
"             <Px1IncCalc Nb=\"1\" Type=\"double\">      </Px1IncCalc>\n",
"\n",
"             <!-- Utilisee pour les points de liaisons, permet d'avoir\n",
"	     un paramatrage universel pas idiot -->\n",
"             <Px1PropProf Nb=\"?\" Type=\"double\" Def=\"0.0\">      </Px1PropProf>\n",
"\n",
"             <Px2IncCalc Nb=\"?\" Type=\"double\">      </Px2IncCalc>\n",
"             <Px1IncZonage Nb=\"?\" Type=\"double\">    </Px1IncZonage>\n",
"             <Px2IncZonage Nb=\"?\" Type=\"double\">    </Px2IncZonage>\n",
"       </IntervParalaxe>\n",
"\n",
"\n",
"       <!-- Remplace le MNT INIT , sera plus general, pour l'instant implementation minimaliste,\n",
"            exige un nuage superposable a celui du calcul \n",
"        -->\n",
"       <NuageXMLInit Nb=\"?\">\n",
"             <NameNuageXML Nb=\"1\" Type=\"std::string\">       </NameNuageXML>\n",
"             <CanAdaptGeom Nb=\"?\" Type=\"bool\" Def=\"false\">  </CanAdaptGeom>\n",
"       </NuageXMLInit>\n",
"\n",
"       <!-- Adapte a la geometrie faisceau -->\n",
"       <IntervSpecialZInv Nb=\"?\">\n",
"             <MulZMin Nb=\"1\" Type=\"double\"> </MulZMin>\n",
"             <MulZMax Nb=\"1\" Type=\"double\"> </MulZMax>\n",
"       </IntervSpecialZInv>\n",
"\n",
"        <!-- limite le nombre de decimale des fichiers de geo-ref, mis a true par defaut car\n",
"         on suppose (espere) que ce ne posera pas de pb de compat -->\n",
"        <GeoRefAutoRoundResol Nb=\"?\" Type=\"bool\"> </GeoRefAutoRoundResol>\n",
"        <GeoRefAutoRoundBox Nb=\"?\" Type=\"bool\"> </GeoRefAutoRoundBox>\n",
"\n",
"       <!-- Adapte  a la geometrie terrain -->\n",
"        <Planimetrie Nb=\"?\">\n",
"\n",
"             <!-- \n",
"                   La zone terrain est definie par l'union de Box Terrain\n",
"                (si elle existe) et de la projection en terrain, avec la\n",
"                def paralaxe, de l'ensemble des points inclus; s'il n'y a\n",
"                ni boite ni Point inclus c'est +ou- la zone qui englobera\n",
"                toutes les images .\n",
"              -->\n",
"             <BoxTerrain Nb=\"?\" Type=\"Box2dr\"> </BoxTerrain>\n",
"             <ListePointsInclus Nb=\"*\">\n",
"                    <Pt Nb=\"+\" Type=\"Pt2dr\"> </Pt>\n",
"                    <Im Nb=\"1\" Type=\"std::string\"> </Im>\n",
"             </ListePointsInclus>\n",
"             <!-- Par ex, si RatioResolImage vaut 0.8 et que la resolution\n",
"                des image est 20 cm, alors la resolution terrain sera de \n",
"                16 cm\n",
"              -->\n",
"             <RatioResolImage Nb=\"?\" Type=\"double\"> </RatioResolImage>\n",
"             <ResolutionTerrain Nb=\"?\" Type=\"double\"> </ResolutionTerrain>\n",
"             <RoundSpecifiedRT  Nb=\"?\" Type=\"bool\"> </RoundSpecifiedRT>\n",
"\n",
"             <!-- Parfois on peut souhaiter que des images \n",
"                  (par exemple HR servant a l'ortho) ne soient\n",
"                  pas utilisee pour calculer les caracteristiques geometrique -->\n",
"             <FilterEstimTerrain Nb=\"?\" Type=\"std::string\" Def=\".*\"> </FilterEstimTerrain>\n",
"\n",
"        <!--\n",
"              Image de Masque utilisee pour designer l'emprise fine de\n",
"           la correlation, il doit etre superposable au MNT de resolution\n",
"           1.  \n",
"               Si le fichier n'existe pas, il en sera cree un correspondant\n",
"           aux point du terrain qui sont vus d'au moins deux images (pour \n",
"           la paralaxe moyenne)\n",
"        -->\n",
"             <MasqueTerrain Nb=\"?\"> \n",
"                  <!-- Si donne et que n'existe pas, la boite du masque est calculee\n",
"                  et devient la boite terrain,  ensuite elle est sauvegardee dans le fichier\n",
"                  pour usage ulterieur\n",
"                  -->\n",
"                  <FileBoxMasqIsBoxTer Nb=\"?\" Type=\"std::string\"> </FileBoxMasqIsBoxTer>\n",
"                  <MT_Image Nb=\"1\" Type=\"std::string\"> </MT_Image>\n",
"                  <MT_Xml Nb=\"1\" Type=\"std::string\"> </MT_Xml>\n",
"             </MasqueTerrain>\n",
"\n",
"         \n",
"\n",
"\n",
"        <!-- Taille minimale de l'emprise terrain / a la taille de l'image 1,\n",
"             par defaut vaut 0 (donc aucune contrainte) sauf pour le cas\n",
"             ou la geometrie est eGeomMNTFaisceauIm1PrCh_Px2D, auquel\n",
"             cas il vaut 0.02 (2%) car cette geometrie est presque\n",
"             toujours associee a du calcul de points homologues qui degenere\n",
"             lorsque la zone est quasi vide.\n",
"        -->\n",
"              <RecouvrementMinimal Nb=\"?\" Type=\"double\">  </RecouvrementMinimal>\n",
"        </Planimetrie>\n",
"\n",
"        <!-- Si donne, il ecrase toute les autres valeur de Plani et Alti -->\n",
"        <FileOriMnt Nb=\"?\" Type=\"std::string\"> </FileOriMnt>\n",
"\n",
"        <!--\n",
"             Cette section contient des champs qui releve a la fois du terrain\n",
"           et de l'agorithmie. Il s'agit de specifier comment les different\n",
"           terme de la fonction d'energie evoluent en fonction de l'echelle.\n",
"\n",
"              Il sont tous precises en terme d'exposant / a DeZoom;\n",
"           \n",
"           Pour les valeurs par defaut :\n",
"\n",
"              o ExpSigmaCorrel : -2, suppose la moyenne de correlation \n",
"                independante de l'echelle\n",
"\n",
"              o ExpRegulAlti : -1, si cout de type L1, et compte tenu du fait\n",
"                que l'on raisonne toujours avec une quantif alti proportionnelle\n",
"                a la quantif plani\n",
"\n",
"               o ExpRegulPlani : -1, si on fait abstraction de tout aspect \"fractal\"\n",
"                 du relief , revient a une integrale de || de gradient\n",
"\n",
"             Donc en fait, par un raisonnement tres \"complique\", on retrouve un\n",
"           coeff de regul constant.\n",
"\n",
"              Par contre ce n'est plus le cas lorsque SsResAlgo est != 1\n",
"        -->\n",
"        <RugositeMNT Nb=\"?\">\n",
"             <EnergieExpCorrel Nb=\"?\" Type=\"double\" Def=\"-2.0\">      </EnergieExpCorrel> \n",
"             <EnergieExpRegulPlani Nb=\"?\" Type=\"double\" Def=\"-1.0\">  </EnergieExpRegulPlani> \n",
"             <EnergieExpRegulAlti Nb=\"?\" Type=\"double\" Def=\"-1.0\">   </EnergieExpRegulAlti> \n",
"        </RugositeMNT>\n",
"\n",
"\n",
"     </Section_Terrain>\n",
"<!--  ************************************************************* \n",
"         Parametres lies a la prise de vue,\n",
"         independamment de son exploitation\n",
"         par le correlateur\n",
"\n",
"         ValSpecNotImage : si initialisee, donne la valeur\n",
"       des pixels hors de l'image.\n",
"-->\n",
"     <Section_PriseDeVue Nb=\"1\">\n",
"        <!-- Bord d'image a ne pas utiliser,  apparu avec image\n",
"             drawtisee, assez large pour tenir compte des eventuelles\n",
"             corrections d'achromatisme\n",
"        -->\n",
"        <BordImage Nb=\"?\" Type=\"int\"  Def=\"5\"> </BordImage>\n",
"        <!-- Aucune raison a priori d'aller contre la valeur par defaut,mais\n",
"             bon on sait jamais\n",
"        -->\n",
"\n",
"\n",
"        <ConvertToSameOriPtTgtLoc Nb=\"?\" Type=\"bool\" > </ConvertToSameOriPtTgtLoc>\n",
"        <ValSpecNotImage Nb=\"?\" Type=\"int\"> </ValSpecNotImage>\n",
"        <PrefixMasqImRes Nb=\"?\" Type=\"std::string\" Def=\"MasqIm\">    </PrefixMasqImRes>\n",
"\n",
"        <DirMasqueImages Nb=\"?\" Type=\"std::string\" Def=\"\"> </DirMasqueImages>\n",
"        <!-- Il y en a plusieurs ce qui permet si necessaire de les combiner \n",
"            par \"et\" \n",
"        -->\n",
"        <MasqImageIn Nb=\"*\">\n",
"             <!-- En cas de match multiple, c'est le dernier qui compte -->\n",
"             <OneMasqueImage Nb=\"*\">\n",
"                <PatternSel Nb=\"1\" Type=\"cElRegex_Ptr\">    </PatternSel>\n",
"                   <!-- Si NomMasq=PasDeMasqImage -> Valeur Tag \n",
"                        pour ne pas aller chercher de masque -->\n",
"                <NomMasq Nb=\"1\"  Type=\"std::string\">      </NomMasq>  \n",
"             </OneMasqueImage>\n",
"             <AcceptNonExistingFile Nb=\"?\" Type=\"bool\" Def=\"false\"> </AcceptNonExistingFile>\n",
"        </MasqImageIn>\n",
"\n",
"         <!-- Filtre a appliquer en entree de l'image -->\n",
"        <FiltreImageIn Nb=\"*\" RefType=\"SpecFitrageImage\"> </FiltreImageIn>\n",
"\n",
"        <GeomImages Nb=\"1\" Type=\"eModeGeomImage\"> </GeomImages>\n",
"        <ModuleGeomImage Nb=\"?\">\n",
"           <NomModule Nb=\"1\" Type=\"std::string\"> </NomModule>\n",
"           <NomGeometrie Nb=\"1\" Type=\"std::string\"> </NomGeometrie> \n",
"        </ModuleGeomImage>\n",
" \n",
"     <!-- Im1 et Im2 doivent etre des noms, les ImC peuvent\n",
"     etre des patterns , au total il doit y avoir au - 2 images -->\n",
"        <Images Nb=\"1\">\n",
"             <Im1 Nb=\"?\" Type=\"std::string\">   </Im1>\n",
"             <Im2 Nb=\"?\" Type=\"std::string\">   </Im2>\n",
"             <!-- Utilise le  FileChantierNameDescripteur pour calculer le nom de l'image 2 a partir du nom de l'image1-->\n",
"	     <FCND_CalcIm2fromIm1 Nb=\"?\">\n",
"	          <I2FromI1Key Nb=\"1\" Type=\"std::string\"> </I2FromI1Key>\n",
"		  <I2FromI1SensDirect Nb=\"1\" Type=\"bool\"> </I2FromI1SensDirect>\n",
"	     </FCND_CalcIm2fromIm1>\n",
"\n",
"\n",
"             <ImPat Nb=\"*\" Type=\"std::string\">   </ImPat>\n",
"             <!-- Utilise le mecanisem ImSecOfMaster d'Apero -->\n",
"\n",
"             <ImageSecByCAWSI Nb=\"?\" Type=\"std::string\"> </ImageSecByCAWSI>\n",
"             <ImSecCalcApero Nb=\"?\">\n",
"                  <Key Nb=\"1\" Type=\"std::string\"> </Key>\n",
"                  <!-- Si Pas donne utilise Score  -->\n",
"                  <Nb Nb=\"?\" Type=\"int\" Def=\"-1\"> </Nb>  \n",
"\n",
"                  <NbMin Nb=\"?\" Type=\"int\" Def=\"-1\"> </NbMin>  \n",
"                  <NbMax Nb=\"?\" Type=\"int\" Def=\"1000\"> </NbMax>  \n",
"                  <OnEmpty Nb=\"?\" Type=\"eOnEmptyImSecApero\" Def=\"eOEISA_error\"> </OnEmpty>  \n",
"             </ImSecCalcApero>\n",
"             <RelGlobSelecteur Nb=\"?\" RefType=\"ParamGenereStrVois\" RefFile=\"SuperposImage.xml\"> </RelGlobSelecteur>\n",
"             <Filter Nb=\"?\" \n",
"                     RefType=\"NameFilter\"\n",
"                     RefFile=\"ParamChantierPhotogram.xml\"\n",
"             >\n",
"             </Filter>\n",
"\n",
"             <!-- Si donne,filtre les images recouvrant la premier (au sens de \n",
"                la fon Elise) d'au moins ce seuil \n",
"              -->\n",
"             <AutoSelectionneImSec Nb=\"?\">\n",
"                  <RecouvrMin Nb=\"1\" Type=\"double\"> </RecouvrMin>\n",
"             </AutoSelectionneImSec>\n",
"\n",
"\n",
"              <!-- Dans le cas ou il y a une structure lineaire du chantier, les images secondaire peuvent etre\n",
"                   calculees a partir de la maitresse, il faut pouvoir convertir un nom en nombre et vice versa\n",
"              -->\n",
"              <ImSecByDelta Nb=\"?\" RefType=\"ListImByDelta\" RefFile=\"ParamChantierPhotogram.xml\">\n",
"              </ImSecByDelta>\n",
"\n",
"              <!-- Ne peut etre utilisee que pour generer la superposition multi-canal , A priori obsolete-->\n",
"             <Im3Superp Nb=\"?\" Type=\"std::string\">   </Im3Superp>\n",
"        </Images>\n",
"	<!-- Ne peut etre vide que pour les modes epipolaires -->\n",
"        <NomsGeometrieImage Nb=\"*\">\n",
"	    <UseIt Nb=\"?\" Type=\"bool\" Def=\"true\"> </UseIt>\n",
"            <PatternSel Nb=\"?\" Type=\"std::string\">    </PatternSel>\n",
"             <!-- La valeur GridDistId  est une cle pour pas de distorsion-->\n",
"            <PatNameGeom Nb=\"?\" Type=\"std::string\">   </PatNameGeom>\n",
"\n",
"             <!-- Si ce tag \"esoterique\" vaut true, alors c'est la concatenation de Iml@Im2 qui\n",
"                  est utilise pour calculer le nom de la geometrie de Im1 (et Im2@Im1\n",
"                  pour Im2). Ce tag est utilise pour eviter tout conflit de noms lorsque des\n",
"                  orientation relatives calculees par couple sont reutilisees en entree de MICMAC\n",
"             -->\n",
"            <PatternNameIm1Im2 Nb=\"?\" Type=\"std::string\"> </PatternNameIm1Im2>\n",
"\n",
"             <!-- Normalement il devrait y avoir exclusion des la specif entre les\n",
"	     trois PatternSel,PatNameGeom,PatternNameIm1Im2 et le mode FDNC, cela\n",
"	     conduirait a des incompatibilite, c'est donc dans le code que l'on verifie\n",
"	     cette exclusion.\n",
"	     -->\n",
"             <FCND_Mode_GeomIm Nb=\"?\">\n",
"	          <FCND_GeomCalc Nb=\"1\" Type=\"std::string\"> </FCND_GeomCalc>  <!-- Pour l'instant 1 to 1 -->\n",
"                 <!-- permet de filtrer si plusieurs NomsGeometrieImage , par def OK-->\n",
"	          <FCND_GeomApply Nb=\"?\" Type=\"cElRegex_Ptr\"> </FCND_GeomApply> \n",
"             </FCND_Mode_GeomIm>\n",
"\n",
"             <!-- Si existe remplace tous les autres, pour l'instant uniquement avec eGeomGen, mais a generaliser ... -->\n",
"             <NGI_StdDir Nb=\"?\" >\n",
"                      <StdDir Nb=\"1\" Type=\"std::string\">   </StdDir>\n",
"	              <NGI_StdDir_Apply Nb=\"?\" Type=\"cElRegex_Ptr\"> </NGI_StdDir_Apply> \n",
"             </NGI_StdDir>\n",
"\n",
"\n",
"            <AddNumToNameGeom Type=\"bool\" Nb=\"?\" Def=\"false\"> </AddNumToNameGeom>\n",
"\n",
"            <ModuleImageLoader Nb=\"?\"> \n",
"                 <NomModule Nb=\"1\" Type=\"std::string\"> </NomModule>\n",
"                 <NomLoader Nb=\"1\" Type=\"std::string\"> </NomLoader> \n",
"            </ModuleImageLoader>\n",
"             <!-- Liste des orientation generee a un facteur de DeZoom; Non Implante -->\n",
"            <GenereOriDeZoom Nb=\"*\" Type=\"int\"> </GenereOriDeZoom> \n",
"\n",
"	    <!-- Utilisee si l'image a ete modifiee (chgt d'echelle, crop)  mais pas\n",
"	    le fichier de geometrie-->\n",
"            <ModifieurGeometrie Nb=\"*\">\n",
"	        <Geom Nb=\"1\" UnionType=\"true\">\n",
"	            <CropAndScale Nb=\"?\"> \n",
"		       <!-- X et Y, sauf si ScaleY est specifie-->\n",
"		       <Scale Nb=\"?\" Type=\"double\" Def=\"1.0\"> </Scale> \n",
"		       <!-- Debut du crop dans les coordonnees de l'image intiale -->\n",
"		       <Crop  Nb=\"?\" Type=\"Pt2dr\" Def=\"0.0 , 0.0\"> </Crop>\n",
"		       <ScaleY Nb=\"?\" Type=\"double\"> </ScaleY>  <!-- Defaut = Scale-->\n",
"		       <!-- Initiale a \"reduite\" : (X-tr.x)/Sc.x -->\n",
"	            </CropAndScale> \n",
"		    <NamePxTr Nb=\"?\" Type=\"std::string\"> </NamePxTr>\n",
"	        </Geom>\n",
"		<Apply Nb=\"?\" Type=\"cElRegex_Ptr\"  > </Apply>\n",
"            </ModifieurGeometrie>\n",
"\n",
"\n",
"        </NomsGeometrieImage>\n",
"        <!-- Fonctionne sur le meme principe que PatternNameGeom\n",
"             avec les \"symboles\" %I et %J\n",
"        -->\n",
"        <NomsHomomologues Nb=\"?\">\n",
"              <PatternSel Nb=\"1\" Type=\"std::string\">    </PatternSel>\n",
"              <PatNameGeom Nb=\"1\" Type=\"std::string\">   </PatNameGeom>\n",
"              <SeparateurHom Nb=\"?\" Type=\"std::string\" Def=\"\">   </SeparateurHom>\n",
"        </NomsHomomologues>\n",
"\n",
"	<!-- Toujours dans le sens direct, car pas forcement inversible -->\n",
"	<FCND_CalcHomFromI1I2 Nb=\"?\" Type=\"std::string\"> </FCND_CalcHomFromI1I2>\n",
"\n",
"\n",
"	<!-- Ces deux tags on ete rajoutes pour les prise de vue\n",
"	convergent tres oblique, le probleme apparait quand l'image\n",
"	d'un point terrain passe de l'autre cote du plan focal.\n",
"\n",
"	     Pour eviter ca \n",
"	-->\n",
"	<SingulariteInCorresp_I1I2 Type=\"bool\" Nb=\"?\" Def=\"false\"> </SingulariteInCorresp_I1I2>\n",
"\n",
"\n",
"        <ClassEquivalenceImage Nb=\"?\" \n",
"	            RefType=\"MapName2Name\"\n",
"		    RefFile=\"SuperposImage.xml\"\n",
"        >\n",
"        </ClassEquivalenceImage>\n",
"\n",
"     </Section_PriseDeVue>\n",
"<!--  *************************************************************\n",
"       Parametres reglant le comportement\n",
"     de l'algo de mise en correspondance\n",
"\n",
"     La premiere etape doit obligatoirement avoir le champs\n",
"   resolution a -1. Elle donne les valeurs par defaut et ne\n",
"   sera pas executee.  \n",
"\n",
"     Pour les champs facultatif l'attribut \"Portee\" est a prendre\n",
"   au sens de Portee Lexical, il peut valoir \"Locale\" ou \"Globale\".\n",
"   Si il vaut Local seule l'etape courante est modifiee, sinon\n",
"   ce sont toutes les etapes suivante. Pour la premiere etape\n",
"   (avec Resol = -1), la portee est toujours globale.\n",
"\n",
"     De maniere generale, c'est l'attribut DeltaPrec a \"1\" qui\n",
"   a cet effet (defaut = \"0\").\n",
"\n",
"       Doit etre ordonne des resolutions les plus basses\n",
"   aux plus grandes.\n",
"-->\n",
"     <Section_MEC Nb=\"1\">\n",
"\n",
"         <!-- Used to avoird too sctrict elimination of point on Z criteria -->\n",
"        <ExtensionIntervZ Nb=\"?\" Type=\"double\"> </ExtensionIntervZ>\n",
"\n",
"         <!-- Option applicable a la geometrie terrain, en image c'est de touet facon\n",
"        la cas... Permet de faire des fichiers + generiques -->\n",
"\n",
"         <PasIsInPixel Nb=\"?\" Type=\"bool\" Def=\"false\"> </PasIsInPixel>\n",
"\n",
"         <!--\n",
"               Si on veut que la mise en correspondance ne se fasse pas\n",
"            sur tous le chantier on fixe la Box ProportionClipMEC, une valeur\n",
"            0 0 1 1 (+ou -  celle par defaut) correspond a l'ensemble du \n",
"            channtier.\n",
"               Utile pour tester rapidement l'effet de modification des parametres.\n",
"         -->\n",
"        <ProportionClipMEC Type=\"Box2dr\" Nb=\"?\"> </ProportionClipMEC>\n",
"        <ClipMecIsProp Nb=\"?\" Type=\"bool\" Def=\"true\"></ClipMecIsProp>\n",
"        <ZoomClipMEC Nb=\"?\" Type=\"double\" Def=\"1.0\"></ZoomClipMEC>\n",
"            <!-- Valeur de la correlation quand moins de 2 images-->\n",
"        <NbMinImagesVisibles Nb=\"?\" Type=\"int\" Def=\"2\"> </NbMinImagesVisibles>\n",
"            <!-- Si ce tag vaut true et que pour un point la Px vaut DefCorr, alors c'est propage \n",
"	    a tout les point de cet Px. Vrai par defaut car ca evite des biais en bord d'image\n",
"	    -->\n",
"\n",
"\n",
"	<OneDefCorAllPxDefCor Nb=\"?\" Type=\"bool\" Def=\"false\"> </OneDefCorAllPxDefCor>\n",
"	<!-- Dans certaine config (tres longue focale) le OneDefCorAllPxDefCor a pour\n",
"	effet de \"manger\" tout le terrain si on le fait trop tot, donc :   -->\n",
"	<ZoomBeginODC_APDC Nb=\"?\"  Type=\"int\" Def=\"4\"> </ZoomBeginODC_APDC>\n",
"\n",
"\n",
"        <DefCorrelation Nb=\"?\" Type=\"double\" Def=\"-0.01234\"> </DefCorrelation>\n",
"	<!-- Tag \"cosmetique\",  recalcul les pixel hors image par projection sur les\n",
"	pixels images -->\n",
"        <ReprojPixelNoVal Nb=\"?\" Type=\"bool\" Def=\"true\"> </ReprojPixelNoVal>\n",
"            <!-- \"Epsilon\" utilise lorsque Ecart Quad trop faible\"-->\n",
"        <EpsilonCorrelation Nb=\"?\" Type=\"double\" Def=\"1e-5\"> </EpsilonCorrelation>\n",
"\n",
"        <!-- Permet qu'a resolution 1, seuls 1 point sur FreqEchantPtsI soit calcule,\n",
"             les frequence inferieures sont gerees automatiquement;\n",
"        -->\n",
"        <EchantillonagePtsInterets Nb=\"?\">\n",
"             <FreqEchantPtsI Nb=\"1\" Type=\"int\"> </FreqEchantPtsI> \n",
"             <ModeEchantPtsI Nb=\"1\" Type=\"eTypeModeEchantPtsI\"> </ModeEchantPtsI>\n",
"	     <KeyCommandeExterneInteret Nb=\"?\" Type=\"std::string\"> </KeyCommandeExterneInteret>\n",
"\n",
"              <!-- Parametres specifiques a Mode=NonAutoCor-->\n",
"              <SzVAutoCorrel Nb=\"?\" Type=\"int\" Def=\"2\"> </SzVAutoCorrel>\n",
"              <EstmBrAutoCorrel Nb=\"?\" Type=\"double\" Def=\"-1.0\"> </EstmBrAutoCorrel>\n",
"              <SeuilLambdaAutoCorrel Nb=\"?\" Type=\"double\" Def=\"0.0\"> </SeuilLambdaAutoCorrel>\n",
"              <SeuilEcartTypeAutoCorrel Nb=\"?\" Type=\"double\" Def=\"0.0\"> </SeuilEcartTypeAutoCorrel>\n",
"              <RepartExclusion Nb=\"?\" Type=\"double\" Def=\"0.4\"> </RepartExclusion>\n",
"              <RepartEvitement Nb=\"?\" Type=\"double\" Def=\"1.0\"> </RepartEvitement>\n",
"        </EchantillonagePtsInterets>\n",
"\n",
"	<!-- souvent, en geomIm1 maitresse,  il est utile que les coordonnees du terrain \n",
"	soient superposables a image1( sans translation) , ce tag permet de forcer\n",
"	-->\n",
"	<ChantierFullImage1 Nb=\"?\" Type=\"bool\" Def=\"false\"> </ChantierFullImage1>\n",
"        <!-- Est-ce que lorsque ChantierFullImage1 on doit inhiber le masque ? true par compat -->\n",
"	<ChantierFullMaskImage1 Nb=\"?\" Type=\"bool\" Def=\"true\"> </ChantierFullMaskImage1>\n",
"        <!--  Si l'on souhite generer des points homologues multiples, il faut que ce soit tjs les memes\n",
"	      points de l'image 1 que l'on retrouve.\n",
"              Pour faire cela simplement, la taille du chantier est alors tjs egale a celle de l'image\n",
"	      (evite pb de coherence sur les origines).\n",
"	      Par ailleurs les points homologues sont exportes sous formes d'images.\n",
"\n",
"	      Ce tag force aussi a true ChantierFullImage1\n",
"	-->\n",
"	<ExportForMultiplePointsHomologues Nb=\"?\" Type=\"bool\" Def=\"false\"> </ExportForMultiplePointsHomologues>\n",
"\n",
"\n",
"\n",
"\n",
"        <!--  J'ai observe empririquement que la dynamique de correlation\n",
"              peut etre extrement variable selon les contextes et les\n",
"              taille de fenetre, pour essayer d'avoir un parametrage de regularisation\n",
"              qui ne soit pas dependant de la taille de fenetre, \n",
"              on peut regler ces coeefs.\n",
"\n",
"              Pas de correction pour les variation de fenetre interieure,\n",
"              la formule est (a peu pres) valide pour de fenetre de taille \n",
"              interieure 0\n",
"        -->\n",
"        <AdapteDynCov Nb=\"?\">\n",
"             <CovLim Nb=\"?\" Type=\"double\" Def=\"0.005\">   </CovLim>\n",
"             <TermeDecr Nb=\"?\" Type=\"double\" Def=\"0.06\">   </TermeDecr>\n",
"              <!--  3 pour fenetre 3x3  -->\n",
"             <SzRef    Nb=\"?\"  Type=\"int\" Def=\"3\"> </SzRef>\n",
"             <!-- La Val Ref a ete etalonnee pour une fenetre 3x3  \"vide\"  -->\n",
"             <ValRef    Nb=\"?\"  Type=\"double\" Def=\"0.048\"> </ValRef>\n",
"        </AdapteDynCov>\n",
"\n",
"        <MMUseMasq3D Nb=\"?\" AccessorFils=\"false\">\n",
"             <NameMasq Nb=\"1\" Type=\"std::string\"> </NameMasq>\n",
"             <ZoomBegin Nb=\"?\" Def=\"16\"  Type=\"int\"> </ZoomBegin>\n",
"             <Dilate Nb=\"?\" Def=\"2\"  Type=\"int\"> </Dilate>\n",
"             <PrefixNuage Nb=\"?\"  Type=\"std::string\"> </PrefixNuage>\n",
"        </MMUseMasq3D>\n",
"\n",
"        <EtapeMEC Nb=\"+\" DeltaPrec=\"1\">\n",
"            <DeZoom  Nb=\"1\" Type=\"int\">                    </DeZoom>\n",
"\n",
"\n",
"            <CorrelAdHoc Nb=\"?\">\n",
"\n",
"                <EpsilonAddMoyenne Nb=\"?\" Type=\"double\" Def=\"0.0\"> </EpsilonAddMoyenne>\n",
"                <EpsilonMulMoyenne Nb=\"?\" Type=\"double\" Def=\"0.0\"> </EpsilonMulMoyenne>\n",
"\n",
"                <SzBlocAH Nb=\"?\" Type=\"int\" Def=\"40\"> </SzBlocAH>\n",
"                <CorrelMultiScale Nb=\"?\">                      \n",
"                      <UseGpGpu Nb=\"?\" Type=\"bool\" Def=\"false\"> </UseGpGpu>\n",
"                      <ModeDense Nb=\"?\" Type=\"bool\"> </ModeDense>\n",
"                      <!-- Si true un indicateur de forme est calcule sur l'image maitresse pour choisir quel type de fenetre est utilise -->\n",
"                      <UseWAdapt Nb=\"?\" Type=\"bool\" Def=\"false\"> </UseWAdapt>\n",
"                      <ModeMax Nb=\"?\" Type=\"bool\" Def=\"false\">  </ModeMax> <!--Pour l'instant Uniquement Implante dans la filiere Census-->\n",
"                      <OneParamCMS Nb=\"+\" Container=\"std::vector\">\n",
"                           <SzW Nb=\"1\" Type=\"Pt2di\"> </SzW>\n",
"                           <!-- A priori Sigma doit etre fonction de  SzW, mais quelle fonction ?? -->\n",
"                           <Sigma Nb=\"1\" Type=\"double\"> </Sigma>\n",
"                           <!-- Poids apres normalisation des tailles de fenetres -->\n",
"                           <Pds Nb=\"1\" Type=\"double\"> </Pds> \n",
"                           <!-- Si pas Square W : filtre gauss -->\n",
"                           <SquareW Nb=\"?\" Type=\"bool\" Def=\"false\"> </SquareW> \n",
"                      </OneParamCMS>\n",
"                </CorrelMultiScale>\n",
"\n",
"                        <!-- Si Correl2DLeastSquare  L'algo doit obligat etre eAlgoLeastSQ -->\n",
"\n",
"\n",
"\n",
"                <!-- Plus union car peut avoir CensusCost + MultiCorrelPonctuel-->\n",
"\n",
"                <TypeCAH Nb=\"1\" >\n",
"                        <CensusCost Nb=\"?\" AccessorFils=\"false\">\n",
"                              <!-- Utilisable pour rehausser la dynamique tres basse des points census-->\n",
"                              <Dyn    Type=\"double\" Def=\"1.0\" Nb=\"?\">  </Dyn>\n",
"\n",
"                              <!-- Unused\n",
"                              <PdsCrown  Type=\"double\" Def=\"0.5\" Nb=\"?\"> </PdsCrown>\n",
"                              -->\n",
"                              <TypeCost Type=\"eModeCensusCost\" Nb=\"1\">   </TypeCost>\n",
"                              <Verif Type=\"bool\" Nb=\"?\" Def=\"false\">   </Verif>\n",
"                              <!-- Dans Census basic -->\n",
"                              <AttenDist  Type=\"double\" Def=\"0.0\" Nb=\"?\"> </AttenDist>\n",
"                              <!-- Uniquement si on mixte avec correl standard -->\n",
"                              <SeuilHautCorMixte Type=\"double\" Def=\"0.8\" Nb=\"?\"> </SeuilHautCorMixte>\n",
"                              <SeuilBasCorMixte Type=\"double\" Def=\"0.6\" Nb=\"?\">  </SeuilBasCorMixte>\n",
"                        </CensusCost>\n",
"\n",
"\n",
"                        <Correl2DLeastSquare Nb=\"?\" AccessorFils=\"false\">    \n",
"                             <SzW Nb=\"1\" Type=\"int\"> </SzW>\n",
"                             <PeriodEch Nb=\"1\" Type=\"int\"> </PeriodEch>\n",
"                             <Step Nb=\"?\" Type=\"double\" Def=\"1.0\"> </Step>\n",
"                        </Correl2DLeastSquare>\n",
"\n",
"\n",
"                        <GPU_Correl Nb=\"?\" AccessorFils=\"false\">    \n",
"                                <Unused Nb=\"?\" Type=\"std::string\"> </Unused>\n",
"                        </GPU_Correl>\n",
"\n",
"                        <MutiCorrelOrthoExt Nb=\"?\" AccessorFils=\"false\">    \n",
"                                <Cmd Nb=\"?\" Type=\"std::string\" Def=\"MMVII  DM4MatchMultipleOrtho \"> </Cmd>\n",
"                                <Options Nb=\"?\" Type=\"std::string\"> </Options>\n",
"                                <DeltaZ Nb=\"?\" Type=\"int\" Def=\"50\"> </DeltaZ>\n",
"                        </MutiCorrelOrthoExt>\n",
"\n",
"                        <!-- Afin de conserver le max de simplicite -->\n",
"                        <GPU_CorrelBasik Nb=\"?\" AccessorFils=\"false\">    \n",
"                                <Unused Nb=\"?\" Type=\"std::string\"> </Unused>\n",
"                        </GPU_CorrelBasik>\n",
"\n",
"\n",
"                        <MultiCorrelPonctuel Nb=\"?\"  AccessorFils=\"false\">\n",
"                                <PdsCorrelStd   Nb=\"1\" Type=\"double\" > </PdsCorrelStd>\n",
"                                <PdsCorrelCroise Nb=\"1\" Type=\"double\" > </PdsCorrelCroise>\n",
"                                <DynRadCorrelPonct Nb=\"?\" Type=\"double\" Def=\"1.0\" > </DynRadCorrelPonct>\n",
"                                <DefCost  Nb=\"?\" Type=\"double\" Def=\"0.1\"> </DefCost>\n",
"                                <MCP_AttachePixel Nb=\"?\">\n",
"                                      <Pds Nb=\"1\" Type=\"double\"> </Pds>\n",
"                                      <!-- Si xml => fichier des valeur constantes, sinon cle de calcul de l'image -->\n",
"                                      <KeyRatio Nb=\"1\" Type=\"std::string\"> </KeyRatio>\n",
"                                </MCP_AttachePixel>\n",
"                        </MultiCorrelPonctuel>\n",
"\n",
"			<ScoreLearnedMMVII Nb=\"?\" AccessorFils=\"false\">\n",
"                              <FileModeleCost Nb=\"1\" Type=\"std::string\">           </FileModeleCost>\n",
"                              <CostDyn        Nb=\"?\" Type=\"double\" Def=\"0.3333\">   </CostDyn>\n",
"                              <CostExp        Nb=\"?\" Type=\"double\" Def=\"0.5\">      </CostExp>\n",
"                              <Cmp_FileMC     Nb=\"?\" Type=\"std::string\">           </Cmp_FileMC>\n",
"                              <Cmp_NbDisc     Nb=\"?\" Type=\"int\"    Def=\"200\">      </Cmp_NbDisc>\n",
"                        </ScoreLearnedMMVII>\n",
"\n",
"                        <Correl_Ponctuel2ImGeomI Nb=\"?\" AccessorFils=\"false\">    \n",
"                              <RatioI1I2 Nb=\"?\" Type=\"double\" Def=\"1.0\"> </RatioI1I2>\n",
"                        </Correl_Ponctuel2ImGeomI>\n",
"\n",
"                        <Correl_PonctuelleCroisee Nb=\"?\" AccessorFils=\"false\">    \n",
"                              <RatioI1I2 Nb=\"?\" Type=\"double\" Def=\"1.0\"> </RatioI1I2>\n",
"                              <PdsPonctuel Nb=\"1\" Type=\"double\"> </PdsPonctuel>\n",
"                              <PdsCroisee  Nb=\"1\" Type=\"double\"> </PdsCroisee>\n",
"                        </Correl_PonctuelleCroisee>\n",
"\n",
"                        <Correl_MultiFen Nb=\"?\" AccessorFils=\"false\">    \n",
"                              <NbFen Nb=\"1\" Type=\"int\"> </NbFen>\n",
"                        </Correl_MultiFen>\n",
"\n",
"                        <Correl_Correl_MNE_ZPredic  Nb=\"?\" AccessorFils=\"false\">    \n",
"                              <SeuilDZ Nb=\"1\" Type=\"double\"> </SeuilDZ>\n",
"                        </Correl_Correl_MNE_ZPredic>\n",
"\n",
"                       <!-- Mesure supposee robuste de correlation non centree normalisee par le pixel central -->\n",
"                        <Correl_NC_Robuste  Nb=\"?\" AccessorFils=\"false\">    \n",
"                              <Unused Nb=\"?\" Type=\"std::string\"> </Unused>\n",
"                        </Correl_NC_Robuste>\n",
"\n",
"                        <MasqueAutoByTieP Nb=\"?\" AccessorFils=\"false\"> \n",
"                            <FilterPrgDyn Nb=\"?\" RefType=\"ParamFiltreDepthByPrgDyn\"  RefFile=\"SuperposImage.xml\"> </FilterPrgDyn>\n",
"                            <!-- Si true, s'arrete apres avoir rechecher les point qui correlent bien sans chercher a boucher les trous -->\n",
"                            <ComputeAndExportEnveloppe Nb=\"?\">\n",
"\n",
"                                   <EndAfter Nb=\"?\" Type=\"bool\" Def=\"true\"> </EndAfter>\n",
"                                   <NuageExport Nb=\"?\" Type=\"std::string\"> </NuageExport>\n",
"                                   <SsEchFilter Type=\"double\" Nb=\"?\" Def=\"3.0\"> </SsEchFilter>\n",
"                                   <SzFilter    Type=\"int\" Nb=\"?\" Def=\"7\"> </SzFilter>\n",
"                                   <ParamPropFilter    Type=\"double\" Nb=\"?\" Def=\"0.9\"> </ParamPropFilter>\n",
"\n",
"                                   <ProlResolCible Type=\"double\" Nb=\"?\" Def=\"25\">   </ProlResolCible>\n",
"                                   <ProlResolCur  Type=\"double\" Nb=\"?\" Def=\"10\"> </ProlResolCur>\n",
"                                   <ProlDistAdd Type=\"double\" Nb=\"?\" Def=\"0.25\"> </ProlDistAdd>\n",
"                                   <ProlDistAddMax Nb=\"?\" Type=\"double\" Def=\"3.0\"> </ProlDistAddMax>\n",
"\n",
"                                   <DilatAltiCible Nb=\"?\" Type=\"int\" Def=\"5\"> </DilatAltiCible>\n",
"                                   <DilatPlaniCible Nb=\"?\" Type=\"int\" Def=\"5\"> </DilatPlaniCible>\n",
"                                   <DilatPlaniCur Nb=\"?\" Type=\"int\" Def=\"2\"> </DilatPlaniCur>\n",
"                                   <DilatAltiCur Nb=\"?\" Type=\"int\" Def=\"2\"> </DilatAltiCur>\n",
"                            </ComputeAndExportEnveloppe>\n",
"                            <!-- Filtre permettant de supprimer le ciel (sans nuage ...) en virant les zones tres homogenes -->\n",
"                            <mmtpFilterSky Nb=\"?\">\n",
"                                <PertPerPix Type=\"double\" Nb=\"?\" Def=\"0.005\"> </PertPerPix>\n",
"                                <SzKernelHom Type=\"int\" Nb=\"?\" Def=\"5\"> </SzKernelHom>\n",
"                                <PropZonec  Type=\"double\" Nb=\"?\" Def=\"0.001\"> </PropZonec>\n",
"                            </mmtpFilterSky>\n",
"\n",
"                            <BasicOneIter Type=\"bool\" Def=\"true\" Nb=\"?\"> </BasicOneIter>\n",
"                            <Masq3D Nb=\"?\" Type=\"std::string\">        </Masq3D>\n",
"                            <ParamFiltreRegProf RefType=\"ParamFiltreDetecRegulProf\" Nb=\"?\"  RefFile=\"SuperposImage.xml\"> </ParamFiltreRegProf>\n",
"\n",
"                            <GlobFilePt3D  Nb=\"?\" Type=\"std::string\"> </GlobFilePt3D>\n",
"                            <KeyImFilePt3D  Nb=\"1\" Type=\"std::string\"> </KeyImFilePt3D>\n",
"                            <DeltaZ Nb=\"1\" Type=\"int\"> </DeltaZ>\n",
"<!-- Attention, ce sont distance Correl = (2-D) /2.0 , donc D>0.6 equiv correl < 0.7 -->\n",
"                            <SeuilSomCostCorrel Nb=\"1\" Type=\"double\"> </SeuilSomCostCorrel>\n",
"                            <SeuilMaxCostCorrel Nb=\"1\" Type=\"double\"> </SeuilMaxCostCorrel>\n",
"                            <SeuilMedCostCorrel Nb=\"1\" Type=\"double\"> </SeuilMedCostCorrel>\n",
"                            <Visu Nb=\"?\" Type=\"bool\" Def=\"false\"> </Visu>\n",
"                            <ImPaintResult Nb=\"?\"  Type=\"eImpaintMethod\" Def=\"eImpaintL2\"> </ImPaintResult>\n",
"                            <ParamIPMnt Nb=\"?\" Type=\"double\" Def=\"1.0\"> </ParamIPMnt>\n",
"\n",
"                            <TiePMasqIm Nb=\"?\">\n",
"                                 <DeZoomRel Nb=\"1\" Type=\"int\"> </DeZoomRel>\n",
"                                 <Dilate Nb=\"1\" Type=\"int\">   </Dilate>\n",
"                            </TiePMasqIm>\n",
"                            <DoImageLabel Nb=\"?\" Type=\"bool\" Def=\"false\"> </DoImageLabel>\n",
"                        </MasqueAutoByTieP> \n",
"                </TypeCAH>\n",
"            </CorrelAdHoc>\n",
"\n",
"            <DoImageBSurH Nb=\"?\" AccessorFils=\"false\">\n",
"                 <Dyn Nb=\"?\" Type=\"double\" Def=\"1e-2\"> </Dyn>\n",
"                 <!-- Offset >0 si on veut stocker les eventuel B/H neg (vue derriere la cam) -->\n",
"                 <Offset Nb=\"?\" Type=\"double\" Def=\"0\"> </Offset>\n",
"                 <SeuilMasqExport Nb=\"?\" Type=\"double\"> </SeuilMasqExport>\n",
"                 <Name Nb=\"1\" Type=\"std::string\"> </Name>\n",
"                 <ScaleNuage Nb=\"1\" Type=\"double\"> </ScaleNuage>\n",
"                 <NameNuage Nb=\"1\" Type=\"std::string\"> </NameNuage>\n",
"            </DoImageBSurH>\n",
"\n",
"             <DoStatResult Nb=\"?\">\n",
"                  <DoRatio2Im Nb=\"1\" Type=\"bool\"> </DoRatio2Im>\n",
"             </DoStatResult>\n",
"\n",
"            <!-- Permet de specifier un  masque special a l'etape\n",
"                 et a l'image\n",
"            -->\n",
"            <MasqOfEtape Nb=\"*\">\n",
"                <PatternApply Nb=\"1\" Type=\"cElRegex_Ptr\"> </PatternApply>\n",
"                <RectInclus Nb=\"?\" Type=\"Box2dr\"> </RectInclus>\n",
"            </MasqOfEtape>\n",
"            <!-- Pour raison de compatibilite, les valeurs par defaut sont\n",
"              donnees dans la section Section_WorkSpace, une valeur\n",
"              peut etre redefinie pour chaque etape -->\n",
"	    <SzRecouvrtDalles Nb=\"?\"  Type=\"int\"> </SzRecouvrtDalles>\n",
"	    <SzDalleMin       Nb=\"?\"  Type=\"int\"> </SzDalleMin>\n",
"	    <SzDalleMax       Nb=\"?\"  Type=\"int\"> </SzDalleMax>\n",
"\n",
"            <DynamiqueCorrel Nb=\"?\" Type=\"eModeDynamiqueCorrel\"> \n",
"            </DynamiqueCorrel>\n",
"\n",
"            <!-- Un moyen basique de ne pas tenir compte des correlations faibles\n",
"            est de dire que si Correl < CorrelMin alors Correl = CorrelMin -->\n",
"            <CorrelMin Nb=\"?\" Type=\"double\" > </CorrelMin>\n",
"            <!-- Gamma de 2, ecrase les correl faible => VOIR FORMULE Cor2Cost -->\n",
"            <GammaCorrel Nb=\"?\" Type=\"double\" > </GammaCorrel>\n",
"\n",
"            <AggregCorr Nb=\"?\" Type=\"eModeAggregCorr\"> \n",
"            </AggregCorr>\n",
"\n",
"	    <!-- Peut etre reel dans le cas de WithFenetreExp -->\n",
"            <SzW    Nb=\"?\"  Type=\"double\">      </SzW>\n",
"	    <!-- En cas de fenetre speciales, faut il utiliser un masque\n",
"	    des images globales, plus rigoureux mais diminue la zone\n",
"	    de calcul ; defaut true ssi NbIm=2-->\n",
"	    <WSpecUseMasqGlob Nb=\"?\" Type=\"bool\"> </WSpecUseMasqGlob>\n",
"	    <TypeWCorr Nb=\"?\" Type=\"eTypeWinCorrel\"> </TypeWCorr>\n",
"	       <!-- Pas defaut egal a SzWx, pour l'instant ne peut etre !=\n",
"	       avec le mode habituel eWInCorrelFixe (car oubli de prise en compte au depart)\n",
"	       -->\n",
"	    <SzWy  Nb=\"?\"  Type=\"double\">      </SzWy>\n",
"	    <NbIterFenSpec Nb=\"?\" Type=\"int\"> </NbIterFenSpec>\n",
"\n",
"\n",
"             <!-- Vaut il mieux  (1) filtrer par le gradient puis calculer le sous-ech, ou (2) l'inverse ?\n",
"	         si c'est  (1) on utilise FiltreImageIn, sinon FiltreImageLoc, applique a la volee,\n",
"		 fait le (2) -->\n",
"            <FiltreImageLoc Nb=\"*\" RefType=\"SpecFitrageImage\"> </FiltreImageLoc>\n",
"\n",
"            <!-- Taille de la fenetre utilisee pour calculer les ecarts\n",
"                 types, par defaut vaut SzW -->\n",
"            <SzWInt    Nb=\"?\"  Type=\"int\">      </SzWInt>\n",
"\n",
"            <!-- Eventuelle sur echantillonage de la fenetre de correlation, par defaut\n",
"                 vaut 1 -->\n",
"            <SurEchWCor Nb=\"?\"  Type=\"int\"> </SurEchWCor>\n",
"\n",
"	    <AlgoRegul Nb=\"?\" Type=\"eAlgoRegul\"> </AlgoRegul>\n",
"            <!-- Uniquemenet accepte pour les algos continus -->\n",
"            <ExportZAbs Nb=\"?\" Type=\"bool\" Def=\"false\"> </ExportZAbs>\n",
"	    <AlgoWenCxRImpossible Nb=\"?\" Type=\"eAlgoRegul\"> </AlgoWenCxRImpossible>\n",
"\n",
"\n",
"            <CoxRoy8Cnx Nb=\"?\" Type=\"bool\"> </CoxRoy8Cnx>     <!-- Def=false-->\n",
"            <CoxRoyUChar Nb=\"?\" Type=\"bool\"> </CoxRoyUChar>   <!-- Def=true-->\n",
"\n",
"\n",
"            <ModulationProgDyn Nb=\"?\">\n",
"                <EtapeProgDyn  Nb=\"+\">\n",
"                     <Px1MultRegul Nb=\"?\" Type=\"std::vector<double>\"> </Px1MultRegul>\n",
"                     <Px2MultRegul Nb=\"?\" Type=\"std::vector<double>\"> </Px2MultRegul>\n",
"                     <NbDir Nb=\"?\" Type=\"int\" Def=\"2\">             </NbDir>\n",
"                     <ModeAgreg Type=\"eModeAggregProgDyn\" Nb=\"1\">  </ModeAgreg>\n",
"                     <Teta0 Nb=\"?\" Type=\"double\" Def=\"0.0\">         </Teta0>\n",
"                </EtapeProgDyn>\n",
"                <Px1PenteMax Nb=\"?\" Type=\"double\" Def=\"10.0\"> </Px1PenteMax>\n",
"                <Px2PenteMax Nb=\"?\" Type=\"double\" Def=\"10.0\"> </Px2PenteMax>\n",
"                <!-- Essentiellement pour mise au point, sinon il vaut mieux laisser MM chosir -->\n",
"                <ChoixNewProg Nb=\"?\" Type=\"bool\"> </ChoixNewProg>\n",
"                <ArgMaskAuto Nb=\"?\">\n",
"                      <ValDefCorrel Nb=\"1\" Type=\"double\"> </ValDefCorrel>\n",
"                      <CostTrans Nb=\"1\" Type=\"double\"> </CostTrans>\n",
"                      <ReInjectMask Nb=\"?\" Type=\"bool\" Def=\"true\"> </ReInjectMask>\n",
"\n",
"                      <AmplKLPostTr Nb=\"?\" Def=\"100.0\" Type=\"double\"> </AmplKLPostTr>\n",
"                      <!-- Erosion pour prendre en compte les imprecisions, par defaut\n",
"                        2 si diff de zoom, 0 si zoom maintenu , donne en distance 3-2, a pour effet \n",
"                        d'aggrandir la zone correllee -->\n",
"                      <Erod32Mask Nb=\"?\" Type=\"int\" > </Erod32Mask>\n",
"                      <!-- Diminue la zone correllee -->\n",
"                      <SzOpen32 Nb=\"?\" Type=\"int\" Def=\"9\" > </SzOpen32>\n",
"                      <SeuilZC Nb=\"?\" Type=\"int\" Def=\"200\" > </SeuilZC>\n",
"                      <!-- Ne peut etre utilise qu'avec le mode eAggregMaxIm1Maitre -->\n",
"                      <EtiqBestImage Nb=\"?\">\n",
"                             <CostChangeEtiq Nb=\"1\" Type=\"double\"> </CostChangeEtiq>\n",
"                             <SauvEtiq Nb=\"?\" Type=\"bool\" Def=\"false\"> </SauvEtiq>\n",
"                      </EtiqBestImage>\n",
"                </ArgMaskAuto>\n",
"            </ModulationProgDyn>\n",
"\n",
"            <!-- Ce vecteur (PrgDynMultRegul) est utilise pour moduler l'evolution \n",
"                 du cout de regularisation de PrgDyn au cour des differents balayage. \n",
"                 De maniere a avoir un comportement le plus proche possible de \n",
"                 CoxRoy. Normalement il est determine  automatiquement. \n",
"             \n",
"            --> \n",
"<!--\n",
"            <DirectionsProgdyn Nb=\"*\" Type=\"Pt2dr\"> </DirectionsProgdyn>\n",
"            <Px1PrgDynMultRegul Nb=\"*\" Type=\"double\"> </Px1PrgDynMultRegul>\n",
"            <Px2PrgDynMultRegul Nb=\"*\" Type=\"double\"> </Px2PrgDynMultRegul>\n",
"\n",
"             <Px1PenteMax Nb=\"?\" Type=\"double\" Def=\"10.0\"> </Px1PenteMax>\n",
"             <Px2PenteMax Nb=\"?\" Type=\"double\" Def=\"10.0\"> </Px2PenteMax>\n",
"-->\n",
"\n",
"            <SsResolOptim Nb=\"?\" Type=\"int\" > </SsResolOptim> <!-- Def = 1  -->\n",
"<!--\n",
"      On peut souhaiter avoir un pas MNT plus fin que la resolution image.\n",
"      Si la resolution image est de 20 cm, par ex faire un MNT a 10. Si on\n",
"      laisse les option de MICMAC telle quelle, il va faire a ss/resolution\n",
"      2 du MNT (cad a resol 20 cm) utiliser des images a ss-resol 2, donc\n",
"      a 40 au lieu des 20 disponibles. C'est ballot !\n",
"           Le parametre RatioDeZoomImage permet de controler cela. Mettre 0.5 dans le cas precedent\n",
"          \n",
"-->\n",
"            <RatioDeZoomImage Nb=\"?\" Type=\"double\"> </RatioDeZoomImage> <!-- Def = 1  -->\n",
"\n",
"        <!-- Regle la quantif des tabul d'interpol -->\n",
"            <NdDiscKerInterp Nb=\"?\" Type=\"int\"> </NdDiscKerInterp> <!-- Def 1000 -->\n",
"            <ModeInterpolation Nb=\"?\" Type=\"eModeInterpolation\"> </ModeInterpolation>\n",
"<!--\n",
"      Dans le cas de l'interpolation bicubique, on peut specifier le parametre de la famille, \n",
"entre -0.5 et -3. Par defaut, on est a -0.5, ce qui transforme une droite en droite. Pour etre\n",
"plus proche du sinus cardinal, il vaut mieux etre autour de -1.2.\n",
"-->\n",
"            <CoefInterpolationBicubique Nb=\"?\" Type=\"double\"> </CoefInterpolationBicubique>  <!-- Def -0.5 -->\n",
"\n",
"            <SzSinCard Nb=\"?\" Type=\"double\" > </SzSinCard> <!-- Def 5.0 -->\n",
"            <!-- Fenetre de Tukey, si SzSinCard=<SzAppodSinCard alors c'est une fenetre de Hanning -->\n",
"            <SzAppodSinCard Nb=\"?\" Type=\"double\"> </SzAppodSinCard>\n",
"<!--\n",
"      OBSOLETE CAR UTILISE DANS LE VIEUX SINCARD  : eOldInterpolSinCard\n",
"\n",
"\n",
"      Dans le cas de l'interpolation par sinus cardinal, on peut specifier la taille de la fenetre \n",
"	a prendre en compte. plus c'est grand, plus c'est precis et plus c'est lent...\n",
"	On peut egalement specifier si on souhaite apodiser par une gaussienne, afin de diminuer les effets \n",
"	de limitation de la taille de la fenetre. Par defaut, on ne le fait pas, pour avoir le meme\n",
"	comportement qu'avant\n",
"-->\n",
"            <TailleFenetreSinusCardinal Nb=\"?\" Type=\"int\" Def=\"3\"> </TailleFenetreSinusCardinal>\n",
"            <ApodisationSinusCardinal Nb=\"?\" Type=\"bool\" Def=\"false\"> </ApodisationSinusCardinal>\n",
"	    <!-- \n",
"	        En mode eGeomMECTerrain les Z* ci dessous\n",
"	    doivent tous avoir une valeur et les Px1*,Px2* aucun.\n",
"	    Vice-versa en mode eGeomMECIm1\n",
"	    -->\n",
"\n",
"            <!--\n",
"                Est-ce que la geometrie est suffisament reguliere pour\n",
"               que l'on puisse utiliser des difference finie pour \n",
"               eviter de la cacluler trop souvent.\n",
" \n",
"                 Par defaut :\n",
"                     - Diff finie OK sur Fenetre 5x5 (taille 2)\n",
"                       si il n'y a pas de redressement\n",
"                     - Diff finie non valides;\n",
"            -->\n",
"            <SzGeomDerivable Nb=\"?\" Type=\"int\"> </SzGeomDerivable>\n",
"\n",
"            <!-- Permet d'avoir de couts concaves qui favoriseront\n",
"               les sauts brusques -->\n",
"            <SeuilAttenZRegul Nb=\"?\"  Type=\"double\"> </SeuilAttenZRegul>\n",
"            <AttenRelatifSeuilZ Nb=\"?\"  Type=\"double\"> </AttenRelatifSeuilZ> <!-- Def 0.2 -->\n",
"\n",
"            <!-- Le parametre de pas en Pax, est en proportion du pas\n",
"            en \"terrain\", cela assure que ZPas=1.0 est toujours une\n",
"            valeur raisonnable pour un premier essai -->\n",
"            <ZRegul_Quad Nb=\"?\"  Type=\"double\">     </ZRegul_Quad>\n",
"            <ZRegul Nb=\"?\"  Type=\"double\">     </ZRegul>\n",
"            <ZPas  Nb=\"?\"  Type=\"double\">     </ZPas>\n",
"\n",
"             <!-- Ces deux valeurs permettent de gerer le fait que, la notion de\n",
"             partie cache etant completement disymetrique, on peur avoir de bonne raison de \n",
"             recherche + vers le bas que vers le haut -->\n",
"	    <RabZDilatAltiMoins   Nb=\"?\" Type=\"int\">   </RabZDilatAltiMoins>\n",
"	    <RabZDilatPlaniMoins   Nb=\"?\" Type=\"int\">  </RabZDilatPlaniMoins>\n",
"\n",
"	    <ZDilatAlti   Nb=\"?\" Type=\"int\">   </ZDilatAlti>\n",
"            <ZDilatPlani  Nb=\"?\" Type=\"int\">   </ZDilatPlani>\n",
"            <ZDilatPlaniPropPtsInt  Nb=\"?\" Type=\"double\">   </ZDilatPlaniPropPtsInt>\n",
"            <ZRedrPx Nb=\"?\" Type=\"bool\">      </ZRedrPx>\n",
"            <ZDeqRedr Nb=\"?\" Type=\"bool\">      </ZDeqRedr>\n",
"            <!-- Faut il dequantifier la px de redressement, defaut = true-->\n",
"            <RedrNbIterMed Nb=\"?\" Type=\"int\"></RedrNbIterMed> <!-- Def 2 -->\n",
"            <RedrSzMed Nb=\"?\" Type=\"int\"></RedrSzMed>  <!-- Def 2 -->\n",
"            <RedrSauvBrut Nb=\"?\" Type=\"bool\"></RedrSauvBrut> <!-- false -->\n",
"\n",
"            <RedrNbIterMoy Nb=\"?\" Type=\"int\"></RedrNbIterMoy> <!-- Def 3 -->\n",
"            <RedrSzMoy Nb=\"?\" Type=\"int\"></RedrSzMoy>         <!-- Def 8 -->\n",
"\n",
"            <Px1Regul_Quad Nb=\"?\"  Type=\"double\">     </Px1Regul_Quad>\n",
"            <Px1Regul Nb=\"?\"  Type=\"double\">     </Px1Regul>\n",
"            <Px1Pas  Nb=\"?\"  Type=\"double\">     </Px1Pas>\n",
"	    <Px1DilatAlti   Nb=\"?\" Type=\"int\">   </Px1DilatAlti>\n",
"            <Px1DilatPlani  Nb=\"?\" Type=\"int\">   </Px1DilatPlani>\n",
"            <Px1DilatPlaniPropPtsInt  Nb=\"?\" Type=\"double\">   </Px1DilatPlaniPropPtsInt>\n",
"            <Px1RedrPx Nb=\"?\" Type=\"bool\">      </Px1RedrPx>\n",
"            <Px1DeqRedr Nb=\"?\" Type=\"bool\">      </Px1DeqRedr> <!-- Def true-->\n",
"\n",
"            <Px2Regul_Quad Nb=\"?\"  Type=\"double\">     </Px2Regul_Quad>\n",
"            <Px2Regul Nb=\"?\"  Type=\"double\">     </Px2Regul>\n",
"            <Px2Pas  Nb=\"?\"  Type=\"double\">     </Px2Pas>\n",
"	    <Px2DilatAlti   Nb=\"?\" Type=\"int\">   </Px2DilatAlti>\n",
"            <Px2DilatPlani  Nb=\"?\" Type=\"int\">   </Px2DilatPlani>\n",
"            <Px2DilatPlaniPropPtsInt  Nb=\"?\" Type=\"double\">   </Px2DilatPlaniPropPtsInt>\n",
"            <Px2RedrPx Nb=\"?\" Type=\"bool\">      </Px2RedrPx>\n",
"            <Px2DeqRedr Nb=\"?\" Type=\"bool\">      </Px2DeqRedr> <!-- Def true-->\n",
"            <!-- Pre redressement en fonction des Px calc, Def = false-->\n",
"\n",
"         <!-- Parametre reglant l'utilisation des contours -->\n",
"	    <!--   <UseContours Nb=\"?\" Type=\"bool\" >   </UseContours>  -->\n",
"\n",
"\n",
"         <!--  Filtrage a posteriori des paralaxe -->\n",
"            <PostFiltragePx Nb=\"?\">\n",
"                  <OneFitragePx Nb=\"*\" RefType=\"SpecFitrageImage\"> \n",
"                  </OneFitragePx>\n",
"            </PostFiltragePx>\n",
"	 <!-- Filtrage pour suprimer les discontinuites, un peu redondant avec le\n",
"	      precedent mais 1/appliquable qq soit l'algo 2/ + oriente filtrage lineaire\n",
"	 -->\n",
"	     <PostFiltrageDiscont Nb=\"?\">\n",
"	          <SzFiltre Nb=\"1\" Type=\"double\"> </SzFiltre>\n",
"		  <!-- + c'est grand + on se rapproche de la gaussienne -->\n",
"	          <NbIter Nb=\"?\" Type=\"int\" Def=\"2\"> </NbIter>\n",
"\n",
"                  <!-- Par defaut pas de ponderation-->\n",
"		  <ExposPonderGrad Nb=\"?\" Type=\"double\" Def=\"2.0\">   </ExposPonderGrad>\n",
"		  <DericheFactEPC Nb=\"?\" Type=\"double\" Def=\"1.0\"> </DericheFactEPC>\n",
"		  <ValGradAtten Nb=\"?\" Type=\"double\">             </ValGradAtten>\n",
"\n",
"\n",
"		  <ExposPonderCorr Nb=\"?\" Type=\"double\"> </ExposPonderCorr>\n",
"	          \n",
"	     </PostFiltrageDiscont>\n",
"\n",
"\n",
"          <!-- Permet d'utiliser un ensemble d'images variable en fonction\n",
"               de l'etape de calcul, typiquement pour ne rajouter les images\n",
"               obliques que vers la fin\n",
"           -->\n",
"            <ImageSelecteur Nb=\"?\">\n",
"                   <ModeExclusion Nb=\"1\" Type=\"bool\"> </ModeExclusion>\n",
"                   <PatternSel Nb=\"*\" Type=\"std::string\"> </PatternSel>\n",
"            </ImageSelecteur>\n",
"\n",
"         <!-- Si on doit selectionner selon une relation / a image1 -->\n",
"            <RelSelecteur Nb=\"?\" RefType=\"ParamGenereStrVois\" RefFile=\"SuperposImage.xml\"> </RelSelecteur>\n",
"\n",
"          <!--\n",
"               Generation de visualisation des resultat intermediaires\n",
"          -->\n",
"                    <!-- Images en 8 Bits -->\n",
"            <Gen8Bits_Px1 Nb=\"?\" Type=\"bool\">    </Gen8Bits_Px1>\n",
"            <Offset8Bits_Px1 Nb=\"?\" Type=\"int\">  </Offset8Bits_Px1>\n",
"            <Dyn8Bits_Px1 Nb=\"?\" Type=\"double\">  </Dyn8Bits_Px1>\n",
"            <Gen8Bits_Px2 Nb=\"?\" Type=\"bool\">    </Gen8Bits_Px2>\n",
"            <Offset8Bits_Px2 Nb=\"?\" Type=\"int\">  </Offset8Bits_Px2>\n",
"            <Dyn8Bits_Px2 Nb=\"?\" Type=\"double\">  </Dyn8Bits_Px2>\n",
"\n",
"            <ArgGen8Bits  Nb=\"*\" Type=\"std::string\"> </ArgGen8Bits>\n",
"\n",
"            <GenFilePxRel Nb=\"?\" Type=\"bool\">    </GenFilePxRel>\n",
"             <!-- Generation d'image des coeff de correlation, \n",
"              defaut=false sauf pour la derniere etape \n",
"              -->\n",
"            <GenImagesCorrel Nb=\"?\" Type=\"bool\"> </GenImagesCorrel>\n",
"            <GenCubeCorrel   Nb=\"?\" Type=\"bool\"> </GenCubeCorrel>\n",
"\n",
"\n",
"\n",
"	    <GenerateProjectionInImages Nb=\"*\">\n",
"	        <NumsImageDontApply Nb=\"*\" Type=\"int\"> </NumsImageDontApply>\n",
"		<FCND_CalcProj Nb=\"1\" Type=\"std::string\"> </FCND_CalcProj>\n",
"		<!-- Soustrait l'identdite (X,Y), au resultat; a du sens en GeomIm1 pour\n",
"		avoir + de \"dynamique\"-->\n",
"		<SubsXY  Nb=\"?\" Type=\"bool\" Def=\"false\"> </SubsXY>\n",
"		<Polar  Nb=\"?\" Type=\"bool\" Def=\"false\"> </Polar>\n",
"                <GenerateImageRedr Nb=\"?\">\n",
"                     <FCND_CalcRedr Nb=\"1\" Type=\"std::string\"> </FCND_CalcRedr>\n",
"                     <Type Nb=\"?\" Type=\"eTypeNumerique\" > </Type>\n",
"                </GenerateImageRedr>\n",
"	    </GenerateProjectionInImages>\n",
"\n",
"\n",
"             <!-- Generation d'une image reduite de Px transv pour creer un CorrectionPxTransverse-->\n",
"\n",
"	     <GenCorPxTransv Nb=\"?\">\n",
"	           <!-- Par rapport a une resol de 1-->\n",
"	            <SsResolPx  Nb=\"1\" Type=\"double\">          </SsResolPx>\n",
"		    <NameXMLFile   Nb=\"1\" Type=\"std::string\">  </NameXMLFile>\n",
"	     </GenCorPxTransv>\n",
"\n",
"	     \n",
"	     <ExportAsModeleDist  Nb=\"*\"\n",
"	            RefType=\"GenereModeleRaster2Analytique\"\n",
"		    RefFile=\"SuperposImage.xml\"\n",
"	     >\n",
"	     </ExportAsModeleDist>\n",
"\n",
"\n",
"             \n",
"            <!--\n",
"                  Parametres specifiques a l'optimisation differentielle,\n",
"            -->\n",
"            <OptDif_PxApply Type=\"ePxApply\" Nb=\"?\"></OptDif_PxApply> <!--Def eApplyPx12 -->\n",
"\n",
"            <!--\n",
"                  Permet de lancer une interface de visualisation, pour eventuel\n",
"                  \"debugage/mis au point\"\n",
"            -->\n",
"             <InterfaceVisualisation Nb=\"?\">\n",
"                         <!-- Si pas de Visu Terrain souhaitee : SzWTerr <0 -->\n",
"                 <VisuTerrainIm Type=\"bool\" Nb=\"?\" Def=\"true\"> </VisuTerrainIm>\n",
"                 <SzWTerr    Type=\"int\" Nb=\"?\" Def=\"100\">            </SzWTerr>\n",
"                 <UnSelectedImage Type=\"std::string\" Nb=\"*\">         </UnSelectedImage>\n",
"                 <CentreVisuTerrain  Type=\"Pt2di\"  Nb=\"1\">           </CentreVisuTerrain>\n",
"                 <ZoomTerr  Type=\"int\" Nb=\"?\" Def=\"1\"> </ZoomTerr>\n",
"\n",
"                 <!-- Si on souhaite faire un histogramme de la partie fractionnaire-->\n",
"                 <NbDiscHistoPartieFrac Type=\"int\" Nb=\"?\" Def=\"-1\"> </NbDiscHistoPartieFrac>\n",
"\n",
"                 <!-- Simulation du probleme de partie fractionnaire -->\n",
"                 <SimulFrac Nb=\"?\">\n",
"                     <CoutFrac Nb=\"1\" Type=\"double\"> </CoutFrac>\n",
"                 </SimulFrac>\n",
"             </InterfaceVisualisation>\n",
"\n",
"\n",
"             <!--  Export des meta donnees associees a la carte de profondeur pour en faire\n",
"                   un fichier XML utilisable en autonome, par defaut vaut non initialise -->\n",
"             <MMExportNuage Nb=\"*\" UnionType=\"true\"> \n",
"                  <MTD_Nuage_Maille Nb=\"?\">\n",
"                      <!-- Permettra d'embarquer les donnees image dans le fichier xml, pas implante pour l'instant -->\n",
"                      <DataInside Nb=\"?\" Type=\"bool\" Def=\"false\"> </DataInside>\n",
"                      <KeyNameMTD Nb=\"1\" Type=\"std::string\">   </KeyNameMTD>\n",
"                      <RatioPseudoConik Nb=\"?\" Type=\"double\" Def=\"1000\"> </RatioPseudoConik>\n",
"                  </MTD_Nuage_Maille>\n",
"                  <PlyFile Nb=\"?\">\n",
"		      <KeyNamePly Nb=\"?\" Type=\"std::string\" Def=\"Key-Assoc-Nuage-Ply\"></KeyNamePly>\n",
"                      <Binary Nb=\"1\" Type=\"bool\"> </Binary>\n",
"                      <Resolution Nb=\"1\" Type=\"double\"> </Resolution>\n",
"                      <PlyCommentAdd Nb=\"*\" Type=\"std::string\"> </PlyCommentAdd>\n",
"                      \n",
"                      <CannauxExportPly Nb=\"*\">\n",
"                           <NameIm Nb=\"1\" Type=\"std::string\">        </NameIm>\n",
"                           <NamesProperty Nb=\"*\" Type=\"std::string\" Container=\"std::vector\"> </NamesProperty>\n",
"                           <FlagUse Nb=\"?\" Type=\"int\">  </FlagUse>\n",
"                      </CannauxExportPly>\n",
"                  </PlyFile>\n",
"             </MMExportNuage>\n",
"\n",
"             \n",
"\n",
"            <!--\n",
"                  Generation des modeles analytiques\n",
"            -->\n",
"            <ModelesAnalytiques Nb=\"?\">\n",
"                 <OneModeleAnalytique Nb=\"*\">\n",
"\n",
"                   \n",
"\n",
"\n",
"                      <UseIt Nb=\"?\" Type=\"bool\" Def=\"true\"> </UseIt>\n",
"\n",
"		      <KeyNuage3D Nb=\"?\" Type=\"std::string\"></KeyNuage3D>\n",
"\n",
"                   <!-- Type de modele : Hom-polynome, matrice rotation etc -->\n",
"                      <TypeModele   Nb=\"1\" Type=\"eTypeModeleAnalytique\"> </TypeModele>\n",
"                   <!-- En mode Hom-polynome-->\n",
"                      <!-- degre du polynome -->\n",
"		      <HomographieL2 Nb=\"?\" Type=\"bool\" Def=\"true\"> </HomographieL2>\n",
"		      <PolynomeL2 Nb=\"?\" Type=\"bool\" Def=\"true\"> </PolynomeL2>\n",
"                      <DegrePol Nb=\"?\" Type=\"int\"> </DegrePol>\n",
"                   <!-- En modee rotation--> \n",
"                        <!--Liste des  numeros d'angles bloques,   0 : teta_01, 1 : teta_02 , 2 : teta_12\n",
"                         1 et 2 figes donne rotation horizontale -->\n",
"                      <NumsAngleFiges Nb=\"*\" Type=\"int\"></NumsAngleFiges>\n",
"                         <!-- Estimation en mode L1 des orientation -->\n",
"                      <L1CalcOri Nb=\"?\" Type=\"bool\" Def=\"false\"> </L1CalcOri>\n",
"\n",
"\n",
"                   <!-- Noms des fichiers Ori a l'export -->\n",
"                      <AutomSelExportOri Nb=\"?\" Type=\"std::string\"> </AutomSelExportOri>\n",
"                      <AutomNamesExportOri1 Nb=\"?\" Type=\"std::string\"> </AutomNamesExportOri1>\n",
"                      <AutomNamesExportOri2 Nb=\"?\" Type=\"std::string\"> </AutomNamesExportOri2>\n",
"\n",
"                   <!-- Noms des fichiers d'homologues , format binaire et xml -->\n",
"		      <!-- Compatibilite, utiliser Key -->\n",
"                      <AutomNamesExportHomXml Nb=\"?\" Type=\"std::string\"> </AutomNamesExportHomXml>\n",
"                      <AutomNamesExportHomTif Nb=\"?\" Type=\"std::string\"> </AutomNamesExportHomTif>\n",
"                      <AutomNamesExportHomBin Nb=\"?\" Type=\"std::string\"> </AutomNamesExportHomBin>\n",
"		      <AffineOrient Nb=\"?\" Type=\"bool\" Def=\"true\"> </AffineOrient>\n",
"\n",
"		      <!-- Compatibilite, utiliser Key -->\n",
"                      <KeyNamesExportHomXml Nb=\"?\" Type=\"std::string\"> </KeyNamesExportHomXml>\n",
" \n",
"   \n",
"                   <!-- Utilise en mode Ori, si une Valeur S est donnee, avant export \n",
"                        des points homologues sont ceux ci sont pondere par S2/(E2+S2) ou E est le \n",
"                        residu d'intersection (en pixel) des rayons perspectifs\n",
"                   -->\n",
"                      <SigmaPixPdsExport Nb=\"?\" Type=\"double\">           </SigmaPixPdsExport>\n",
"\n",
"\n",
"                   <!--  Si FiltreByCorrel est vrai, la correlation est utilisee pour ponderer les point\n",
"                      Homologues en entree, soit S le seuil donnee par SeuilFiltreCorrel, la ponderation\n",
"                      est binaire (C>S) si UseFCBySeuil est vrai, sinon c'est (C-S) tronque a 0\n",
"                    -->\n",
"                      <FiltreByCorrel   Nb=\"?\" Def=\"false\" Type=\"bool\">  </FiltreByCorrel>\n",
"                      <SeuilFiltreCorrel Nb=\"?\" Def=\"0.2\" Type=\"double\"> </SeuilFiltreCorrel>\n",
"                      <UseFCBySeuil   Nb=\"?\" Def=\"true\" Type=\"bool\">  </UseFCBySeuil>\n",
"		      <ExposantPondereCorrel Nb=\"?\" Def=\"1.0\" Type=\"double\"> </ExposantPondereCorrel>\n",
"\n",
"		      <!--  Le filtrage pas la correlation deja calculee est  utile sur des appariement\n",
"		      \"mous\" tel que la superposition multi spectral, avec des appariements ponctuels, tels\n",
"		      les poinst de liaison, il est un peu redondant avec ce qui a deja ete fait, on se donne\n",
"		      donc la possibilite de recalculer un score qui soit multi-echelle;\n",
"\n",
"		       Le tag UseIt a pour but de permettre le reglage de \"meta fichier\" de parametre\n",
"		       (ils en prevoient plusieur et le frontal choisit celui qui lui convient)\n",
"		      -->\n",
"\n",
"		      <ReCalclCorrelMultiEchelle Nb=\"*\">\n",
"		           <UseIt Nb=\"1\" Type=\"bool\"> </UseIt>\n",
"			   <ScaleSzW Nb=\"+\" Type=\"Pt2di\"> </ScaleSzW> <!-- X = DeZoom, Y = SzW-->\n",
"			   <AgregMin Nb=\"?\" Type=\"bool\" Def=\"true\"> </AgregMin>\n",
"			   <DoImg  Nb=\"?\" Type=\"bool\" Def=\"true\">   </DoImg>\n",
"                           <Seuil Nb=\"1\"  Type=\"double\"> </Seuil>\n",
"		      </ReCalclCorrelMultiEchelle>\n",
"\n",
"                    <!-- La correlation dense donne un homologue pour chaque point, c'est inutile\n",
"                    et couteux pour calculer des modeles analytique, on regroupe donc entree les points\n",
"                    selon un grille reguliere de pas PasCalcul -->\n",
"                      <PasCalcul Nb=\"1\" Type=\"int\">                     </PasCalcul>\n",
"                      <!-- Si on souhaite juste prendre le point central, pour etre + reigoureux de point de vue photogram -->\n",
"                      <PointUnique Nb=\"?\" Type=\"bool\" Def=\"false\"> </PointUnique>\n",
"                      <!-- Pas utilise actuellement \n",
"                          <PasDebug Nb=\"?\" Type=\"int\">                     </PasDebug>\n",
"                          <EcartPond Nb=\"*\" Type=\"double\"> </EcartPond>\n",
"                      -->\n",
"                      <!--  \n",
"                       -->\n",
"                      <!-- Est ce que le modele calcule devra etre reimporte comme predicteur, si oui-->\n",
"                      <ReuseModele Nb=\"?\" Type=\"bool\">          </ReuseModele>\n",
"                      <!-- Permet de ne pas refaire le calcul, utilise en mise au point, \n",
"                           le calcul etant effectue une premiere fois pour qu'il y'ait les bonnes\n",
"                           structures sans  perte de temps-->\n",
"                      <MakeExport Nb=\"?\" Type=\"bool\"  Def=\"true\">          </MakeExport>\n",
"\n",
"                       <!-- nom des fichiers d'exports -->\n",
"                      <NameExport Nb=\"?\" Type=\"std::string\" Def=\"ModeleAnalytique\"> </NameExport>\n",
"                      <!-- Export d'une version \"image\" de la //axe analytique, Mise au point-->\n",
"                      <ExportImage Nb=\"?\" Type=\"bool\" Def=\"false\"> </ExportImage>\n",
"                      <!--\n",
"                          Si true, alors on exporte une image de difference entre le modele\n",
"                         et les fichiers de //axes, qui sera utilisee commme paralaxe de\n",
"                         \"residuelle\" / au modele analytique\n",
"                      -->\n",
"                      <ReuseResiduelle Nb=\"?\" Type=\"bool\" Def=\"false\"></ReuseResiduelle>\n",
"\n",
"                      <!--Pour  generer un modele de grille de la transfo, \n",
"		          3 valeur en argument Nom1 Num Nom2\n",
"			-->\n",
"		       \n",
"		      <FCND_ExportModeleGlobal Nb=\"?\" Type=\"std::string\"> </FCND_ExportModeleGlobal>\n",
"\n",
"\n",
"\n",
"                      <!-- Maille de Grille dans le cas ExportModeleGlobal -->\n",
"                      <MailleExport Nb=\"?\" Type=\"double\" Def=\"10.0\"></MailleExport>\n",
"                      <UseHomologueReference Nb=\"?\" Type=\"bool\" Def=\"false\"> </UseHomologueReference>\n",
"                      <MakeImagePxRef Nb=\"?\" Type=\"bool\" Def=\"false\"> </MakeImagePxRef>\n",
"                      <NbPtMinValideEqOriRel Nb=\"?\" Type=\"int\" Def=\"6\"> </NbPtMinValideEqOriRel>\n",
"                 </OneModeleAnalytique>\n",
"            </ModelesAnalytiques>\n",
"            <!-- La bascule se fait avant la compensation   -->\n",
"            <BasculeRes Nb=\"*\">\n",
"	          <Ori Nb=\"1\" UnionType=\"true\">\n",
"                      <Explicite Nb=\"?\" RefType=\"FileOriMnt\"\n",
"                                 RefFile=\"ParamChantierPhotogram.xml\"\n",
"                      > \n",
"                      </Explicite>\n",
"		      <ByFileNomChantier Nb=\"?\">\n",
"		           <Prefixe Nb=\"1\" Type=\"std::string\">  </Prefixe>\n",
"			   <NomChantier Nb=\"?\" Type=\"bool\" Def=\"true\"> </NomChantier>\n",
"		           <Postfixe Nb=\"1\" Type=\"std::string\"> </Postfixe>\n",
"			   <NameTag  Nb=\"?\"  Type=\"std::string\" Def=\"FileOriMnt\"\n",
"                                     RefFile=\"ParamChantierPhotogram.xml\"\n",
"                           > </NameTag>\n",
"		      </ByFileNomChantier>\n",
"	          </Ori>\n",
"		  <OutValue Nb=\"?\" Type=\"double\" Def=\"0.0\"> </OutValue>\n",
"	    </BasculeRes>\n",
"\n",
"\n",
"            <GenerePartiesCachees Nb=\"?\">\n",
"                  <!-- Nouvelle methode de generation de nom, sinon c'est MicMac qui choisit -->\n",
"                  <UseIt Nb=\"?\" Def=\"true\" Type=\"bool\"></UseIt>\n",
"\n",
"                  <PasDisc   Nb=\"?\" Type=\"double\" Def=\"1.0\"> </PasDisc>\n",
"                  <SeuilUsePC Nb=\"1\" Type=\"double\">   </SeuilUsePC>\n",
"                  <KeyCalcPC Nb=\"?\" Type=\"std::string\"> </KeyCalcPC>\n",
"                  <!-- Si on mets une KeyCalcPC, en gal c'est pour de l'ortho, donc pas de chantier ds le nom -->\n",
"                  <AddChantierKPC Nb=\"?\" Type=\"bool\" Def=\"false\"> </AddChantierKPC>\n",
"                  <SupresExtChantierKPC Nb=\"?\" Type=\"bool\" Def=\"true\"> </SupresExtChantierKPC>\n",
"                  <!-- Dequantifier le MNT est un tout petit peu + precis -->\n",
"                  <Dequant Nb=\"?\" Type=\"bool\"> </Dequant>\n",
"                  <ByMkF Nb=\"?\" Type=\"bool\" Def=\"true\"> </ByMkF>\n",
"\n",
"                   <!-- Surtout pour la mise au point, sinon a priori on\n",
"                   en a besoin pour tous -->\n",
"                  <PatternApply Nb=\"?\" Type=\"std::string\" Def=\".*\"> </PatternApply>\n",
"\n",
"                  <VisuSuperposMNT Nb=\"?\">\n",
"                        <NameFile Nb=\"1\" Type=\"std::string\"> </NameFile>\n",
"                        <Seuil    Nb=\"1\" Type=\"double\">      </Seuil>\n",
"                  </VisuSuperposMNT>\n",
"                  <!-- Si true va + vite mais consomme bcp + de memoire -->\n",
"                  <BufXYZ Nb=\"?\" Type=\"bool\" Def=\"true\"></BufXYZ>\n",
"                  <!-- Si true ne fait pas le calcul lorsque le fichier PC exitse -->\n",
"                  <DoOnlyWhenNew Nb=\"?\" Type=\"bool\" Def=\"false\"></DoOnlyWhenNew>\n",
"\n",
"                  <!-- Le calcul peut etre assez consommateur en memoire, pas mal de tampon\n",
"                       et zone potentiellemnt bcp + grande que l'image. D'ou le decoupage avec\n",
"                       ces param pa def\n",
"                   -->\n",
"\n",
"                  <SzBloc Nb=\"?\" Type=\"int\" Def=\"4000\"> </SzBloc>\n",
"                  <SzBord Nb=\"?\" Type=\"int\" Def=\"300\"> </SzBord>\n",
"                  <ImSuperpMNT Nb=\"?\" Type=\"bool\" Def=\"false\"> </ImSuperpMNT>\n",
"                  <!-- Si cette valeur est donnees tous les calculs d'emprise sont fait dessus, utile lorsqu'une partie\n",
"                       meme faible du MNE est tres bruitees -->\n",
"                  <ZMoy Nb=\"?\" Type=\"double\"> </ZMoy>\n",
"                  <FiltreName Nb=\"?\" Type=\"cElRegex_Ptr\"> </FiltreName>\n",
"                  <MakeOrthoParImage Nb=\"?\">\n",
"\n",
"                      <DirOrtho Nb=\"?\" Type=\"std::string\" Def=\"ORTHO/\"> </DirOrtho>\n",
"                      <FileMTD Nb=\"?\" Type=\"std::string\" Def=\"MTDOrtho.xml\"> </FileMTD>\n",
"\n",
"                      <MakeMTDMaskOrtho Nb=\"?\">\n",
"                          <NameFileSauv Nb=\"?\" Type=\"std::string\" Def=\"MTDMaskOrtho.xml\"> </NameFileSauv>\n",
"                          <Mesures Nb=\"1\" RefType=\"MasqMesures\" RefFile=\"SuperposImage.xml\"> </Mesures>\n",
"                      </MakeMTDMaskOrtho>\n",
"\n",
"\n",
"                      <OrthoBiCub Nb=\"?\" Type=\"double\" Def=\"-0.5\"> </OrthoBiCub>\n",
"                      <!-- Si l'image est bcp + resolu que l'ortho et qu'on veut eviter\n",
"                           l'aliasing (par ex souvent = au DeZoom si image Resol1 et pas\n",
"                           ortho \"naturel\")-->\n",
"                      <ScaleBiCub  Nb=\"?\" Type=\"double\" Def=\"1\"> </ScaleBiCub>\n",
"\n",
"                      <OrthoSinusCard Nb=\"?\" AccessorFils=\"false\">\n",
"                            <SzKernel Nb=\"1\" Type=\"double\"> </SzKernel>\n",
"                            <SzApod Nb=\"1\" Type=\"double\">   </SzApod>\n",
"                      </OrthoSinusCard>\n",
"                      <!-- On peut vouloir generer une ortho a une resol differente du MNT,\n",
"                           de même, la phasage des pixel, peut etre different de celui du MNT\n",
"                            pour import dans une autre ortho\n",
"\n",
"                             ResolRelOrhto -> 0.5 pour avoir une ortho 2 fois plus resolue\n",
"                      -->\n",
"                      <ResolRelOrhto Nb=\"?\" Type=\"double\"> </ResolRelOrhto>\n",
"                      <ResolAbsOrtho Nb=\"?\" Type=\"double\"> </ResolAbsOrtho>\n",
"                       <!-- Valeur d'un des pixel terrain ou il  y aura un point d'ortho -->\n",
"                      <PixelTerrainPhase Nb=\"?\" Type=\"Pt2dr\"> </PixelTerrainPhase> \n",
"\n",
"\n",
"                      <KeyCalcInput Nb=\"1\" Type=\"std::string\"> </KeyCalcInput>\n",
"                      <KeyCalcOutput Nb=\"1\" Type=\"std::string\"> </KeyCalcOutput>\n",
"                      <!-- Par defaut nombre de canaux \"naturel\" de l'image -->\n",
"                      <NbChan Nb=\"?\" Type=\"int\" Def=\"-1\"> </NbChan>\n",
"                      <!-- Pour avoir une image d'incidence toute bete / au plan hor -->\n",
"                      <KeyCalcIncidHor Nb=\"?\" Type=\"std::string\"> </KeyCalcIncidHor>\n",
"                      <SsResolIncH Nb=\"?\" Type=\"double\" Def=\"10\"> </SsResolIncH>\n",
"<!-- Est ce que l'image d'incidence est calculee a Z Moyen -->\n",
"                      <CalcIncAZMoy Nb=\"?\" Type=\"bool\"> </CalcIncAZMoy>\n",
"<!-- Est ce que cette image, qui en fait gere les priorite est simplement une image de frontiere -->\n",
"                      <ImageIncIsDistFront Nb=\"?\" Type=\"bool\" Def=\"false\"> </ImageIncIsDistFront>\n",
"\n",
"                       <!-- Permet, meme en mode angle  d'eviter les point frontiere -->\n",
"                       <RepulsFront Nb=\"?\" Type=\"int\" Def=\"20\"> </RepulsFront>\n",
"                      <!-- !!! Par rapport a la resolution des image R1, 0.5 si image 2 fois plus petite -->\n",
"                      <ResolIm Nb=\"?\" Type=\"double\" Def=\"1.0\"> </ResolIm>\n",
"                      \n",
"                      <!-- Si l'image qu'on ortho rectifie a ete cropee / image de correl : Trans > 0 , le translate\n",
"                           est donne pour des zoom image de 1 -->\n",
"                      <TranslateIm Nb=\"?\" Type=\"Pt2di\" Def=\"Pt2di(0,0)\"> </TranslateIm>\n",
"<!--\n",
"-->\n",
"                  </MakeOrthoParImage>\n",
"            </GenerePartiesCachees>\n",
"\n",
"            <RedrLocAnam Nb=\"?\">\n",
"                 <NameOut Type=\"std::string\" Nb=\"1\"> </NameOut>\n",
"                 <NameMasq Type=\"std::string\" Nb=\"1\"> </NameMasq>\n",
"                 <NameOriGlob Type=\"std::string\" Nb=\"1\"> </NameOriGlob>\n",
"                 <NameNuage Type=\"std::string\" Nb=\"?\"> </NameNuage>\n",
"\n",
"                 <XRecouvrt Type=\"int\" Def=\"300\" Nb=\"?\"> </XRecouvrt>\n",
"                 <MemAvalaible Type=\"double\" Def=\"3e7\" Nb=\"?\"> </MemAvalaible>\n",
"                 <FilterMulLargY Type=\"double\" Def=\"3.0\" Nb=\"?\"> </FilterMulLargY>\n",
"                 <NbIterFilterY Type=\"double\" Def=\"4\" Nb=\"?\"> </NbIterFilterY>\n",
"\n",
"                 <FilterXY Type=\"int\" Def=\"2\" Nb=\"?\"> </FilterXY>\n",
"                 <NbIterXY Type=\"int\" Def=\"3\" Nb=\"?\"> </NbIterXY>\n",
"\n",
"                 <DensityHighThresh Type=\"double\" Def=\"0.5\" Nb=\"?\"> </DensityHighThresh>\n",
"                 <DensityLowThresh Type=\"double\" Def=\"0.3\" Nb=\"?\"> </DensityLowThresh>\n",
"\n",
"                 <UseAutoMask Type=\"bool\" Nb=\"?\" Def=\"true\"> </UseAutoMask>\n",
"            </RedrLocAnam>\n",
"\n",
"           <!--  Utilisation si possibles des parties cachees -->\n",
"            <UsePartiesCachee Nb=\"?\" Type=\"bool\"> </UsePartiesCachee> <!-- Def true -->\n",
"            <NameVisuTestPC Nb=\"?\" Type=\"std::string\"> </NameVisuTestPC>\n",
"\n",
"\n",
"            <NuagePredicteur Nb=\"?\">\n",
"                   <KeyAssocIm2Nuage Nb=\"1\" Type=\"std::string\"> </KeyAssocIm2Nuage>\n",
"                   <Selector Nb=\"?\" Type=\"std::string\" Def=\".*\"> </Selector>\n",
"                   <ScaleNuage Nb=\"1\" Type=\"double\"> </ScaleNuage>\n",
"            </NuagePredicteur>\n",
"        </EtapeMEC>\n",
"	<!-- Voir dans cFileImage.cpp des commentaires sur\n",
"	TypePyramImage.\n",
"\n",
"               Doit etre ordonne des resolutions les plus basses\n",
"            aux plus grandes.\n",
"	-->\n",
"	<TypePyramImage Nb=\"*\">\n",
"               <Resol Nb=\"1\" Type=\"int\">              </Resol>\n",
"	       <DivIm  Nb=\"?\" Type=\"int\" Def=\"16\">    </DivIm>\n",
"	       <TypeEl Nb=\"1\" Type=\"eTypeImPyram\">    </TypeEl>\n",
"	</TypePyramImage>\n",
"        <!-- Genrer des pyramide avec perte min si pas de TypePyramImage -->\n",
"        <HighPrecPyrIm Type=\"bool\" Def=\"true\" Nb=\"?\"> </HighPrecPyrIm>\n",
"\n",
"         <!-- Si raw ou jpg en entree, remplace le TypePyramImage -->\n",
"        <Correl16Bits Nb=\"?\" Type=\"bool\"> </Correl16Bits> <!-- true -->\n",
"\n",
"        <!-- Definition des noms de modeles images -->\n",
"<!--\n",
"        <NameMDModele Nb=\"?\" Type=\"std::string\" Def=\"MTD_\"> </NameMDModele>\n",
"        <NameDataModele  Nb=\"?\" Type=\"std::string\" Def=\"DataGr_\"> </NameDataModele>\n",
"        <AddNumToNameModele Nb=\"?\" Type=\"bool\" Def=\"true\">  </AddNumToNameModele>\n",
"-->\n",
"\n",
"\n",
"\n",
"     </Section_MEC>\n",
"\n",
"<!--  *************************************************************\n",
"       Parametres fixant les resultats\n",
"     devant etre produits par l'algo\n",
"-->\n",
"     <Section_Results Nb=\"1\">\n",
"         <!-- Si on trouve AllDone dans  MM_EtatAvancement, on ne fait rien -->\n",
"         <Use_MM_EtatAvancement Nb=\"?\" Type=\"bool\" Def=\"false\"> </Use_MM_EtatAvancement>\n",
"\n",
"         <!-- On peut avoir besoin que MicMac ne fasse rigoureusement\n",
"	      rien si ce n'est qq action specifiques dei generation de donnees ai\n",
"	      (par exemple : orientation )\n",
"\n",
"	      On peut malgre tout avoir \"un peu plus que ce que l'on demande\" car il\n",
"	      il y des dependances entre les diverses donnees, certaine difficilement\n",
"	      evitable (par exemple le TA a besoin de la pyramide a sa resol), d'autre\n",
"	      plus contestable .\n",
"	 -->\n",
"\n",
"\n",
"         <DoNothingBut Nb=\"?\">\n",
"                  <ButDoPyram Nb=\"?\" Type=\"bool\" Def=\"false\">         </ButDoPyram>\n",
"                  <ButDoMasqIm Nb=\"?\" Type=\"bool\" Def=\"false\">        </ButDoMasqIm>\n",
"                  <ButDoMemPart Nb=\"?\" Type=\"bool\" Def=\"false\">       </ButDoMemPart>\n",
"                  <ButDoTA Nb=\"?\" Type=\"bool\" Def=\"false\">             </ButDoTA>\n",
"                  <ButDoMasqueChantier Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoMasqueChantier>\n",
"                  <ButDoOriMNT Nb=\"?\" Type=\"bool\" Def=\"false\">         </ButDoOriMNT>\n",
"                  <ButDoMTDNuage Nb=\"?\" Type=\"bool\" Def=\"false\">         </ButDoMTDNuage>\n",
"                  <ButDoFDC Nb=\"?\" Type=\"bool\" Def=\"false\">            </ButDoFDC>\n",
"                  <ButDoExtendParam Nb=\"?\" Type=\"bool\" Def=\"false\">    </ButDoExtendParam>\n",
"		  <ButDoGenCorPxTransv  Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoGenCorPxTransv>\n",
"		  <ButDoPartiesCachees  Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoPartiesCachees>\n",
"		  <ButDoOrtho  Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoOrtho>\n",
"		  <ButDoSimul  Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoSimul>\n",
"		  <ButDoRedrLocAnam  Nb=\"?\" Type=\"bool\" Def=\"false\"> </ButDoRedrLocAnam>\n",
"         </DoNothingBut>\n",
"         <!-- A laisser pour com interne MicMac : // des PC -->\n",
"         <Paral_Pc_IdProcess Nb=\"?\" Type=\"int\"> </Paral_Pc_IdProcess>\n",
"         <Paral_Pc_NbProcess Nb=\"?\" Type=\"int\"> </Paral_Pc_NbProcess>\n",
"\n",
"         <!-- Dans les geometrie faisceau, les plans d'equi profondeur sont par\n",
"	 defaut parallele au capteur, on peut preferer une direction specifique par exemple\n",
"	 avec un scene quasi plane et une pdv convergente.\n",
"	 -->\n",
"         <X_DirPlanInterFaisceau Nb=\"?\" Type=\"double\" Def=\"0\"> </X_DirPlanInterFaisceau>\n",
"         <Y_DirPlanInterFaisceau Nb=\"?\" Type=\"double\" Def=\"0\"> </Y_DirPlanInterFaisceau>\n",
"         <Z_DirPlanInterFaisceau Nb=\"?\" Type=\"double\" Def=\"0\"> </Z_DirPlanInterFaisceau>\n",
"\n",
"         <GeomMNT Nb=\"1\" Type=\"eModeGeomMNT\"> </GeomMNT>\n",
"\n",
"\n",
"         <SectionSimulation Nb=\"?\" AccessorFils=\"false\">\n",
"             <SimulRelief Nb=\"1\">\n",
"                  <DoItR Nb=\"?\" Type=\"bool\" Def=\"false\"> </DoItR>\n",
"                  <MNTPart Nb=\"1\">\n",
"                     <PenteGlob Nb=\"?\" Type=\"Pt2dr\" Def=\"Pt2dr(0,0)\"></PenteGlob>\n",
"                     <FoncPer Nb=\"*\">\n",
"                           <Per Nb=\"1\" Type=\"Pt2dr\"> </Per>\n",
"                           <Ampl Nb=\"1\" Type=\"double\"> </Ampl>\n",
"<!-- Si true alors Ampl fixe l'amplitude de la derivee -->\n",
"                           <AmplIsDer Nb=\"?\" Type=\"bool\" Def=\"true\"></AmplIsDer>\n",
"                     </FoncPer>\n",
"                  </MNTPart>\n",
"                  <MNEPart Nb=\"1\">\n",
"                     <SimulBarres Nb=\"*\">\n",
"                        <Nb Nb=\"1\" Type=\"int\"> </Nb>\n",
"                        <PowDistLongueur Nb=\"?\" Type=\"double\" Def=\"2.0\"> </PowDistLongueur>\n",
"                        <IntervLongeur Nb=\"1\" Type=\"Pt2dr\"> </IntervLongeur>\n",
"                        <IntervLargeur Nb=\"1\" Type=\"Pt2dr\"> </IntervLargeur>\n",
"                        <IntervPentes Nb=\"1\" Type=\"Pt2dr\"> </IntervPentes>\n",
"                        <IntervHauteur Nb=\"1\" Type=\"Pt2dr\"> </IntervHauteur>\n",
"                        <ProbSortant Nb=\"?\" Type=\"double\" Def=\"0.5\"> </ProbSortant>\n",
"                     </SimulBarres>\n",
"                  </MNEPart>\n",
"             </SimulRelief>\n",
"\n",
"             <TexturePart Nb=\"1\">\n",
"                   <Texton Nb=\"1\" Type=\"std::string\"> </Texton>\n",
"                   <ImRes Nb=\"1\" Type=\"std::string\"> </ImRes>\n",
"             </TexturePart>\n",
"\n",
"             <ProjImPart Nb=\"1\">\n",
"                  <PatternSel Nb=\"1\"  Type=\"cElRegex_Ptr\"> </PatternSel>\n",
"                  <SzBloc Nb=\"?\" Type=\"int\" Def=\"100000\"> </SzBloc>\n",
"                  <SzBrd Nb=\"?\" Type=\"int\" Def=\"20\"> </SzBrd>\n",
"              <!-- Pas defaut le mm que RatioResolImage global ; si meilleur resol, < 1 -->\n",
"                  <RatioSurResol Nb=\"?\" Type=\"double\"> </RatioSurResol>\n",
"                  <KeyProjMNT Nb=\"?\" Type=\"std::string\"> </KeyProjMNT>\n",
"                  <KeyIm Nb=\"?\" Type=\"std::string\"> </KeyIm>\n",
"\n",
"                  <BicubParam Nb=\"?\" Type=\"double\" Def=\"-0.5\"></BicubParam>\n",
"                  <ReprojInverse Nb=\"?\" Type=\"bool\" Def=\"false\"> </ReprojInverse>\n",
"\n",
"                  <SzFTM Type=\"double\" Nb=\"?\" Def=\"1.0\"> </SzFTM>\n",
"                  <Bruit Type=\"double\" Nb=\"?\"> </Bruit>\n",
"             </ProjImPart>\n",
"\n",
"         </SectionSimulation>\n",
"\n",
"         <!--  Pour la calcul d'emprise, quand la geom connait sa paralaxe, faut il\n",
"               l'utiliser ou utiliser la valeur globale\n",
"         -->\n",
"         <Prio2OwnAltisolForEmprise Nb=\"?\" Type=\"bool\" Def=\"false\"> </Prio2OwnAltisolForEmprise>\n",
"       \n",
"          <!-- Si Anamorphose est specifiee,\n",
"               0- Px doit etre 1D\n",
"               1- il faut que la geometrie soit\n",
"               terrain (euclid). Sans doute restrictif, a voir si on\n",
"               peut relacher cette contrainte ?\n",
"          -->\n",
"         <AnamorphoseGeometrieMNT Nb=\"?\">\n",
"             <!-- Pour gerer le desanamorphose des ortho .... -->\n",
"             <UnUseAnamXCste Nb=\"?\" Def=\"false\" Type=\"bool\"> </UnUseAnamXCste>\n",
"             <AnamSurfaceAnalytique Nb=\"?\">\n",
"                   <NameFile Nb=\"1\" Type=\"std::string\"> </NameFile>\n",
"                   <Id Nb=\"1\" Type=\"std::string\"> </Id>\n",
"             </AnamSurfaceAnalytique>\n",
"             <AnamDeZoomMasq Nb=\"?\" Type=\"int\" Def=\"16\"> </AnamDeZoomMasq>\n",
"             <!-- Limite +ou- Pi/3 -->\n",
"             <AnamLimAngleVisib Nb=\"?\" Type=\"double\" Def=\"1.05\"> </AnamLimAngleVisib>\n",
"             <MakeMaskImNadir Nb=\"?\">\n",
"                 <DynIncid Nb=\"?\" Type=\"double\" Def=\"1e4\"> </DynIncid>\n",
"<!-- A priori si on fait des masque image, on ne veut pas utiliser cela en geometrie terrain -->\n",
"                 <MakeAlsoMaskTerrain Type=\"bool\" Nb=\"?\" Def=\"false\"> </MakeAlsoMaskTerrain>\n",
"                <!-- Selectionne les KBest -->\n",
"                 <KBest  Nb=\"1\" Type=\"int\">   </KBest>\n",
"                  <!-- Comme il y a une certaine incert, on selectionne ceux t.q \n",
"                            Incid<  (1+IncertAngle) KBetsIncid\n",
"                  -->\n",
"                 <IncertAngle  Nb=\"?\" Type=\"double\" Def=\"0.1\"> </IncertAngle>\n",
"                 <Dilat32 Nb=\"?\" Type=\"int\" Def=\"6\"> </Dilat32>\n",
"                 <Erod32 Nb=\"?\" Type=\"int\"  Def=\"3\"> </Erod32>\n",
"             </MakeMaskImNadir>\n",
"         </AnamorphoseGeometrieMNT>\n",
"\n",
"         <!-- Utile  pour un chgt de rep temp a la correl (redressement, \n",
"             pb d'unites heterogenes ....)   NO-REPERE  donne meme effet que rien -->\n",
"         <RepereCorrel Nb=\"?\" Type=\"std::string\"> </RepereCorrel>\n",
"         <TagRepereCorrel Nb=\"?\" Type=\"std::string\" Def=\"RepereCartesien\"> </TagRepereCorrel>\n",
"\n",
"\n",
"\n",
"         <DoMEC Nb=\"?\" Def=\"true\" Type=\"bool\">  </DoMEC>\n",
"         <!-- Le DoMEC ne se fera que si le fichier n'existe pas -->\n",
"         <NonExistingFileDoMEC Nb=\"?\"  Type=\"std::string\"> </NonExistingFileDoMEC>\n",
"\n",
"\n",
"         <!-- FDC=File Description de Chantier -->\n",
"         <DoFDC Nb=\"?\" Def=\"false\" Type=\"bool\">  </DoFDC>\n",
"	 <!-- Si true genere le xml apres inclusion des fichier\n",
"	 et modif par lignes de commandes-->\n",
"	 <GenereXMLComp Nb=\"?\" Def=\"true\" Type=\"bool\"> </GenereXMLComp>\n",
"\n",
"         <TAUseMasqNadirKBest Nb=\"?\" Type=\"int\"> </TAUseMasqNadirKBest>\n",
"	 <ZoomMakeTA Nb=\"?\"  Type=\"int\"> </ZoomMakeTA>\n",
"         <SaturationTA  Nb=\"?\" Type=\"double\" Def=\"50.0\"> </SaturationTA>\n",
"         <!-- Si true le TA ressemble + a une ortho, avec prise en compte du nadir, la\n",
"          coloration est   un etiquettage -->\n",
"         <OrthoTA Nb=\"?\" Type=\"bool\" Def=\"false\"> </OrthoTA>\n",
"	 <ZoomMakeMasq Nb=\"?\"  Type=\"int\"> </ZoomMakeMasq>\n",
"         \n",
"\n",
"         <!-- Si true le masque terrain n'est calcule qu'a la resolution necessaire, cela fait gagner un temps\n",
"              non negligeable en proportion lorque l'on s'arrete a des resol basse; false par defaut au cas\n",
"              ou il y aurait des effets collateraux ...\n",
"         -->\n",
"         <LazyZoomMaskTerrain Nb=\"?\" Type=\"bool\" Def=\"false\"> </LazyZoomMaskTerrain>\n",
"\n",
"\n",
"         <MakeImCptTA Nb=\"?\" Type=\"bool\" Def=\"false\"> </MakeImCptTA>\n",
"         <FilterTA  Nb=\"?\" Type=\"std::string\"> </FilterTA>\n",
"	 <!-- \n",
"	     Coefficient de Gamma Correction utilisee dans les fonctionnamites\n",
"	 necessitant une visualisation des images (TA, Visu interm ...)\n",
"	 -->\n",
"	 <GammaVisu Nb=\"?\" Def=\"1.0\" Type=\"double\"> </GammaVisu>\n",
"\n",
"         <ZoomVisuLiaison Nb=\"?\" Def=\"-1\" Type=\"int\"> </ZoomVisuLiaison>\n",
"         <!-- De par le mode de calcul, il est possible, bien qu'improbable,\n",
"            que les points homologues soient en dehors de l'image.\n",
"              Ce parametre regle le seuil de verification. Il est SIGNE,\n",
"            une valeur negative indiquant un reglage plus strict.\n",
"              \"Conventionnellement\" les valeurs superieures a 1e10 ne sont\n",
"           pas testees.\n",
"         -->\n",
"         <TolerancePointHomInImage Nb=\"?\" Type=\"double\" Def=\"0.0\">\n",
"         </TolerancePointHomInImage>\n",
"\n",
"         <!-- Meme pb que TolerancePointHomInImage , mais il s'agit\n",
"	 d'une mesure \"corrective\", les point en dehors du seuil sont\n",
"	 vires (et ne genere pas d'erreur ....) -->\n",
"         <FiltragePointHomInImage Nb=\"?\" Type=\"double\" Def=\"0.0\">\n",
"         </FiltragePointHomInImage>\n",
"\n",
"         <!-- Origine de la numerotation des erreurs MicMac -->\n",
"         <BaseCodeRetourMicmacErreur Nb=\"?\" Type=\"int\" Def=\"100\"> \n",
"         </BaseCodeRetourMicmacErreur>\n",
"\n",
"         <SuperpositionImages Nb=\"?\">\n",
"              <OrdreChannels Nb=\"1\" Type=\"Pt3di\"> </OrdreChannels>\n",
"              <PtBalanceBlancs  Nb=\"?\" Type=\"Pt2di\"> </PtBalanceBlancs>\n",
"              <P0Sup Nb=\"?\" Type=\"Pt2di\">            </P0Sup>\n",
"              <SzSup Nb=\"?\" Type=\"Pt2di\">            </SzSup>\n",
"\n",
"              <PatternSelGrid Nb=\"1\" Type=\"cElRegex_Ptr\">  </PatternSelGrid>\n",
"              <PatternNameGrid Nb=\"1\" Type=\"std::string\">  </PatternNameGrid>\n",
"              <ColorimetriesCanaux Nb=\"*\">\n",
"                  <CanalSelector Nb=\"1\"  Type=\"cElRegex_Ptr\"> </CanalSelector>\n",
"                  <ValBlanc Nb=\"?\" Type=\"double\">             </ValBlanc>\n",
"                  <!-- ValNoir +ou- le voile atmospherique -->\n",
"                  <ValNoir  Nb=\"?\" Type=\"double\" Def=\"0.0\">   </ValNoir>\n",
"              </ColorimetriesCanaux>\n",
"              <GammaCorrection Nb=\"?\" Def=\"1.0\" Type=\"double\"> </GammaCorrection>\n",
"              <MultiplicateurBlanc Nb=\"?\" Def=\"1.0\" Type=\"double\"> </MultiplicateurBlanc>\n",
"              <GenFileImages Nb=\"?\" Def=\"false\" Type=\"bool\"> </GenFileImages>\n",
"         </SuperpositionImages>\n",
"\n",
"   \n",
"     </Section_Results>\n",
"<!--  *************************************************************\n",
"     Parametres lies a l'execution du calcul \n",
"     du \"chantier\" sur la machine\n",
"-->\n",
"     <Section_WorkSpace Nb=\"1\">\n",
"\n",
"          <!-- Permet de stocker un fichier de specialisation en fonnction (par ex)\n",
"               de la PDV maitresse -->\n",
"          <FileExportApero2MM Nb=\"?\" Type=\"std::string\"> </FileExportApero2MM>\n",
"          <UseProfInVertLoc Nb=\"?\" Type=\"bool\" Def=\"true\"></UseProfInVertLoc>\n",
"\n",
"          <NameFileParamMICMAC Nb=\"?\" Type=\"std::string\"> </NameFileParamMICMAC>\n",
"      <!-- Localisation sur le disque -->\n",
"         <!-- Work Dir, emplacement du chantier -->\n",
"         <WorkDir Nb=\"1\" Type=\"std::string\"> </WorkDir>\n",
"         <!-- Tmp Dir en local /  -->\n",
"         <DirImagesOri Nb=\"?\" Type=\"std::string\"> </DirImagesOri>\n",
"\n",
"         <TmpMEC Nb=\"1\" Type=\"std::string\">  </TmpMEC>\n",
"         <TmpPyr Nb=\"?\" Type=\"std::string\">  </TmpPyr>\n",
"         <TmpGeom Nb=\"?\" Type=\"std::string\" Def=\"\" >  </TmpGeom>\n",
"	 <TmpResult Nb=\"?\" Type=\"std::string\" Def=\"Result/\" >  </TmpResult>\n",
"\n",
"      <!-- Execution par processus--> \n",
"      <!-- !!!!   CalledByProcess : \n",
"                   Ces tag sont geres par le correlateur\n",
"                   Ne jamais les positionner \"a la main\" \n",
"	      !!!! -->\n",
"	 <CalledByProcess  Nb=\"?\" Def=\"false\" Type=\"bool\"> </CalledByProcess>\n",
"	 <IdMasterProcess  Nb=\"?\" Def=\"-1\" Type=\"int\"> </IdMasterProcess>\n",
"         <!-- Pour pouvoir specifier par Key dans le DicoLoc : commandes simplifiees -->\n",
"         <CreateGrayFileAtBegin  Nb=\"?\" Def=\"false\" Type=\"bool\"> </CreateGrayFileAtBegin>\n",
"	 <Visu Nb=\"?\" Def=\"false\" Type=\"bool\">             </Visu>\n",
"	 <ByProcess Nb=\"?\" Def=\"0\" Type=\"int\"> </ByProcess>\n",
"         <StopOnEchecFils Nb=\"?\" Def=\"true\" Type=\"bool\"> </StopOnEchecFils>\n",
"      <!-- Decoupage --> \n",
"	           <!-- Memoire en Mega Octet -->\n",
"	 <AvalaibleMemory  Nb=\"?\" Def=\"128\" Type=\"int\"> </AvalaibleMemory>\n",
"	 <SzRecouvrtDalles Nb=\"?\" Def=\"50\"  Type=\"int\"> </SzRecouvrtDalles>\n",
"	 <SzDalleMin       Nb=\"?\" Def=\"400\" Type=\"int\"> </SzDalleMin>\n",
"	 <SzDalleMax       Nb=\"?\" Def=\"800\" Type=\"int\"> </SzDalleMax>\n",
"            <!-- Nouvelle facon de gerer la memoire, controle a posteriori de la taille et split recursif-->\n",
"         <NbCelluleMax Nb=\"?\" Def=\"2e7\" Type=\"double\"> </NbCelluleMax>\n",
"         <!-- Dans le decoupage de cAppliMICMAC_ChCorrel.cpp -->\n",
"         <SzMinDecomposCalc Nb=\"?\" Def=\"10\" Type=\"int\"> </SzMinDecomposCalc>\n",
"         <AutorizeSplitRec Nb=\"?\" Type=\"bool\"> </AutorizeSplitRec>\n",
"         <DefTileFile Nb=\"?\" Def=\"10000\" Type=\"int\"> </DefTileFile>\n",
"\n",
"      <!-- Pour un certains nombre de fichiers aux, t.q. TA ou Masq, le DeZoom,\n",
"          si non specifie est calcule de maniere a ce que le nombre de pixel soit approx\n",
"          NbPixFilesAux. \n",
"	  Pour eviter d'avoir une taille 1 sur les petits chantier c'est au min DeZoomDefMinFileAux\n",
"      -->\n",
"	 <NbPixDefFilesAux Nb=\"?\" Def=\"3.0e7\" Type=\"double\"> </NbPixDefFilesAux>\n",
"	 <DeZoomDefMinFileAux Nb=\"?\" Def=\"4\" Type=\"int\">  </DeZoomDefMinFileAux>\n",
"      <!-- Execution partielle\n",
"           En general geree par le correlateur, mais peut etre effectuee\n",
"	   \"a la main\" pour une reprise a chaud\n",
"       -->\n",
"         <FirstEtapeMEC Nb=\"?\" Def=\"0\"  Type=\"int\"> </FirstEtapeMEC>\n",
"         <LastEtapeMEC  Nb=\"?\" Def=\"10000\" Type=\"int\"> </LastEtapeMEC>\n",
"         <FirstBoiteMEC Nb=\"?\" Def=\"0\"  Type=\"int\"> </FirstBoiteMEC>\n",
"         <NbBoitesMEC   Nb=\"?\" Def=\"100000000\" Type=\"int\"> </NbBoitesMEC>  \n",
"\n",
"        <NomChantier Nb=\"?\" Type=\"std::string\" Def=\"LeChantier\">  </NomChantier>\n",
"        <CalcNomChantier Nb=\"?\">\n",
"              <PatternSelChantier Nb=\"1\" Type=\"std::string\">    </PatternSelChantier>\n",
"              <PatNameChantier Nb=\"1\" Type=\"std::string\">   </PatNameChantier>\n",
"              <SeparateurChantier Nb=\"?\" Type=\"std::string\" Def=\"\">   </SeparateurChantier>\n",
"        </CalcNomChantier>\n",
"\n",
"        <PatternSelPyr Nb=\"?\" Type=\"std::string\" Def=\"(.*)@(.*)\"> </PatternSelPyr>\n",
"        <PatternNomPyr Nb=\"?\" Type=\"std::string\" Def=\"$1DeZoom$2.tif\"> </PatternNomPyr>\n",
"        <SeparateurPyr Nb=\"?\" Type=\"std::string\" Def=\"@\"> </SeparateurPyr>\n",
"\n",
"        <KeyCalNamePyr Nb=\"?\" Type=\"std::string\" Def=\"Key-Assoc-Pyram-MM\"> </KeyCalNamePyr>\n",
"\n",
"        <ActivePurge Nb=\"?\" Type=\"bool\" Def=\"false\"> </ActivePurge>\n",
"        <PurgeFiles Nb=\"*\">\n",
"            <PatternSelPurge Nb=\"1\" Type=\"std::string\"> </PatternSelPurge>\n",
"            <PurgeToSupress  Nb=\"1\" Type=\"bool\">        </PurgeToSupress>\n",
"        </PurgeFiles>\n",
"\n",
"        <PurgeMECResultBefore Nb=\"?\" Type=\"bool\" Def=\"false\"> </PurgeMECResultBefore>\n",
"        <PreservedFile Nb=\"?\" Type=\"std::string\"> </PreservedFile>\n",
"\n",
"	<UseChantierNameDescripteur Nb=\"?\" Type=\"bool\" Def=\"false\"> </UseChantierNameDescripteur>\n",
"	<FileChantierNameDescripteur Nb=\"?\" Type=\"string\"> </FileChantierNameDescripteur>\n",
"\n",
"       <MapMicMac Nb=\"?\"\n",
"                    RefType=\"CmdMappeur\"\n",
"                    RefFile=\"ParamChantierPhotogram.xml\"\n",
"        >\n",
"        </MapMicMac>\n",
"\n",
"       <PostProcess Nb=\"?\"\n",
"                    RefType=\"CmdExePar\"\n",
"                    RefFile=\"ParamChantierPhotogram.xml\"\n",
"        >\n",
"        </PostProcess>\n",
"        \n",
"        <ComprMasque Nb=\"?\" Type=\"eComprTiff\" Def=\"eComprTiff_FAX4\"> </ComprMasque>\n",
"        <TypeMasque Nb=\"?\" Type=\"eTypeNumerique\" Def=\"eTN_Bits1MSBF\"> </TypeMasque>\n",
"\n",
"\n",
"     </Section_WorkSpace>\n",
"\n",
"     <SectionBatch Nb=\"?\">\n",
"	     <!-- Si false imprime juste la ligne de commande -->\n",
"	 <ExeBatch Nb=\"?\" Type=\"bool\" Def=\"true\"> </ExeBatch>\n",
"         <OneBatch Nb=\"*\">\n",
"              <PatternSelImBatch Nb=\"1\"  Type=\"std::string\">    </PatternSelImBatch>\n",
"              <PatternCommandeBatch Nb=\"*\"  Type=\"std::string\"> </PatternCommandeBatch>\n",
"         </OneBatch>\n",
"         <NextMicMacFile2Exec Nb=\"*\" Type=\"std::string\"> </NextMicMacFile2Exec>\n",
"     </SectionBatch>\n",
"<!--  *************************************************************\n",
"     Comme son nom l'indique cette section contient un certain\n",
"    nombre de parametre en Vrac. Ils ne sont pas directement\n",
"    utiles pour le programme operationnel de mise en correspondances ;\n",
"   \n",
"      Ils sont utiles soit pour la mise au point/debugage, soit pour\n",
"    des programmes annexes tels que le programme de saisie de points \n",
"    de liaison.\n",
"-->\n",
"     <Section_Vrac Nb=\"1\">\n",
"          <DebugMM Nb=\"?\" Type=\"bool\" Def=\"false\"></DebugMM>\n",
"      <!-- SAISIE DE POINTS DE LIAISONS -->\n",
"          <!-- Saisie de liasion avec contrainte epipolaire-->\n",
"          <SL_XSzW Nb=\"?\" Def=\"1000\" Type=\"int\"> </SL_XSzW> \n",
"          <SL_YSzW Nb=\"?\" Def=\"900\" Type=\"int\"> </SL_YSzW> \n",
"          <SL_Epip Nb=\"?\" Def=\"false\" Type=\"bool\"> </SL_Epip> \n",
"          <SL_YDecEpip Nb=\"?\" Type=\"int\" Def=\"0\"> </SL_YDecEpip> \n",
"          <!-- Saisie de liasion avec des points homologues Im1/Im2 \"initiaux\"\n",
"           pour redresser l'image, c'est un nom de fichier-->\n",
"          <SL_PackHom0 Nb=\"?\" Type=\"std::string\" Def=\"\"> </SL_PackHom0>\n",
"	  <SL_RedrOnCur Nb=\"?\" Type=\"bool\" Def=\"false\">   </SL_RedrOnCur>\n",
"	  <SL_NewRedrCur   Nb=\"?\" Type=\"bool\" Def=\"false\">   </SL_NewRedrCur>\n",
"	  <SL_L2Estim   Nb=\"?\" Type=\"bool\" Def=\"true\">   </SL_L2Estim>\n",
"\n",
"\n",
"          <SL_FILTER Nb=\"?\" Type=\"std::vector<std::string>\"> </SL_FILTER>\n",
"          <SL_TJS_FILTER Nb=\"?\" Type=\"bool\" Def=\"false\"> </SL_TJS_FILTER>\n",
"          <SL_Step_Grid Nb=\"?\" Type=\"double\" Def=\"10.0\"> </SL_Step_Grid>\n",
"          <SL_Name_Grid_Exp Nb=\"?\" Type=\"std::string\" Def=\"GridMap_%I_To_%J\"> </SL_Name_Grid_Exp>\n",
"          \n",
"      <!-- VISUALISATION DE SUPERPOSITIONS  -->\n",
"          <VSG_DynImRed Nb=\"?\" Type=\"double\" Def=\"5.0\">  </VSG_DynImRed>\n",
"          <VSG_DeZoomContr Nb=\"?\" Type=\"int\" Def=\"16\">   </VSG_DeZoomContr>\n",
"\n",
"      <!-- DEBUG -->\n",
"           <PtDebug Type=\"Pt2di\" Nb=\"?\" > </PtDebug>\n",
"	   <DumpNappesEnglob Type=\"bool\" Nb=\"?\" Def=\"false\"> </DumpNappesEnglob>\n",
"\n",
"      <!-- Aucune raison pour l'utisateur de change la valeur par defaut de ces variables de\n",
"           mise au point\n",
"      -->\n",
"        <InterditAccelerationCorrSpec Nb=\"?\" Type=\"bool\" Def=\"false\"> </InterditAccelerationCorrSpec>\n",
"        <InterditCorrelRapide Nb=\"?\" Type=\"bool\" Def=\"false\"> </InterditCorrelRapide>\n",
"	<ForceCorrelationByRect Nb=\"?\" Type=\"bool\" Def=\"false\"> </ForceCorrelationByRect>\n",
"      <!-- Permet pour mise au point, de donner des cples homologues de ref -->\n",
"           <ListTestCpleHomol Nb=\"*\">\n",
"                <PtIm1 Type=\"Pt2dr\" Nb=\"1\" > </PtIm1>\n",
"                <PtIm2 Type=\"Pt2dr\" Nb=\"1\" > </PtIm2>\n",
"           </ListTestCpleHomol>\n",
"\n",
"      <!-- Mise au point, si presente les coordonnees images sont affichees-->\n",
"           <ListeTestPointsTerrain Type=\"Pt3dr\" Nb=\"*\" > </ListeTestPointsTerrain>\n",
"	   <WithMessage Nb=\"?\" Type=\"bool\" Def=\"false\">   </WithMessage>\n",
"\n",
"           <ShowLoadedImage Nb=\"?\" Type=\"bool\" Def=\"false\">    </ShowLoadedImage>\n",
"\n",
"           <SectionDebug Nb=\"?\">\n",
"                <DebugEscalier Nb=\"?\">\n",
"                     <P1 Nb=\"1\" Type=\"Pt2di\"> </P1>\n",
"                     <P2 Nb=\"1\" Type=\"Pt2di\"> </P2>\n",
"                     <ShowDerivZ Nb=\"?\" Type=\"bool\" Def=\"false\"> </ShowDerivZ>\n",
"                </DebugEscalier>\n",
"           </SectionDebug>\n",
" \n",
"     </Section_Vrac>\n",
"\n",
"   </ParamMICMAC>\n",
"\n",
"<Verbatim File=\".h.cpp\">\n",
"// Quelque chose\n",
"</Verbatim>\n",
"\n",
"<Verbatim File=\".h\">\n",
"#endif // Define_NotMicMac\n",
"</Verbatim>\n",
"\n",
"\n",
"\n",
"</GenCpp>\n",
"","//#_-=+{}@$##$##@"};
