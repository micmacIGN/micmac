#include "cMMVII_Appli.h"
#include "MMVII_Matrix.h"

// include model architecture 
#include "cCnnModelPredictor.h"

bool TEST=true;
//WITHOUT ATTENTION DUBLIN
std::vector<double> spaceCorrDUBLIN_TEST_ENSCHEDE = {0.0 ,5.01437811e-03 ,1.00142388e-02, 1.50140990e-02
 ,2.00139601e-02 ,2.50138212e-02 ,3.00136805e-02 ,3.50135416e-02
 ,4.00134027e-02 ,4.50132638e-02 ,5.00131249e-02 ,5.50129861e-02
 ,6.00128435e-02 ,6.50127083e-02 ,7.00125694e-02 ,7.50124305e-02
 ,8.00122842e-02 ,8.50121453e-02 ,9.00120065e-02 ,9.50118676e-02
 ,1.00011729e-01 ,1.05011590e-01 ,1.10011451e-01 ,1.15011312e-01
 ,1.20011173e-01 ,1.25011027e-01 ,1.30010888e-01 ,1.35010749e-01
 ,1.40010610e-01 ,1.45010471e-01 ,1.50010332e-01 ,1.55010194e-01
 ,1.60010055e-01 ,1.65009916e-01 ,1.70009777e-01 ,1.75009638e-01
 ,1.80009499e-01 ,1.85009360e-01 ,1.90009221e-01 ,1.95009083e-01
 ,2.00008944e-01 ,2.05008805e-01 ,2.10008666e-01 ,2.15008527e-01
 ,2.20008388e-01 ,2.25008249e-01 ,2.30008110e-01 ,2.35007972e-01
 ,2.40007833e-01 ,2.45007694e-01 ,2.50007540e-01 ,2.55007416e-01
 ,2.60007262e-01 ,2.65007138e-01 ,2.70006984e-01 ,2.75006860e-01
 ,2.80006707e-01 ,2.85006583e-01 ,2.90006429e-01 ,2.95006305e-01
 ,3.00006151e-01 ,3.05006027e-01 ,3.10005873e-01 ,3.15005749e-01
 ,3.20005596e-01 ,3.25005472e-01 ,3.30005318e-01 ,3.35005194e-01
 ,3.40005040e-01 ,3.45004916e-01 ,3.50004762e-01 ,3.55004638e-01
 ,3.60004485e-01 ,3.65004331e-01 ,3.70004207e-01 ,3.75004053e-01
 ,3.80003929e-01 ,3.85003775e-01 ,3.90003651e-01 ,3.95003498e-01
 ,4.00003374e-01 ,4.05003220e-01 ,4.10003096e-01 ,4.15002942e-01
 ,4.20002818e-01 ,4.25002664e-01 ,4.30002540e-01 ,4.35002387e-01
 ,4.40002263e-01 ,4.45002109e-01 ,4.50001985e-01 ,4.55001831e-01
 ,4.60001707e-01 ,4.65001553e-01 ,4.70001429e-01 ,4.75001276e-01
 ,4.80001152e-01 ,4.85000998e-01 ,4.90000874e-01 ,4.95000720e-01
 ,5.00000596e-01 ,5.05000472e-01 ,5.10000288e-01 ,5.15000165e-01
 ,5.20000041e-01 ,5.24999857e-01 ,5.29999733e-01 ,5.34999609e-01
 ,5.39999485e-01 ,5.44999301e-01 ,5.49999177e-01 ,5.54999053e-01
 ,5.59998930e-01 ,5.64998746e-01 ,5.69998622e-01 ,5.74998498e-01
 ,5.79998374e-01 ,5.84998190e-01 ,5.89998066e-01 ,5.94997942e-01
 ,5.99997818e-01 ,6.04997635e-01 ,6.09997511e-01 ,6.14997387e-01
 ,6.19997263e-01 ,6.24997079e-01 ,6.29996955e-01 ,6.34996831e-01
 ,6.39996707e-01 ,6.44996524e-01 ,6.49996400e-01 ,6.54996276e-01
 ,6.59996152e-01 ,6.64995968e-01 ,6.69995844e-01 ,6.74995720e-01
 ,6.79995537e-01 ,6.84995413e-01 ,6.89995289e-01 ,6.94995165e-01
 ,6.99994981e-01 ,7.04994857e-01 ,7.09994733e-01 ,7.14994609e-01
 ,7.19994426e-01 ,7.24994302e-01 ,7.29994178e-01 ,7.34994054e-01
 ,7.39993870e-01 ,7.44993746e-01 ,7.49993622e-01 ,7.54993498e-01
 ,7.59993315e-01 ,7.64993191e-01 ,7.69993067e-01 ,7.74992943e-01
 ,7.79992759e-01 ,7.84992635e-01 ,7.89992511e-01 ,7.94992387e-01
 ,7.99992204e-01 ,8.04992080e-01 ,8.09991956e-01 ,8.14991832e-01
 ,8.19991648e-01 ,8.24991524e-01 ,8.29991400e-01 ,8.34991276e-01
 ,8.39991093e-01 ,8.44990969e-01 ,8.49990845e-01 ,8.54990661e-01
 ,8.59990537e-01 ,8.64990413e-01 ,8.69990289e-01 ,8.74990106e-01
 ,8.79989982e-01 ,8.84989858e-01 ,8.89989734e-01 ,8.94989550e-01
 ,8.99989426e-01 ,9.04989302e-01 ,9.09989178e-01 ,9.14988995e-01
 ,9.19988871e-01 ,9.24988747e-01 ,9.29988623e-01 ,9.34988439e-01
 ,9.39988315e-01 ,9.44988191e-01 ,9.49988067e-01 ,9.54987884e-01
 ,9.59987760e-01 ,9.64987636e-01 ,9.69987512e-01 ,9.74987328e-01
 ,9.79987204e-01 ,9.84987080e-01 ,9.89986956e-01 ,1.0};
 
 std::vector<double> spaceProbDUBLIN_TEST_ENSCHEDE = {0.0, 0.0,  0.00354715 , 0.00648111 ,0.00897599 ,0.01121609 ,0.01331414
 ,0.01530787 ,0.0172437  ,0.01914961 ,0.02102701 ,0.02290535 ,0.02477192
 ,0.02663904 ,0.02848654 ,0.03032058 ,0.03217096 ,0.03401978 ,0.03586171
 ,0.03771127 ,0.03958163 ,0.04146709 ,0.04335558 ,0.04526194 ,0.04719444
 ,0.04913589 ,0.05109307 ,0.0530587  ,0.05503174 ,0.05702619 ,0.05902879
 ,0.06103175 ,0.06304536 ,0.06507508 ,0.06713504 ,0.06920701 ,0.07128152
 ,0.07336337 ,0.07546365 ,0.07759109 ,0.07972717 ,0.08189945 ,0.08409469
 ,0.08630109 ,0.08853381 ,0.09077941 ,0.09303524 ,0.09530348 ,0.09759812
 ,0.09990547 ,0.10221648 ,0.10454616 ,0.10689487 ,0.10925207 ,0.11163134
 ,0.11404813 ,0.11647586 ,0.11890275 ,0.12135138 ,0.12385609 ,0.12638735
 ,0.12892453 ,0.131483   ,0.13405755 ,0.13664916 ,0.1392584  ,0.14188803
 ,0.14456151 ,0.14725911 ,0.14997879 ,0.15270078 ,0.15543435 ,0.1581876
 ,0.16099229 ,0.16384181 ,0.1666957  ,0.16955296 ,0.1724489  ,0.17538709
 ,0.17833811 ,0.18131805 ,0.1843131  ,0.18732788 ,0.19035587 ,0.19340125
 ,0.19647509 ,0.19957923 ,0.20270197 ,0.20585666 ,0.20900943 ,0.21216886
 ,0.21533201 ,0.21851364 ,0.22170169 ,0.22488955 ,0.22806051 ,0.23122644
 ,0.23496439 ,0.23867949 ,0.24180912 ,0.24489915 ,0.2479513  ,0.2510038
 ,0.25405476 ,0.25706616 ,0.26004738 ,0.26301429 ,0.26596996 ,0.26891409
 ,0.27181726 ,0.27472832 ,0.27762519 ,0.28049599 ,0.28335751 ,0.2862217
 ,0.28903924 ,0.2918378  ,0.29466928 ,0.29753226 ,0.3003725  ,0.30320749
 ,0.30605062 ,0.30890103 ,0.31173942 ,0.31458288 ,0.31742699 ,0.32029394
 ,0.3231558  ,0.32601312 ,0.32886802 ,0.33174716 ,0.33464914 ,0.33756703
 ,0.3405056  ,0.34345468 ,0.3464366  ,0.34945873 ,0.3525165  ,0.35557767
 ,0.3586402  ,0.36173728 ,0.3648633  ,0.36799896 ,0.37119047 ,0.37440757
 ,0.37767244 ,0.38095973 ,0.38427836 ,0.38764292 ,0.39105769 ,0.3945125
 ,0.39801846 ,0.40157455 ,0.40520294 ,0.4088979  ,0.41264807 ,0.41645673
 ,0.42035243 ,0.42432863 ,0.42838236 ,0.43251913 ,0.4367284  ,0.44099847
 ,0.44537315 ,0.44985226 ,0.45446022 ,0.45919666 ,0.46406003 ,0.46904211
 ,0.47417105 ,0.4794602  ,0.48490359 ,0.49052266 ,0.49630813 ,0.50231718
 ,0.50855732 ,0.51503574 ,0.52175303 ,0.52877732 ,0.53613466 ,0.54385385
 ,0.55193305 ,0.56040531 ,0.5693858  ,0.57891037 ,0.58899895 ,0.5997746
 ,0.61132465 ,0.62378215 ,0.63726827 ,0.65197994 ,0.66822371 ,0.68640309
 ,0.70695784 ,0.73057162 ,0.75849408 ,0.79275805 ,0.83712088 ,0.90045365
 ,1.        };
 
std::vector<double> spaceCorrDUBLIN = {0.0 ,4.99999663e-03 ,9.99999326e-03 ,1.49999894e-02
 ,1.99999865e-02, 2.49999817e-02, 2.99999788e-02, 3.49999741e-02
 ,3.99999730e-02, 4.49999683e-02, 4.99999635e-02, 5.49999624e-02
 ,5.99999577e-02, 6.49999529e-02, 6.99999481e-02, 7.49999434e-02
 ,7.99999461e-02, 8.49999413e-02, 8.99999365e-02, 9.49999318e-02
 ,9.99999270e-02, 1.04999922e-01, 1.09999925e-01, 1.14999920e-01
 ,1.19999915e-01, 1.24999911e-01, 1.29999906e-01, 1.34999901e-01
 ,1.39999896e-01, 1.44999892e-01, 1.49999887e-01, 1.54999882e-01
 ,1.59999892e-01, 1.64999887e-01, 1.69999883e-01, 1.74999878e-01
 ,1.79999873e-01, 1.84999868e-01, 1.89999864e-01, 1.94999859e-01
 ,1.99999854e-01, 2.04999849e-01, 2.09999844e-01, 2.14999840e-01
 ,2.19999850e-01, 2.24999845e-01, 2.29999840e-01, 2.34999835e-01
 ,2.39999831e-01, 2.44999826e-01, 2.49999821e-01, 2.54999816e-01
 ,2.59999812e-01, 2.64999807e-01, 2.69999802e-01, 2.74999797e-01
 ,2.79999793e-01, 2.84999788e-01, 2.89999783e-01, 2.94999778e-01
 ,2.99999774e-01, 3.04999769e-01, 3.09999764e-01, 3.14999789e-01
 ,3.19999784e-01, 3.24999779e-01, 3.29999775e-01, 3.34999770e-01
 ,3.39999765e-01, 3.44999760e-01, 3.49999756e-01, 3.54999751e-01
 ,3.59999746e-01, 3.64999741e-01, 3.69999737e-01, 3.74999732e-01
 ,3.79999727e-01, 3.84999722e-01, 3.89999717e-01, 3.94999713e-01
 ,3.99999708e-01, 4.04999703e-01, 4.09999698e-01, 4.14999694e-01
 ,4.19999689e-01, 4.24999684e-01, 4.29999679e-01, 4.34999675e-01
 ,4.39999700e-01, 4.44999695e-01, 4.49999690e-01, 4.54999685e-01
 ,4.59999681e-01, 4.64999676e-01, 4.69999671e-01, 4.74999666e-01
 ,4.79999661e-01, 4.84999657e-01, 4.89999652e-01, 4.94999647e-01
 ,4.99999642e-01, 5.04999638e-01, 5.09999633e-01, 5.14999628e-01
 ,5.19999623e-01, 5.24999619e-01, 5.29999614e-01, 5.34999609e-01
 ,5.39999604e-01, 5.44999599e-01, 5.49999595e-01, 5.54999590e-01
 ,5.59999585e-01, 5.64999580e-01, 5.69999576e-01, 5.74999571e-01
 ,5.79999566e-01, 5.84999561e-01, 5.89999557e-01, 5.94999552e-01
 ,5.99999547e-01, 6.04999542e-01, 6.09999537e-01, 6.14999533e-01
 ,6.19999528e-01, 6.24999583e-01, 6.29999578e-01, 6.34999573e-01
 ,6.39999568e-01, 6.44999564e-01, 6.49999559e-01, 6.54999554e-01
 ,6.59999549e-01, 6.64999545e-01, 6.69999540e-01, 6.74999535e-01
 ,6.79999530e-01, 6.84999526e-01, 6.89999521e-01, 6.94999516e-01
 ,6.99999511e-01, 7.04999506e-01, 7.09999502e-01, 7.14999497e-01
 ,7.19999492e-01, 7.24999487e-01, 7.29999483e-01, 7.34999478e-01
 ,7.39999473e-01, 7.44999468e-01, 7.49999464e-01, 7.54999459e-01
 ,7.59999454e-01, 7.64999449e-01, 7.69999444e-01, 7.74999440e-01
 ,7.79999435e-01, 7.84999430e-01, 7.89999425e-01, 7.94999421e-01
 ,7.99999416e-01, 8.04999411e-01, 8.09999406e-01, 8.14999402e-01
 ,8.19999397e-01, 8.24999392e-01, 8.29999387e-01, 8.34999382e-01
 ,8.39999378e-01, 8.44999373e-01, 8.49999368e-01, 8.54999363e-01
 ,8.59999359e-01, 8.64999354e-01, 8.69999349e-01, 8.74999404e-01
 ,8.79999399e-01, 8.84999394e-01, 8.89999390e-01, 8.94999385e-01
 ,8.99999380e-01, 9.04999375e-01, 9.09999371e-01, 9.14999366e-01
 ,9.19999361e-01, 9.24999356e-01, 9.29999352e-01, 9.34999347e-01
 ,9.39999342e-01, 9.44999337e-01, 9.49999332e-01, 9.54999328e-01
 ,9.59999323e-01, 9.64999318e-01, 9.69999313e-01, 9.74999309e-01
 ,9.79999304e-01, 9.84999299e-01, 9.89999294e-01, 1.0};

std::vector<double> spaceProbDUBLIN = {0.0,0.0,0.00222471 ,0.00369953 ,0.00494951 ,0.00612526 ,0.00726693
 ,0.00838431 ,0.0094892  ,0.01057381 ,0.01163421 ,0.01267144 ,0.01369882
 ,0.01472379 ,0.0157382  ,0.01674726 ,0.01774915 ,0.01874278 ,0.01973753
 ,0.02072812 ,0.02170232 ,0.02267662 ,0.02365592 ,0.02463718 ,0.02562121
 ,0.02660122 ,0.02757589 ,0.02855643 ,0.02954347 ,0.03053779 ,0.0315415
 ,0.03254214 ,0.03354409 ,0.03455226 ,0.03556838 ,0.03659409 ,0.03762359
 ,0.03865657 ,0.03970152 ,0.0407578  ,0.04182756 ,0.04290536 ,0.04398487
 ,0.04507196 ,0.04617302 ,0.04729318 ,0.04842453 ,0.04956558 ,0.05072045
 ,0.0518826  ,0.05305491 ,0.0542387  ,0.05543502 ,0.05664357 ,0.05787176
 ,0.05910933 ,0.06035262 ,0.06160874 ,0.06287516 ,0.06415895 ,0.06546208
 ,0.06677914 ,0.06810985 ,0.06945999 ,0.07082638 ,0.07220297 ,0.07359506
 ,0.07500037 ,0.07642134 ,0.0778615  ,0.07931773 ,0.08078869 ,0.08227624
 ,0.0837864  ,0.08531688 ,0.0868602  ,0.08841035 ,0.08997309 ,0.09155573
 ,0.09315562 ,0.09477783 ,0.09642211 ,0.09808136 ,0.09974891 ,0.10142903
 ,0.10313278 ,0.10485735 ,0.10660027 ,0.10835897 ,0.11012611 ,0.11190516
 ,0.11370237 ,0.11551439 ,0.11732841 ,0.11915276 ,0.12098487 ,0.1228184
 ,0.1250199  ,0.1272263  ,0.12906944 ,0.13089341 ,0.13271536 ,0.13453767
 ,0.13636555 ,0.13819391 ,0.14001326 ,0.14182312 ,0.14363499 ,0.14545227
 ,0.14726933 ,0.14909087 ,0.15091059 ,0.15273994 ,0.15457539 ,0.1564289
 ,0.15828752 ,0.16014498 ,0.16203149 ,0.16392256 ,0.16581793 ,0.1677355
 ,0.16967095 ,0.17162148 ,0.1735842  ,0.17556906 ,0.17757372 ,0.17958931
 ,0.18162449 ,0.18368105 ,0.18577119 ,0.18787534 ,0.18999932 ,0.1921476
 ,0.19431776 ,0.1965184  ,0.19874699 ,0.20100422 ,0.20329216 ,0.20561326
 ,0.20796795 ,0.21035259 ,0.21277359 ,0.21522656 ,0.21771686 ,0.22024035
 ,0.22279741 ,0.22540243 ,0.22805099 ,0.23074492 ,0.23348714 ,0.23628114
 ,0.23912353 ,0.24201635 ,0.24496961 ,0.24797733 ,0.25106271 ,0.25421725
 ,0.25743395 ,0.26072    ,0.26409427 ,0.26754562 ,0.27107913 ,0.27471698
 ,0.27844854 ,0.28228337 ,0.28622792 ,0.29027764 ,0.29445354 ,0.2987614
 ,0.30320308 ,0.3077996  ,0.31255641 ,0.31749303 ,0.32261609 ,0.32794065
 ,0.33347043 ,0.33923575 ,0.34527854 ,0.35158964 ,0.35821266 ,0.36518168
 ,0.3725149  ,0.3802919  ,0.38855417 ,0.39733118 ,0.40671337 ,0.41680306
 ,0.42770895 ,0.43958503 ,0.45260141 ,0.46696797 ,0.48301445 ,0.50112347
 ,0.52190492 ,0.54627009 ,0.57568472 ,0.61270266 ,0.66260491 ,0.7402241
 ,1.        };
// Without Attention
std::vector<double> spaceCorr = {0.0 ,5.01321116e-03 ,1.00131324e-02 ,1.50130531e-02
 ,2.00129747e-02, 2.50128955e-02, 3.00128162e-02, 3.50127369e-02
 ,4.00126576e-02, 4.50125784e-02, 5.00124991e-02, 5.50124198e-02
 ,6.00123443e-02, 6.50122613e-02, 7.00121820e-02, 7.50121027e-02
 ,8.00120234e-02, 8.50119442e-02, 9.00118724e-02, 9.50117931e-02
 ,1.00011714e-01, 1.05011635e-01, 1.10011555e-01, 1.15011476e-01
 ,1.20011397e-01, 1.25011310e-01, 1.30011231e-01, 1.35011151e-01
 ,1.40011072e-01, 1.45010993e-01, 1.50010929e-01, 1.55010849e-01
 ,1.60010770e-01, 1.65010691e-01, 1.70010611e-01, 1.75010532e-01
 ,1.80010453e-01, 1.85010374e-01, 1.90010294e-01, 1.95010215e-01
 ,2.00010136e-01, 2.05010056e-01, 2.10009977e-01, 2.15009898e-01
 ,2.20009819e-01, 2.25009739e-01, 2.30009660e-01, 2.35009581e-01
 ,2.40009502e-01, 2.45009422e-01, 2.50009328e-01, 2.55009264e-01
 ,2.60009170e-01, 2.65009105e-01, 2.70009011e-01, 2.75008947e-01
 ,2.80008882e-01, 2.85008788e-01, 2.90008724e-01, 2.95008630e-01
 ,3.00008565e-01, 3.05008471e-01, 3.10008407e-01, 3.15008312e-01
 ,3.20008248e-01, 3.25008154e-01, 3.30008090e-01, 3.35007995e-01
 ,3.40007931e-01, 3.45007837e-01, 3.50007772e-01, 3.55007678e-01
 ,3.60007614e-01, 3.65007520e-01, 3.70007455e-01, 3.75007361e-01
 ,3.80007297e-01, 3.85007203e-01, 3.90007138e-01, 3.95007044e-01
 ,4.00006980e-01, 4.05006886e-01, 4.10006821e-01, 4.15006727e-01
 ,4.20006663e-01, 4.25006568e-01, 4.30006504e-01, 4.35006410e-01
 ,4.40006346e-01, 4.45006251e-01, 4.50006187e-01, 4.55006093e-01
 ,4.60006028e-01, 4.65005934e-01, 4.70005870e-01, 4.75005776e-01
 ,4.80005711e-01, 4.85005617e-01, 4.90005553e-01, 4.95005459e-01
 ,5.00005364e-01, 5.05005300e-01, 5.10005236e-01, 5.15005171e-01
 ,5.20005107e-01, 5.25004983e-01, 5.30004919e-01, 5.35004854e-01
 ,5.40004790e-01, 5.45004666e-01, 5.50004601e-01, 5.55004537e-01
 ,5.60004473e-01, 5.65004349e-01, 5.70004284e-01, 5.75004220e-01
 ,5.80004156e-01, 5.85004032e-01, 5.90003967e-01, 5.95003903e-01
 ,6.00003839e-01, 6.05003715e-01, 6.10003650e-01, 6.15003586e-01
 ,6.20003521e-01, 6.25003397e-01, 6.30003333e-01, 6.35003269e-01
 ,6.40003204e-01, 6.45003080e-01, 6.50003016e-01, 6.55002952e-01
 ,6.60002887e-01, 6.65002763e-01, 6.70002699e-01, 6.75002635e-01
 ,6.80002570e-01, 6.85002446e-01, 6.90002382e-01, 6.95002317e-01
 ,7.00002253e-01, 7.05002129e-01, 7.10002065e-01, 7.15002000e-01
 ,7.20001936e-01, 7.25001812e-01, 7.30001748e-01, 7.35001683e-01
 ,7.40001619e-01, 7.45001495e-01, 7.50001431e-01, 7.55001366e-01
 ,7.60001302e-01, 7.65001237e-01, 7.70001113e-01, 7.75001049e-01
 ,7.80000985e-01, 7.85000920e-01, 7.90000796e-01, 7.95000732e-01
 ,8.00000668e-01, 8.05000603e-01, 8.10000479e-01, 8.15000415e-01
 ,8.20000350e-01, 8.25000286e-01, 8.30000162e-01, 8.35000098e-01
 ,8.40000033e-01, 8.44999969e-01, 8.49999845e-01, 8.54999781e-01
 ,8.59999716e-01, 8.64999652e-01, 8.69999528e-01, 8.74999464e-01
 ,8.79999399e-01, 8.84999335e-01, 8.89999211e-01, 8.94999146e-01
 ,8.99999082e-01, 9.04999018e-01, 9.09998894e-01, 9.14998829e-01
 ,9.19998765e-01, 9.24998701e-01, 9.29998577e-01, 9.34998512e-01
 ,9.39998448e-01, 9.44998384e-01, 9.49998260e-01, 9.54998195e-01
 ,9.59998131e-01, 9.64998066e-01, 9.69997942e-01, 9.74997878e-01
 ,9.79997814e-01, 9.84997749e-01, 9.89997625e-01, 1.0};

std::vector<double> spaceProb = {0.0,0.0,  .00195898, 0.00357165, 0.00500644, 0.00632557, 0.00757813
 ,0.00879118, 0.00997973 ,0.01115117 ,0.01230161 ,0.01342482 ,0.01452877
 ,0.0156378 , 0.01675254 ,0.01785096 ,0.01894217 ,0.02003805 ,0.02112368
 ,0.0222167 , 0.02333164 ,0.02445237 ,0.02556642 ,0.02668225 ,0.02780843
 ,0.02893386, 0.03007511 ,0.03122621 ,0.03236788 ,0.03353747 ,0.0347253
 ,0.03591878, 0.03712798 ,0.03834578 ,0.03958075 ,0.04082456 ,0.04206875
 ,0.04333074, 0.04461367 ,0.0459212  ,0.04725447 ,0.04859619 ,0.04994938
 ,0.05132945, 0.05274087 ,0.05416503 ,0.05560787 ,0.05707806 ,0.05855657
 ,0.06005333, 0.061579   ,0.06312901 ,0.06471673 ,0.06634192 ,0.06800086
 ,0.06969038, 0.07141285 ,0.07318433 ,0.07497784 ,0.07679436 ,0.07866776
 ,0.08060382, 0.08259203 ,0.08461203 ,0.08667635 ,0.08878635 ,0.09095531
 ,0.0932076 , 0.09552373 ,0.09789391 ,0.10031998 ,0.10282052 ,0.10541038
 ,0.10807577, 0.11086499 ,0.1137604  ,0.11674222 ,0.11983796 ,0.12307273
 ,0.1264293 , 0.12989361 ,0.13349112 ,0.13726083 ,0.14117398 ,0.14521353
 ,0.14940494, 0.15375911 ,0.15827291 ,0.16290825 ,0.16768941 ,0.17264312
 ,0.17771155, 0.18291504 ,0.18821775 ,0.19360144 ,0.19902581 ,0.20449289
 ,0.21128797, 0.2182034  ,0.22391162 ,0.22943283 ,0.23475296 ,0.23990154
 ,0.24490849, 0.24977815 ,0.25452919 ,0.25914809 ,0.26359309 ,0.26794047
 ,0.27216553, 0.27627924 ,0.28027826 ,0.28417864 ,0.2880058  ,0.29174497
 ,0.29538617, 0.29893073 ,0.30240822 ,0.30582336 ,0.30917198 ,0.31245205
 ,0.31565569, 0.31885875 ,0.32200886 ,0.3251049  ,0.32817631 ,0.33121182
 ,0.33420893, 0.33718241 ,0.34014412 ,0.34308985 ,0.34600925 ,0.348933
 ,0.35184324, 0.35472998 ,0.35758348 ,0.36045033 ,0.3633205  ,0.36619498
 ,0.36905595, 0.37190915 ,0.37478305 ,0.37768372 ,0.38060239 ,0.38351149
 ,0.38641736, 0.38936165 ,0.3923065  ,0.39528112 ,0.39826586 ,0.40129391
 ,0.40433463, 0.40741637 ,0.41055872 ,0.41371462 ,0.41691095 ,0.42013752
 ,0.4234201 , 0.4267431  ,0.43014208 ,0.43358588 ,0.43708435 ,0.44066213
 ,0.44432003, 0.4480487  ,0.45183663 ,0.4557246  ,0.45971897 ,0.46380786
 ,0.46801893, 0.47231142 ,0.47677562 ,0.48137264 ,0.48610318 ,0.49099675
 ,0.49605909, 0.50132195 ,0.50680723 ,0.51252826 ,0.51848957 ,0.52469391
 ,0.53121003, 0.53808913 ,0.54537401 ,0.55308251 ,0.56131861 ,0.57008489
 ,0.57950252, 0.58968345 ,0.6007666  ,0.6129281  ,0.62638153 ,0.64149181
 ,0.65872244, 0.67878127 ,0.7027543  ,0.73249943 ,0.77204769 ,0.8320679
 ,1.};

 // With ATTENTION::
/*
std::vector<double> spaceCorr = {0.0, 5.00340527e-03, 1.00033870e-02, 1.50033692e-02
 ,2.00033505e-02, 2.50033326e-02, 3.00033130e-02, 3.50032970e-02
 ,4.00032774e-02, 4.50032577e-02, 5.00032417e-02, 5.50032221e-02
 ,6.00032024e-02, 6.50031865e-02, 7.00031668e-02, 7.50031471e-02
 ,8.00031275e-02, 8.50031152e-02, 9.00030956e-02, 9.50030759e-02
 ,1.00003056e-01, 1.05003037e-01, 1.10003024e-01, 1.15003005e-01
 ,1.20002985e-01, 1.25002965e-01, 1.30002946e-01, 1.35002926e-01
 ,1.40002906e-01, 1.45002887e-01, 1.50002867e-01, 1.55002862e-01
 ,1.60002843e-01, 1.65002823e-01, 1.70002803e-01, 1.75002784e-01
 ,1.80002764e-01, 1.85002744e-01, 1.90002725e-01, 1.95002705e-01
 ,2.00002685e-01, 2.05002680e-01, 2.10002661e-01, 2.15002641e-01
 ,2.20002621e-01, 2.25002602e-01, 2.30002582e-01, 2.35002562e-01
 ,2.40002543e-01, 2.45002523e-01, 2.50002503e-01, 2.55002499e-01
 ,2.60002464e-01, 2.65002459e-01, 2.70002425e-01, 2.75002420e-01
 ,2.80002385e-01, 2.85002381e-01, 2.90002376e-01, 2.95002341e-01
 ,3.00002337e-01, 3.05002302e-01, 3.10002297e-01, 3.15002263e-01
 ,3.20002258e-01, 3.25002223e-01, 3.30002218e-01, 3.35002184e-01
 ,3.40002179e-01, 3.45002174e-01, 3.50002140e-01, 3.55002135e-01
 ,3.60002100e-01, 3.65002096e-01, 3.70002061e-01, 3.75002056e-01
 ,3.80002022e-01, 3.85002017e-01, 3.90001982e-01, 3.95001978e-01
 ,4.00001973e-01, 4.05001938e-01, 4.10001934e-01, 4.15001899e-01
 ,4.20001894e-01, 4.25001860e-01, 4.30001855e-01, 4.35001820e-01
 ,4.40001816e-01, 4.45001781e-01, 4.50001776e-01, 4.55001771e-01
 ,4.60001737e-01, 4.65001732e-01, 4.70001698e-01, 4.75001693e-01
 ,4.80001658e-01, 4.85001653e-01, 4.90001619e-01, 4.95001614e-01
 ,5.00001609e-01, 5.05001545e-01, 5.10001540e-01, 5.15001535e-01
 ,5.20001531e-01, 5.25001526e-01, 5.30001462e-01, 5.35001457e-01
 ,5.40001452e-01, 5.45001447e-01, 5.50001383e-01, 5.55001378e-01
 ,5.60001373e-01, 5.65001369e-01, 5.70001364e-01, 5.75001299e-01
 ,5.80001295e-01, 5.85001290e-01, 5.90001285e-01, 5.95001221e-01
 ,6.00001216e-01, 6.05001211e-01, 6.10001206e-01, 6.15001142e-01
 ,6.20001137e-01, 6.25001132e-01, 6.30001128e-01, 6.35001123e-01
 ,6.40001059e-01, 6.45001054e-01, 6.50001049e-01, 6.55001044e-01
 ,6.60000980e-01, 6.65000975e-01, 6.70000970e-01, 6.75000966e-01
 ,6.80000961e-01, 6.85000896e-01, 6.90000892e-01, 6.95000887e-01
 ,7.00000882e-01, 7.05000818e-01, 7.10000813e-01, 7.15000808e-01
 ,7.20000803e-01, 7.25000739e-01, 7.30000734e-01, 7.35000730e-01
 ,7.40000725e-01, 7.45000720e-01, 7.50000656e-01, 7.55000651e-01
 ,7.60000646e-01, 7.65000641e-01, 7.70000577e-01, 7.75000572e-01
 ,7.80000567e-01, 7.85000563e-01, 7.90000558e-01, 7.95000494e-01
 ,8.00000489e-01, 8.05000484e-01, 8.10000479e-01, 8.15000415e-01
 ,8.20000410e-01, 8.25000405e-01, 8.30000401e-01, 8.35000336e-01
 ,8.40000331e-01, 8.45000327e-01, 8.50000322e-01, 8.55000317e-01
 ,8.60000253e-01, 8.65000248e-01, 8.70000243e-01, 8.75000238e-01
 ,8.80000174e-01, 8.85000169e-01, 8.90000165e-01, 8.95000160e-01
 ,9.00000155e-01, 9.05000091e-01, 9.10000086e-01, 9.15000081e-01
 ,9.20000076e-01, 9.25000012e-01, 9.30000007e-01, 9.35000002e-01
 ,9.39999998e-01, 9.44999933e-01, 9.49999928e-01, 9.54999924e-01
 ,9.59999919e-01, 9.64999914e-01, 9.69999850e-01, 9.74999845e-01
 ,9.79999840e-01, 9.84999835e-01, 9.89999771e-01, 1.0};

std::vector<double> spaceProb ={0.0,0.0,  0.0023275, 0.00413935, 0.00567632, 0.00707687, 0.00837724
 ,0.00959742, 0.01075961, 0.01188539, 0.01298508, 0.01406045, 0.01512478
 ,0.01617204, 0.01720136, 0.01822613, 0.01924003, 0.02023535, 0.02122792
 ,0.02223662, 0.02325179, 0.0242555 , 0.02525951, 0.02625524, 0.02725385
 ,0.02826448, 0.02927567, 0.03028474, 0.03130191, 0.0323413 , 0.03337659
 ,0.03441324, 0.03547175, 0.0365403 , 0.03761203, 0.03867733, 0.03975112
 ,0.04085598, 0.04197432, 0.04310311, 0.04424088, 0.04537661, 0.04653133
 ,0.04770968, 0.04892037, 0.0501447 , 0.05137529, 0.05262343, 0.05388302
 ,0.05516737, 0.0564766 , 0.05780604, 0.05915369, 0.06053872, 0.06195259
 ,0.06339009, 0.06484771, 0.06633813, 0.06787255, 0.06943299, 0.0710172
 ,0.07262644, 0.07428397, 0.0760071 , 0.07776741, 0.07955411, 0.08137665
 ,0.08324873, 0.0851748 , 0.08715197, 0.08918697, 0.09127854, 0.09345182
 ,0.09571027, 0.09803384, 0.10043483, 0.10292652, 0.10550697, 0.10817934
 ,0.1109515 , 0.11381878, 0.11679181, 0.11988664, 0.12310635, 0.12644772
 ,0.12990293, 0.1335058 , 0.1372584 , 0.14116238, 0.14523239, 0.14945836
 ,0.15385254, 0.15839232, 0.16308341, 0.16791936, 0.17289035, 0.17800292
 ,0.18324386, 0.19004635, 0.19722501, 0.2030889 , 0.20859386, 0.21391617
 ,0.21908868, 0.22412305, 0.22904112, 0.23385839, 0.23856151, 0.24314941
 ,0.24763851, 0.25201129, 0.25627612, 0.26043778, 0.26450251, 0.26846729
 ,0.27236604, 0.27618322, 0.27992247, 0.2836081 , 0.2872127 , 0.29075075
 ,0.29422377, 0.29763869, 0.30099527, 0.30430599, 0.30756343, 0.31079199
 ,0.31398683, 0.31713475, 0.32025039, 0.32332875, 0.32636088, 0.32936938
 ,0.33238255, 0.33537545, 0.33834067, 0.34129113, 0.34422244, 0.3471377
 ,0.35003779, 0.35292254, 0.35581124, 0.35869707, 0.36157943, 0.36447602
 ,0.36735757, 0.37024276, 0.37313592, 0.37605948, 0.37901559, 0.38198234
 ,0.38496333, 0.38796779, 0.39100898, 0.39405672, 0.39714292, 0.40026094
 ,0.40342625, 0.40662912, 0.40988186, 0.41320004, 0.41658308, 0.42005953
 ,0.42357724, 0.42717705, 0.43084872, 0.43460328, 0.43845765, 0.44244333
 ,0.4465394 , 0.45073076, 0.45502564, 0.45946272, 0.46406995, 0.4688119
 ,0.47373219, 0.47884337, 0.48419155, 0.48974662, 0.49554732, 0.50161187
 ,0.50801137, 0.51478962, 0.52192225, 0.52950534, 0.53756967, 0.54624003
 ,0.5555338 , 0.56557039, 0.57654628, 0.58865304, 0.60206409, 0.61712885
 ,0.63433656, 0.65438753, 0.67842073, 0.7083464 , 0.74820577, 0.80889095
 ,1.0 };
 */

// With ATTENTION MULTI SCALE FEATURES 
std::vector<double> spaceCorrAttMS = {0.0 ,5.0019301e-03 ,1.0001909e-02 ,1.5001888e-02 ,2.0001866e-02
 ,2.5001846e-02, 3.0001825e-02, 3.5001803e-02, 4.0001784e-02, 4.5001760e-02
 ,5.0001740e-02, 5.5001721e-02, 6.0001697e-02, 6.5001674e-02, 7.0001654e-02
 ,7.5001635e-02, 8.0001615e-02, 8.5001595e-02, 9.0001568e-02, 9.5001549e-02
 ,1.0000153e-01, 1.0500151e-01, 1.1000149e-01, 1.1500147e-01, 1.2000144e-01
 ,1.2500143e-01, 1.3000140e-01, 1.3500138e-01, 1.4000136e-01, 1.4500134e-01
 ,1.5000132e-01, 1.5500130e-01, 1.6000128e-01, 1.6500126e-01, 1.7000124e-01
 ,1.7500122e-01, 1.8000120e-01, 1.8500116e-01, 1.9000115e-01, 1.9500113e-01
 ,2.0000111e-01, 2.0500109e-01, 2.1000107e-01, 2.1500105e-01, 2.2000103e-01
 ,2.2500101e-01, 2.3000099e-01, 2.3500095e-01, 2.4000093e-01, 2.4500091e-01
 ,2.5000089e-01, 2.5500089e-01, 2.6000085e-01, 2.6500082e-01, 2.7000082e-01
 ,2.7500078e-01, 2.8000078e-01, 2.8500074e-01, 2.9000074e-01, 2.9500070e-01
 ,3.0000070e-01, 3.0500066e-01, 3.1000066e-01, 3.1500062e-01, 3.2000059e-01
 ,3.2500058e-01, 3.3000055e-01, 3.3500054e-01, 3.4000051e-01, 3.4500051e-01
 ,3.5000047e-01, 3.5500047e-01, 3.6000043e-01, 3.6500043e-01, 3.7000039e-01
 ,3.7500036e-01, 3.8000035e-01, 3.8500032e-01, 3.9000031e-01, 3.9500028e-01
 ,4.0000027e-01, 4.0500024e-01, 4.1000023e-01, 4.1500020e-01, 4.2000017e-01
 ,4.2500016e-01, 4.3000013e-01, 4.3500012e-01, 4.4000009e-01, 4.4500008e-01
 ,4.5000005e-01, 4.5500004e-01, 4.6000001e-01, 4.6500000e-01, 4.6999997e-01
 ,4.7499993e-01, 4.7999993e-01, 4.8499990e-01, 4.8999989e-01, 4.9499986e-01
 ,4.9999985e-01, 5.0499982e-01, 5.0999981e-01, 5.1499981e-01, 5.1999974e-01
 ,5.2499974e-01, 5.2999973e-01, 5.3499967e-01, 5.3999966e-01, 5.4499966e-01
 ,5.4999965e-01, 5.5499959e-01, 5.5999959e-01, 5.6499958e-01, 5.6999958e-01
 ,5.7499951e-01, 5.7999951e-01, 5.8499950e-01, 5.8999944e-01, 5.9499943e-01
 ,5.9999943e-01, 6.0499942e-01, 6.0999936e-01, 6.1499935e-01, 6.1999935e-01
 ,6.2499934e-01, 6.2999928e-01, 6.3499928e-01, 6.3999927e-01, 6.4499921e-01
 ,6.4999920e-01, 6.5499920e-01, 6.5999919e-01, 6.6499913e-01, 6.6999912e-01
 ,6.7499912e-01, 6.7999911e-01, 6.8499905e-01, 6.8999904e-01, 6.9499904e-01
 ,6.9999897e-01, 7.0499897e-01, 7.0999897e-01, 7.1499896e-01, 7.1999890e-01
 ,7.2499889e-01, 7.2999889e-01, 7.3499888e-01, 7.3999882e-01, 7.4499881e-01
 ,7.4999881e-01, 7.5499874e-01, 7.5999874e-01, 7.6499873e-01, 7.6999873e-01
 ,7.7499866e-01, 7.7999866e-01, 7.8499866e-01, 7.8999859e-01, 7.9499859e-01
 ,7.9999858e-01, 8.0499858e-01, 8.0999851e-01, 8.1499851e-01, 8.1999850e-01
 ,8.2499850e-01, 8.2999843e-01, 8.3499843e-01, 8.3999842e-01, 8.4499836e-01
 ,8.4999835e-01, 8.5499835e-01, 8.5999835e-01, 8.6499828e-01, 8.6999828e-01
 ,8.7499827e-01, 8.7999827e-01, 8.8499820e-01, 8.8999820e-01, 8.9499819e-01
 ,8.9999813e-01, 9.0499812e-01, 9.0999812e-01, 9.1499811e-01, 9.1999805e-01
 ,9.2499804e-01, 9.2999804e-01, 9.3499804e-01, 9.3999797e-01, 9.4499797e-01
 ,9.4999796e-01, 9.5499790e-01, 9.5999789e-01, 9.6499789e-01, 9.6999788e-01
 ,9.7499782e-01, 9.7999781e-01, 9.8499781e-01, 9.8999780e-01, 1.0};

std::vector<double> spaceProbAttMS ={0.0,0.0,0.00214986, 0.00382798, 0.00532545, 0.00671304, 0.00800585,
 0.00924477, 0.01045326 ,0.01162766 ,0.01277646 ,0.0138971  ,0.01499359,
 0.01608113, 0.01716253 ,0.01824312 ,0.01933726 ,0.02043475 ,0.02151054,
 0.02259537, 0.02369295 ,0.02477946 ,0.02586904 ,0.02697107 ,0.02808974,
 0.02921161, 0.03032578 ,0.03144761 ,0.03257444 ,0.03371111 ,0.03486551,
 0.03603454, 0.03722386 ,0.03842307 ,0.03962014 ,0.04082826 ,0.04206391,
 0.04331764, 0.04457811 ,0.04584424 ,0.04712626 ,0.0484255  ,0.04974509,
 0.05108302, 0.05244481 ,0.05380457 ,0.05516813 ,0.05657726 ,0.05799613,
 0.05944114, 0.06091691 ,0.06240041 ,0.06390678 ,0.06544568 ,0.06701973,
 0.0686173 , 0.07022406 ,0.07184613 ,0.07349416 ,0.0751733  ,0.07690396,
 0.07866531, 0.08044476 ,0.08224323 ,0.08408934 ,0.08599389 ,0.08794699,
 0.08994524, 0.09198331 ,0.09406416 ,0.09619658 ,0.09838728 ,0.10062104,
 0.10291839, 0.10528834 ,0.10773185 ,0.11023234 ,0.11279544 ,0.11545326,
 0.11820759, 0.12105082 ,0.12397774 ,0.12702016 ,0.13017969 ,0.13344889,
 0.13683827, 0.14035615 ,0.14401336 ,0.14780237 ,0.15173141 ,0.15580815,
 0.16004158, 0.16440984 ,0.16894441 ,0.1736093  ,0.17834517 ,0.1831817 ,
 0.18809685, 0.19406086 ,0.20023602 ,0.20538795 ,0.2102688  ,0.21504691,
 0.21973592, 0.22432817 ,0.22881988 ,0.23321632 ,0.23754095 ,0.24178409,
 0.24593461, 0.24998011 ,0.25393324 ,0.25781708 ,0.26160831 ,0.26532435,
 0.26896465, 0.27256642 ,0.2761025  ,0.27956796 ,0.28297056 ,0.2863008 ,
 0.2895711 , 0.29280528 ,0.29599796 ,0.29913025 ,0.30224104 ,0.30532242,
 0.30837524, 0.31137856 ,0.3143413  ,0.31728873 ,0.32020769 ,0.3230928 ,
 0.32596772, 0.32884227 ,0.33171072 ,0.33454568 ,0.33736578 ,0.34020304,
 0.34302006, 0.34583479 ,0.34865663 ,0.35147412 ,0.35430255 ,0.3571241 ,
 0.35996187, 0.36282269 ,0.36570238 ,0.36861318 ,0.37153809 ,0.37447187,
 0.37743619, 0.38043238 ,0.38345412 ,0.38650393 ,0.38961951 ,0.39277735,
 0.3959589 , 0.39920599 ,0.40253769 ,0.40591117 ,0.40934353 ,0.41282615,
 0.41640201, 0.42005599 ,0.42379348 ,0.42762522 ,0.43155791 ,0.43559011,
 0.43971647, 0.4439752  ,0.44835832 ,0.45290891 ,0.45762176 ,0.46251719,
 0.46755919, 0.47278039 ,0.47821801 ,0.48389916 ,0.48983449 ,0.49604524,
 0.50262824, 0.50954698 ,0.51684883 ,0.52458706 ,0.53286111 ,0.54169161,
 0.55119783, 0.5614883  ,0.57274916 ,0.58513156 ,0.59886031 ,0.61433334,
 0.63198369, 0.65254843 ,0.67719517 ,0.70799207 ,0.74893783 ,0.81133126,
 1. };
 
 
 
 std::vector<double> spaceCorrToulouse={0.0, 5.00511844e-03, 1.00050922e-02, 1.50050670e-02,
 2.00050417e-02, 2.50050146e-02, 3.00049894e-02, 3.50049622e-02,
 4.00049388e-02, 4.50049117e-02, 5.00048883e-02, 5.50048612e-02,
 6.00048341e-02, 6.50048107e-02, 7.00047836e-02, 7.50047565e-02,
 8.00047293e-02, 8.50047097e-02, 9.00046825e-02, 9.50046554e-02,
 1.00004628e-01, 1.05004601e-01, 1.10004582e-01, 1.15004554e-01,
 1.20004527e-01, 1.25004500e-01, 1.30004480e-01, 1.35004446e-01,
 1.40004426e-01, 1.45004392e-01, 1.50004372e-01, 1.55004352e-01,
 1.60004318e-01, 1.65004298e-01, 1.70004264e-01, 1.75004244e-01,
 1.80004224e-01, 1.85004190e-01, 1.90004170e-01, 1.95004135e-01,
 2.00004116e-01, 2.05004096e-01, 2.10004061e-01, 2.15004042e-01,
 2.20004007e-01, 2.25003988e-01, 2.30003968e-01, 2.35003933e-01,
 2.40003914e-01, 2.45003879e-01, 2.50003844e-01, 2.55003840e-01,
 2.60003805e-01, 2.65003771e-01, 2.70003766e-01, 2.75003731e-01,
 2.80003697e-01, 2.85003692e-01, 2.90003657e-01, 2.95003623e-01,
 3.00003588e-01, 3.05003583e-01, 3.10003549e-01, 3.15003514e-01,
 3.20003510e-01, 3.25003475e-01, 3.30003440e-01, 3.35003436e-01,
 3.40003401e-01, 3.45003366e-01, 3.50003332e-01, 3.55003327e-01,
 3.60003293e-01, 3.65003258e-01, 3.70003253e-01, 3.75003219e-01,
 3.80003184e-01, 3.85003150e-01, 3.90003145e-01, 3.95003110e-01,
 4.00003076e-01, 4.05003071e-01, 4.10003036e-01, 4.15003002e-01,
 4.20002997e-01, 4.25002962e-01, 4.30002928e-01, 4.35002893e-01,
 4.40002888e-01, 4.45002854e-01, 4.50002819e-01, 4.55002815e-01,
 4.60002780e-01, 4.65002745e-01, 4.70002741e-01, 4.75002706e-01,
 4.80002671e-01, 4.85002637e-01, 4.90002632e-01, 4.95002598e-01,
 5.00002563e-01, 5.05002558e-01, 5.10002494e-01, 5.15002489e-01,
 5.20002484e-01, 5.25002420e-01, 5.30002415e-01, 5.35002410e-01,
 5.40002346e-01, 5.45002341e-01, 5.50002337e-01, 5.55002272e-01,
 5.60002267e-01, 5.65002263e-01, 5.70002198e-01, 5.75002193e-01,
 5.80002189e-01, 5.85002124e-01, 5.90002120e-01, 5.95002055e-01,
 6.00002050e-01, 6.05002046e-01, 6.10001981e-01, 6.15001976e-01,
 6.20001972e-01, 6.25001907e-01, 6.30001903e-01, 6.35001898e-01,
 6.40001833e-01, 6.45001829e-01, 6.50001824e-01, 6.55001760e-01,
 6.60001755e-01, 6.65001750e-01, 6.70001686e-01, 6.75001681e-01,
 6.80001616e-01, 6.85001612e-01, 6.90001607e-01, 6.95001543e-01,
 7.00001538e-01, 7.05001533e-01, 7.10001469e-01, 7.15001464e-01,
 7.20001459e-01, 7.25001395e-01, 7.30001390e-01, 7.35001385e-01,
 7.40001321e-01, 7.45001316e-01, 7.50001311e-01, 7.55001247e-01,
 7.60001242e-01, 7.65001237e-01, 7.70001173e-01, 7.75001168e-01,
 7.80001104e-01, 7.85001099e-01, 7.90001094e-01, 7.95001030e-01,
 8.00001025e-01, 8.05001020e-01, 8.10000956e-01, 8.15000951e-01,
 8.20000947e-01, 8.25000882e-01, 8.30000877e-01, 8.35000873e-01,
 8.40000808e-01, 8.45000803e-01, 8.50000799e-01, 8.55000734e-01,
 8.60000730e-01, 8.65000665e-01, 8.70000660e-01, 8.75000656e-01,
 8.80000591e-01, 8.85000587e-01, 8.90000582e-01, 8.95000517e-01,
 9.00000513e-01, 9.05000508e-01, 9.10000443e-01, 9.15000439e-01,
 9.20000434e-01, 9.25000370e-01, 9.30000365e-01, 9.35000360e-01,
 9.40000296e-01, 9.45000291e-01, 9.50000286e-01, 9.55000222e-01,
 9.60000217e-01, 9.65000153e-01, 9.70000148e-01, 9.75000143e-01,
 9.80000079e-01, 9.85000074e-01 ,9.90000069e-01 ,1.0};
std::vector<double> spaceProbToulouse={0.0,0.0, 7.57158792e-04, 1.46101111e-03, 2.13510867e-03,
 2.80560755e-03, 3.47325320e-03, 4.14160352e-03, 4.81207540e-03,
 5.47330391e-03, 6.13812998e-03, 6.81217616e-03, 7.49420433e-03,
 8.18413815e-03, 8.87949835e-03, 9.57905632e-03, 1.02931376e-02,
 1.10113786e-02, 1.17318645e-02, 1.24836121e-02, 1.32437862e-02,
 1.40043881e-02, 1.47887929e-02, 1.55796274e-02, 1.63776899e-02,
 1.71977481e-02, 1.80309667e-02, 1.88765175e-02, 1.97260090e-02,
 2.05976698e-02, 2.14908296e-02, 2.24012716e-02, 2.33355025e-02,
 2.42803452e-02, 2.52333546e-02, 2.62148523e-02, 2.72185182e-02,
 2.82245902e-02, 2.92596069e-02, 3.03212544e-02, 3.13925504e-02,
 3.24914395e-02, 3.36058547e-02, 3.47354037e-02, 3.59092451e-02,
 3.71151465e-02, 3.83271419e-02, 3.95672150e-02, 4.08463676e-02,
 4.21544024e-02, 4.34960451e-02, 4.48626355e-02, 4.62598509e-02,
 4.76916654e-02, 4.91623760e-02, 5.06623813e-02, 5.21789053e-02,
 5.37246387e-02, 5.53234866e-02, 5.69755504e-02, 5.86563666e-02,
 6.03687749e-02, 6.21327242e-02, 6.39424209e-02, 6.57955336e-02,
 6.76954565e-02, 6.96501481e-02, 7.16888032e-02, 7.37654339e-02,
 7.58689838e-02, 7.80511302e-02, 8.02959363e-02, 8.25826225e-02,
 8.49334528e-02, 8.73676761e-02, 8.98604551e-02, 9.24013886e-02,
 9.50284551e-02, 9.77528778e-02, 1.00533279e-01, 1.03398782e-01,
 1.06375984e-01, 1.09432643e-01, 1.12579310e-01, 1.15806537e-01,
 1.19119287e-01, 1.22521666e-01, 1.26042110e-01, 1.29689356e-01,
 1.33445343e-01, 1.37308528e-01, 1.41274497e-01, 1.45361726e-01,
 1.49530726e-01, 1.53789155e-01, 1.58160305e-01, 1.62610926e-01,
 1.67102097e-01, 1.71614426e-01, 1.76202219e-01, 1.80810017e-01,
 1.85325089e-01, 1.89790514e-01, 1.94193612e-01, 1.98487779e-01,
 2.02705011e-01, 2.06844734e-01, 2.10856872e-01, 2.14769942e-01,
 2.18625024e-01, 2.22389245e-01, 2.26067980e-01, 2.29684641e-01,
 2.33237934e-01, 2.36705308e-01, 2.40097674e-01, 2.43433128e-01,
 2.46715401e-01, 2.49956145e-01, 2.53145383e-01, 2.56290024e-01,
 2.59378589e-01, 2.62421236e-01, 2.65444073e-01, 2.68418229e-01,
 2.71359880e-01, 2.74277795e-01, 2.77171418e-01, 2.80061769e-01,
 2.82950829e-01, 2.85799188e-01, 2.88608809e-01, 2.91412595e-01,
 2.94208670e-01, 2.97012129e-01, 2.99808010e-01, 3.02589849e-01,
 3.05405991e-01, 3.08199200e-01, 3.10963112e-01, 3.13724969e-01,
 3.16487964e-01, 3.19244389e-01, 3.22005124e-01, 3.24776714e-01,
 3.27544467e-01, 3.30326331e-01, 3.33119966e-01, 3.35903688e-01,
 3.38694618e-01, 3.41513286e-01, 3.44365398e-01, 3.47228408e-01,
 3.50100763e-01, 3.52998825e-01, 3.55952795e-01, 3.58914234e-01,
 3.61901789e-01, 3.64917831e-01, 3.67967817e-01, 3.71073590e-01,
 3.74208795e-01, 3.77377571e-01, 3.80591933e-01, 3.83839633e-01,
 3.87123935e-01, 3.90483872e-01, 3.93914102e-01, 3.97411219e-01,
 4.00988826e-01, 4.04641165e-01, 4.08378006e-01, 4.12214152e-01,
 4.16130071e-01, 4.20158389e-01, 4.24309050e-01, 4.28604301e-01,
 4.33046922e-01, 4.37645859e-01, 4.42416293e-01, 4.47394306e-01,
 4.52558787e-01, 4.57947648e-01, 4.63650384e-01, 4.69671896e-01,
 4.76036645e-01, 4.82807105e-01, 4.90063152e-01, 4.97899568e-01,
 5.06387304e-01, 5.15656106e-01, 5.25923949e-01, 5.37497175e-01,
 5.50713197e-01, 5.66137838e-01, 5.84707235e-01, 6.08114183e-01,
 6.39840902e-01, 6.90121942e-01, 1.0};

 
 std::vector<double> spaceCorrToulouse512={0.0 , 5.00155101e-03, 1.00015430e-02, 1.50015354e-02,
 2.00015269e-02, 2.50015203e-02, 3.00015118e-02, 3.50015052e-02,
 4.00014967e-02, 4.50014882e-02, 5.00014797e-02, 5.50014749e-02,
 6.00014664e-02, 6.50014579e-02, 7.00014532e-02, 7.50014409e-02,
 8.00014362e-02, 8.50014240e-02, 9.00014192e-02, 9.50014144e-02,
 1.00001402e-01, 1.05001397e-01, 1.10001385e-01, 1.15001380e-01,
 1.20001368e-01, 1.25001371e-01, 1.30001351e-01, 1.35001346e-01,
 1.40001342e-01, 1.45001337e-01, 1.50001332e-01, 1.55001312e-01,
 1.60001308e-01, 1.65001303e-01, 1.70001298e-01, 1.75001293e-01,
 1.80001274e-01, 1.85001269e-01, 1.90001264e-01, 1.95001259e-01,
 2.00001240e-01, 2.05001235e-01, 2.10001230e-01, 2.15001225e-01,
 2.20001221e-01, 2.25001201e-01, 2.30001196e-01, 2.35001191e-01,
 2.40001187e-01, 2.45001182e-01, 2.50001162e-01, 2.55001158e-01,
 2.60001153e-01, 2.65001148e-01, 2.70001143e-01, 2.75001138e-01,
 2.80001134e-01, 2.85001129e-01, 2.90001094e-01, 2.95001090e-01,
 3.00001085e-01, 3.05001080e-01, 3.10001075e-01, 3.15001070e-01,
 3.20001066e-01, 3.25001061e-01, 3.30001056e-01, 3.35001051e-01,
 3.40001017e-01, 3.45001012e-01, 3.50001007e-01, 3.55001003e-01,
 3.60000998e-01, 3.65000993e-01, 3.70000988e-01, 3.75000983e-01,
 3.80000979e-01, 3.85000944e-01, 3.90000939e-01, 3.95000935e-01,
 4.00000930e-01, 4.05000925e-01, 4.10000920e-01, 4.15000916e-01,
 4.20000911e-01, 4.25000906e-01, 4.30000901e-01, 4.35000867e-01,
 4.40000862e-01, 4.45000857e-01, 4.50000852e-01, 4.55000848e-01,
 4.60000843e-01, 4.65000838e-01, 4.70000833e-01, 4.75000829e-01,
 4.80000824e-01, 4.85000789e-01, 4.90000784e-01, 4.95000780e-01,
 5.00000775e-01, 5.05000770e-01, 5.10000765e-01, 5.15000761e-01,
 5.20000756e-01, 5.25000751e-01, 5.30000746e-01, 5.35000741e-01,
 5.40000737e-01, 5.45000732e-01, 5.50000727e-01, 5.55000722e-01,
 5.60000658e-01, 5.65000653e-01, 5.70000648e-01, 5.75000644e-01,
 5.80000639e-01, 5.85000634e-01, 5.90000629e-01, 5.95000625e-01,
 6.00000620e-01, 6.05000615e-01, 6.10000610e-01, 6.15000606e-01,
 6.20000601e-01, 6.25000596e-01, 6.30000591e-01, 6.35000587e-01,
 6.40000582e-01, 6.45000577e-01, 6.50000572e-01, 6.55000567e-01,
 6.60000503e-01, 6.65000498e-01, 6.70000494e-01, 6.75000489e-01,
 6.80000484e-01, 6.85000479e-01, 6.90000474e-01, 6.95000470e-01,
 7.00000465e-01, 7.05000460e-01, 7.10000455e-01, 7.15000451e-01,
 7.20000446e-01, 7.25000441e-01, 7.30000436e-01, 7.35000432e-01,
 7.40000427e-01, 7.45000422e-01, 7.50000417e-01, 7.55000353e-01,
 7.60000348e-01, 7.65000343e-01, 7.70000339e-01, 7.75000334e-01,
 7.80000329e-01, 7.85000324e-01, 7.90000319e-01, 7.95000315e-01,
 8.00000310e-01, 8.05000305e-01, 8.10000300e-01, 8.15000296e-01,
 8.20000291e-01, 8.25000286e-01, 8.30000281e-01, 8.35000277e-01,
 8.40000272e-01, 8.45000267e-01, 8.50000262e-01, 8.55000198e-01,
 8.60000193e-01, 8.65000188e-01, 8.70000184e-01, 8.75000179e-01,
 8.80000174e-01, 8.85000169e-01, 8.90000165e-01, 8.95000160e-01,
 9.00000155e-01, 9.05000150e-01, 9.10000145e-01, 9.15000141e-01,
 9.20000136e-01, 9.25000131e-01, 9.30000126e-01, 9.35000122e-01,
 9.40000117e-01, 9.45000112e-01, 9.50000107e-01, 9.55000043e-01,
 9.60000038e-01, 9.65000033e-01, 9.70000029e-01, 9.75000024e-01,
 9.80000019e-01, 9.85000014e-01, 9.90000010e-01, 1.0};


std::vector<double> spaceProbToulouse512={0.0,0.0, 8.76210339e-04, 1.66340498e-03, 2.39380481e-03,
 3.09822642e-03, 3.79300846e-03, 4.47077098e-03, 5.14214964e-03,
 5.81281311e-03, 6.48102415e-03, 7.15519893e-03, 7.82668312e-03,
 8.49324431e-03, 9.16392246e-03, 9.83745342e-03, 1.05157680e-02,
 1.11920842e-02, 1.18772158e-02, 1.25832332e-02, 1.32859113e-02,
 1.39990466e-02, 1.47275573e-02, 1.54662452e-02, 1.62159942e-02,
 1.69649180e-02, 1.77254839e-02, 1.85043768e-02, 1.93028109e-02,
 2.01155443e-02, 2.09419727e-02, 2.17861175e-02, 2.26335030e-02,
 2.34845605e-02, 2.43570363e-02, 2.52540530e-02, 2.61575832e-02,
 2.70661397e-02, 2.79962897e-02, 2.89547469e-02, 2.99422488e-02,
 3.09546343e-02, 3.19878461e-02, 3.30307877e-02, 3.40887275e-02,
 3.51808114e-02, 3.63052649e-02, 3.74475576e-02, 3.86037916e-02,
 3.97958942e-02, 4.10113623e-02, 4.22501922e-02, 4.35297459e-02,
 4.48339532e-02, 4.61794617e-02, 4.75626582e-02, 4.89701968e-02,
 5.04126742e-02, 5.18939620e-02, 5.34150527e-02, 5.49841901e-02,
 5.65923795e-02, 5.82353669e-02, 5.99228282e-02, 6.16535216e-02,
 6.34332755e-02, 6.52736958e-02, 6.71711519e-02, 6.91105086e-02,
 7.11076205e-02, 7.31672540e-02, 7.52986184e-02, 7.75112752e-02,
 7.97767939e-02, 8.20895122e-02, 8.44648259e-02, 8.69231236e-02,
 8.94472760e-02, 9.20293372e-02, 9.47192930e-02, 9.75018434e-02,
 1.00386776e-01, 1.03361795e-01, 1.06417651e-01, 1.09599180e-01,
 1.12891761e-01, 1.16291714e-01, 1.19793929e-01, 1.23380619e-01,
 1.27086416e-01, 1.30912106e-01, 1.34835942e-01, 1.38879946e-01,
 1.43015198e-01, 1.47256878e-01, 1.51583200e-01, 1.55974097e-01,
 1.60469291e-01, 1.65007361e-01, 1.69552391e-01, 1.74142202e-01,
 1.78706104e-01, 1.83187877e-01, 1.87604158e-01, 1.91964572e-01,
 1.96241176e-01, 2.00428037e-01, 2.04540007e-01, 2.08559144e-01,
 2.12493468e-01, 2.16354486e-01, 2.20144992e-01, 2.23850602e-01,
 2.27467934e-01, 2.31013049e-01, 2.34494308e-01, 2.37923065e-01,
 2.41305095e-01, 2.44628370e-01, 2.47908358e-01, 2.51126218e-01,
 2.54277308e-01, 2.57395803e-01, 2.60480613e-01, 2.63527709e-01,
 2.66524926e-01, 2.69480747e-01, 2.72415739e-01, 2.75329846e-01,
 2.78206895e-01, 2.81056040e-01, 2.83898318e-01, 2.86722644e-01,
 2.89508620e-01, 2.92276294e-01, 2.95044578e-01, 2.97808941e-01,
 3.00593675e-01, 3.03364240e-01, 3.06096605e-01, 3.08827548e-01,
 3.11560619e-01, 3.14269377e-01, 3.17004741e-01, 3.19743127e-01,
 3.22475938e-01, 3.25222623e-01, 3.27989510e-01, 3.30771406e-01,
 3.33539264e-01, 3.36328707e-01, 3.39137820e-01, 3.41954202e-01,
 3.44784025e-01, 3.47640987e-01, 3.50521186e-01, 3.53419918e-01,
 3.56343544e-01, 3.59311937e-01, 3.62304847e-01, 3.65330809e-01,
 3.68388529e-01, 3.71503776e-01, 3.74659381e-01, 3.77840017e-01,
 3.81101576e-01, 3.84429194e-01, 3.87813556e-01, 3.91269693e-01,
 3.94773654e-01, 3.98359538e-01, 4.02041248e-01, 4.05805490e-01,
 4.09651958e-01, 4.13605437e-01, 4.17684586e-01, 4.21920952e-01,
 4.26323184e-01, 4.30870752e-01, 4.35616492e-01, 4.40561691e-01,
 4.45697247e-01, 4.51076553e-01, 4.56763453e-01, 4.62770240e-01,
 4.69138133e-01, 4.75908584e-01, 4.83120156e-01, 4.90885311e-01,
 4.99324980e-01, 5.08633969e-01, 5.18945467e-01, 5.30478480e-01,
 5.43643480e-01, 5.59009955e-01, 5.77512170e-01, 6.00838946e-01,
 6.32502725e-01, 6.82781487e-01, 1.0};

void InterpolatePos(std::vector<double> aX,std::vector<double> aF, double& value)
{
    // Value to Index 
    auto i = std::lower_bound(aX.begin(), aX.end(), value); // sorted in increasing order from 0 to 1
    int k = i - aX.begin();
    //std::cout<<"KKK "<<k<<std::endl;
    int l = k ? k - 1 : 1 ;
    if(aF[k]<aF[l]) 
    {
        value = aF[k]+(value-aX[k])*(aF[l]-aF[k])/(aX[l]-aX[k]);
        //std::cout<<"values "<<value<<std::endl;
    }
    else 
    {
       value = aF[l]+(value-aX[l])*(aF[k]-aF[l])/(aX[k]-aX[l]);
        //std::cout<<"value before  "<<aF[l]<<"  values "<<value<<"  value after "<<aF[k]<<std::endl;
    }
}
 
void Tensor2Tiff(torch::Tensor aTens, std::string anImageName)
{
    Im2D<REAL4,REAL8> anIm=Im2D<REAL4,REAL8> (aTens.size(-1),aTens.size(-2));
    REAL4 ** anImD=anIm.data();
    std::memcpy((*anImD),aTens.data_ptr<REAL4>(),sizeof(REAL4)*aTens.numel());
    ELISE_COPY
    (
     anIm.all_pts(),
     anIm.in() ,
     Tiff_Im(
        anImageName.c_str(),
        anIm.sz(),
        GenIm::real4,
        Tiff_Im::No_Compr,
        Tiff_Im::BlackIsZero,
        Tiff_Im::Empty_ARG ).out()
      );
}
/*
namespace {
	void display_weights(torch::nn::Module & module)
	{
		torch::NoGradGuard no_grad;
        
        
        std::cout<<"MODULE NAME "<<module.name()<<std::endl;
        std::cout<<"MODULE PARAMETERS SIZE "<<module.parameters().size()<<std::endl;

        if (auto conv = module.as<torch::nn::Conv2d>()) {
            std::cout<<"WGHT MATRIX MIN "<<conv->weight.min()<<std::endl;
            std::cout<<"WGHT MATRIX MAX "<<conv->weight.max()<<std::endl;
            //std::cout<<"BIAS VETCOR "<<conv->bias.sizes()<<std::endl;
			}
        if (auto linear = module.as<torch::nn::Linear>()) {
            std::cout<<"WGHT MATRIX "<<linear->weight<<std::endl;
            std::cout<<"BIAS VETCOR "<<linear->bias.sizes()<<std::endl;
			}
	}
}
*/
namespace MMVII
{
namespace  cNS_MatchMultipleOrtho
{

class cAppliMatchMultipleOrtho;

class cAppliMatchMultipleOrtho : public cMMVII_Appli
{
     public :
        typedef tU_INT1               tElemMasq;
        typedef tREAL4                tElemOrtho;
        typedef tREAL4                tElemSimil;
        typedef cIm2D<tElemMasq>      tImMasq;
        typedef cIm2D<tElemOrtho>     tImOrtho;
        typedef cIm2D<tElemSimil>     tImSimil;
        typedef cDataIm2D<tElemMasq>  tDImMasq;
        typedef cDataIm2D<tElemOrtho> tDImOrtho;
        typedef cDataIm2D<tElemSimil> tDImSimil;
        typedef std::vector<tImOrtho>  tVecOrtho;
        typedef std::vector<tImMasq>   tVecMasq;


        cAppliMatchMultipleOrtho(const std::vector<std::string> & aVArgs,const cSpecMMVII_Appli & aSpec);
     const std::string  & NameArch() const {return mArchitecture;} // ACCESSOR
     const std::string  & NameDirModel() const {return mModelBinDir;} // ACCESSOR
     private :
	std::string NameIm(int aKIm,int aKScale,const std::string & aPost) const
	{
             return mPrefixZ + "_I" +ToStr(aKIm) + "_S" + ToStr(aKScale) + "_"+ aPost  + ".tif";
	}
        std::string NameImOrg(int aKIm,int aKScale,const std::string & aPost) const
        {
             return mPrefixGlob + "_I" +ToStr(aKIm) + "_S" + ToStr(aKScale) + "_"+ aPost  + ".tif";
        }
        std::string NameImOrgEpip12(int aKIm,int aKIm2,int aKScale, const std::string & aPost) const
        {
             return mPrefixGlob + "_I" +ToStr(aKIm) + "_S" + ToStr(aKScale) + "_I" +ToStr(aKIm2) + "_S" + ToStr(aKScale) + "_"+ aPost  + ".tif";
        }
        std::string NameImEpip(int aKIm,int aKIm2,int aKScale, const std::string & aPost) const
        {
             return mPrefixGlob + "_I" +ToStr(aKIm) + "_I" +ToStr(aKIm2) +"_S" + ToStr(aKScale) + "_"+ aPost  + ".tif";
        }
	std::string NameOrtho(int aKIm,int aKScale) const {return NameIm(aKIm,aKScale,"O");}
        std::string NameGeoX (int aKIm,int aKScale) const {return NameIm(aKIm,aKScale,"GEOX");}
        std::string NameGeoY (int aKIm,int aKScale) const {return NameIm(aKIm,aKScale,"GEOY");}
        std::string NameMasq (int aKIm,int aKScale) const {return NameIm(aKIm,aKScale,"M");}
        std::string NameORIG (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG");}

        std::string NameORIGMASTERGEOX (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_GEOX");}
        std::string NameMASTEREPIP (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"Epip");}
        std::string NameSECEPIP (int aKIm,int aKIm2,int aKScale) const {return NameImEpip(aKIm,aKIm2,aKScale,"Epip");}
        std::string NameORIGMASTERGEOY (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_GEOY");}
        std::string NameORIGMASTERMASQ (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_Masq");}
        std::string NameORIGMASTEREpImGEOX (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_EpIm_GEOX");}
        std::string NameORIGMASTEREpImGEOY (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_EpIm_GEOY");}
        std::string NameORIGMASTEREpImMASQ (int aKIm,int aKIm2,int aKScale) const {return NameImOrgEpip12(aKIm,aKIm2,aKScale,"ORIG_EpIm_Masq");}

        std::string NameORIGSECGEOX (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_GEOX");}
        std::string NameORIGSECGEOY (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_GEOY");}
        std::string NameORIGSECMASQ (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_Masq");}

        std::string NameORIGSECEpImGEOX (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_EpIm_GEOX");}
        std::string NameORIGSECEpImGEOY (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_EpIm_GEOY");}
        std::string NameORIGSECEpImMASQ (int aKIm,int aKScale) const {return NameImOrg(aKIm,aKScale,"ORIG_EpIm_Masq");}


        int Exe() override;
        int ExeProjectOrigEmbeddings();
        int ExeSubPixFeats();
        int GotoEpipolar();
        int GotoHomography();
        cCollecSpecArg2007 & ArgObl(cCollecSpecArg2007 & anArgObl) override ;
        cCollecSpecArg2007 & ArgOpt(cCollecSpecArg2007 & anArgOpt) override ;

        //  One option, to replace by whatever you want
    void ComputeSimilByCorrelMaster();
    void ComputeSimilByLearnedCorrelMaster(std::vector<torch::Tensor> * AllEmbeddings);
    void ComputeSimilByLearnedCorrelMasterEnhanced(std::vector<torch::Tensor> * AllOrthosEmbeddings);
    void ComputeSimilByLearnedCorrelMasterEnhancedMVS(std::vector<torch::Tensor> * AllOrthosEmbeddings);
    void ComputeSimilByLearnedCorrelMasterDecision();
    void ComputeSimilByLearnedCorrelMasterMaxMoy(std::vector<torch::Tensor> * AllOrthosEmbeddings);
    void ComputeSimilByLearnedCorrelMasterMaxMoyMulScale(std::vector<torch::Tensor> * AllOrthosEmbeddings);
    void ComputeSimilByLearnedCorrelMasterDempsterShafer(std::vector<torch::Tensor> * AllOrthosEmbeddings);
    tREAL4 ComputeConflictBetween2SEts(tREAL4 aCorrel1, tREAL4 aCorrel2, tREAL4 aPonder1,tREAL4 aPonder2);
    tREAL4 ComputeJointMassBetween2Sets(tREAL4 aCorrel1, tREAL4 aCorrel2, tREAL4 aPonder1,tREAL4 aPonder2);
    void CorrelMaster(const cPt2di &,int aKIm,bool & AllOk,float &aWeight,float & aCorrel);
    void MakeNormalizedIms();
    void InitializePredictor ();
    torch::Tensor ToTensorGeo(tImOrtho & aGeoX,tImOrtho & aGeoY, cPt2di aDIM);
    torch::Tensor ToTensorGeo(tImOrtho & aGeoX,tImOrtho & aGeoY);
    torch::Tensor ResampleFeatureMap(torch::Tensor & aFeatMap, tImOrtho aGeoX, tImOrtho aGeoY);
    torch::Tensor Gather2D(torch::Tensor & aFeatMap, torch::Tensor anX, torch::Tensor anY);
    torch::Tensor InterpolateFeatMap(torch::Tensor & aFeatMap, tImOrtho aGeoX, tImOrtho aGeoY);
    torch::Tensor ComputeEpipolarImage(tImOrtho & aNativeGeomImage, tImOrtho & aGeoX, tImOrtho & aGeoY);
    double Interpol_Bilin(torch::Tensor & aMap,const cPt2dr & aLoc);
	// -------------- Mandatory args -------------------
	std::string   mPrefixGlob;   // Prefix to all names
	int           mNbZ;      // Number of independant ortho (=number of Z)
	int           mNbIm;     // Number of images
	int           mNbScale;  // Number of scale in image
	cPt2di        mSzW;      // Sizeof of windows
	bool          mIm1Mast;  //  Is first image the master image ?
	
	// -------------- Internal variables -------------------
	tImSimil                   mImSimil;   // computed image of similarity
	std::string                mPrefixZ;   // Prefix for a gizen Z
	cPt2di                     mSzIms;     // common  size of all ortho
	
	// ADDED LEARNING ENV
    aCnnModelPredictor *  mCNNPredictor=nullptr;
    bool                  mWithIntCorr=true;  // initialized in the begining 
    bool                  mWithExtCorr=false;  // initialized in the begining 
    bool                  mWithDecisionNet=true;
    bool                  mWithMatcher3D=false;
    std::string           mArchitecture;
    std::string           mResol;
    bool                  mUseCuda=false;
    std::string           mModelBinDir;
    cPt2di                mCNNWin;
    
    // Networks architectures 
    ConvNet_Fast mNetFastStd= ConvNet_Fast(3,4);  // Conv Kernel= 3x3 , Convlayers=4
    ConvNet_FastBn  mNetFastMVCNN=ConvNet_FastBn(3,7);// Conv Kernel= 3x3 , Convlayers=7
    ConvNet_FastBnRegister mNetFastMVCNNReg=ConvNet_FastBnRegister(3,5,1,112,torch::kCPU);// changed from 64 to 112
    Fast_ProjectionHead mNetFastPrjHead=Fast_ProjectionHead(3,5,1,1,112,112,64,torch::kCPU);
    //MSNet_Attention mMSNet=MSNet_Attention(32);
    //MSNetHead mMSNet=MSNetHead(32);
    // SCRIPTED NETWORKS
    torch::jit::script::Module mMSAFF;
    torch::jit::script::Module mDecisionMLP;
    MSNet_Attention mMSNet=MSNet_Attention(32);
    FastandHead mNetFastMVCNNMLP=FastandHead(3,5,4,1,184,184,9,64,torch::kCPU);
    SimilarityNet mNetFastMVCNNDirectSIM=SimilarityNet(3,5,4,1,184,184,64,torch::kCPU);
    //FastandHead mNetFastMVCNNMLP; // Fast MVCNN + MLP for Multiview Features Aggregation
    // LATER SLOW NET 
    ConvNet_Slow mNetSlowStd=ConvNet_Slow(3,4,4); // Conv Kernel= 3x3 , Convlayers=4, Fully Connected Layers =4

	std::vector<tVecOrtho>      mVOrtho;    // vector of loaded ortho at a given Z
	std::vector<tVecMasq>       mVMasq;     // vector of loaded masq  at a given Z
        std::vector<tVecOrtho>      mVGEOX;     // Real offsets in X direction
        std::vector<tVecOrtho>      mVGEOY;     // Real offsets in Y direction
        std::vector<tVecOrtho>      mORIGIm;    // Original Oriented images used to generate ORTHOS
};

// ARCHITECTURES OF CNN TRAINED 
static const std::string TheFastArch = "MVCNNFast";
static const std::string TheFastArchReg = "MVCNNFastReg";
static const std::string TheFastandPrjHead = "MVCNNFastProjHead";
static const std::string TheFastStandard = "MCNNStd";
static const std::string TheFastArchWithMLP= "MVCNNFastMLP";
static const std::string TheFastArchDirectSim="MVCNNFastDirectSIM";
//static const std::string TheMSNet="MSNetHead";
static const std::string TheMSNet="MSNet_Attention";
static const std::string TheUnetMlpCubeMatcher="UnetMLPMatcher";
/* *************************************************** */
/*                                                     */
/*              cAppliMatchMultipleOrtho               */
/*                                                     */
/* *************************************************** */

cAppliMatchMultipleOrtho::cAppliMatchMultipleOrtho(const std::vector<std::string> & aVArgs,const cSpecMMVII_Appli & aSpec) :
   cMMVII_Appli  (aVArgs,aSpec),
   mImSimil      (cPt2di(1,1)),
   mCNNWin          (0,0)
   
{

}


cCollecSpecArg2007 & cAppliMatchMultipleOrtho::ArgObl(cCollecSpecArg2007 & anArgObl) 
{
 return
      anArgObl
          <<   Arg2007(mPrefixGlob,"Prefix of all names")
          <<   Arg2007(mNbZ,"Number of Z/Layers")
          <<   Arg2007(mNbIm,"Number of images in one layer")
          <<   Arg2007(mNbScale,"Number of scaled in on images")
          <<   Arg2007(mSzW,"Size of window")
          <<   Arg2007(mIm1Mast,"Is first image a master image ?")
   ;
}

cCollecSpecArg2007 & cAppliMatchMultipleOrtho::ArgOpt(cCollecSpecArg2007 & anArgOpt)
{
   return anArgOpt
          // << AOpt2007(mStepZ, "StepZ","Step for paralax",{eTA2007::HDV})
          << AOpt2007(mModelBinDir,"CNNParams" ,"Model Directory : Contient des fichiers binaires *.bin")
          << AOpt2007(mArchitecture,"CNNArch" ,"Model architecture : "+TheFastArch+" || "+TheFastStandard+" || "+TheFastArchWithMLP)
          << AOpt2007(mResol,"RESOL" ,"RESOL OPTION FOR THE MULTISCALE TRAINING: ")
          << AOpt2007(mUseCuda,"UseCuda","USE CUDA TO LAUNCH MODELS")
   ;
}


void cAppliMatchMultipleOrtho::InitializePredictor ()
{
    StdOut()<<"MODEL ARCHITECTURE:: "<<mArchitecture<<"\n";
    bool IsArchWellDefined=false;
    IsArchWellDefined = (mArchitecture==TheFastArch) ||  (mArchitecture==TheFastArchReg) ||  (mArchitecture==TheFastStandard) || (mArchitecture==TheFastArchWithMLP)
            || (mArchitecture==TheFastArchDirectSim) || (mArchitecture==TheFastandPrjHead)|| (mArchitecture==TheMSNet)
            || (mArchitecture==TheUnetMlpCubeMatcher);
    MMVII_INTERNAL_ASSERT_strong(IsArchWellDefined,"The network architecture should be specified : "+TheFastArch+" || "+TheFastStandard 
        +" || "+TheFastArchWithMLP+" || "+TheFastArchDirectSim+ " || "+TheUnetMlpCubeMatcher+ " !");
    MMVII_INTERNAL_ASSERT_strong(this->mModelBinDir!=""," Model params dir must be specified ! ");
    
    mWithExtCorr = (mArchitecture!="");
    
    if (mWithExtCorr)
    {
        // ARCHITECTURE and Location of Model Binaries 
        if(mArchitecture==TheFastArch)
        {
            mCNNPredictor = new aCnnModelPredictor(TheFastArch,mModelBinDir,mUseCuda);
            // CREATE AN INSTANCE OF THE NETWORK 
            torch::Device device(torch::kCPU);
            mNetFastMVCNN->createModel(184,7,1,3,device); // becareful to change these values with respect to network architecture
				
				
            // Populate layers by learned weights and biases 
            mCNNPredictor->PopulateModelFromBinaryWithBN(mNetFastMVCNN);
            
            mCNNWin=mCNNPredictor->GetWindowSizeBN(mNetFastMVCNN);
				
            //Add padding to maintain the same size as output 
            auto Fast=mNetFastMVCNN->getFastSequential(); 
            
            // ACTIVATE PADDING (NOW DEACTIVATED)
            
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                {   //torch::nn::Conv2dImpl *mod=Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>();
                        //std::cout<<"condition verified on name of convolution "<<std::endl;
                    Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                }
            }
        }
        if(mArchitecture==TheFastArchReg)
        {
            mCNNPredictor = new aCnnModelPredictor(TheFastArchReg,mModelBinDir,mUseCuda);
            mCNNPredictor->PopulateModelFromBinaryWithBNReg(mNetFastMVCNNReg);
            
            //mCNNWin=mCNNPredictor->GetWindowSizeBNReg(mNetFastMVCNNReg);  just changed to test
			mCNNWin=cPt2di(7,7);	
            //Add padding to maintain the same size as output 
            auto Fast=mNetFastMVCNNReg->mFast; 
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                {  
                    Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                }
            }
        }
        if(mArchitecture==TheFastandPrjHead)
        {
            mCNNPredictor = new aCnnModelPredictor(TheFastandPrjHead,mModelBinDir,mUseCuda);
            mCNNPredictor->PopulateModelPrjHead(mNetFastPrjHead);
            
            mCNNWin=mCNNPredictor->GetWindowSizePrjHead(mNetFastPrjHead);
				
            //Add padding to maintain the same size as output 
            auto Fast=mNetFastPrjHead->mFast; 
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                {  
                    Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                }
            }
        }
        if(mArchitecture==TheMSNet)
        { 
            mCNNPredictor = new aCnnModelPredictor(TheMSNet,mModelBinDir,mUseCuda);
            //mCNNPredictor->PopulateModelMSNetHead(mMSNet);<<<<<<<here>>>>>>>>
            mCNNPredictor->PopulateModelMSNetAtt(mMSNet);

    
            mCNNWin=cPt2di(7,7); // The chosen window size is 7x7
        }
        if(mArchitecture==TheFastArchWithMLP)
        {
            mCNNPredictor = new aCnnModelPredictor(TheFastArchWithMLP,mModelBinDir,mUseCuda);
            // CREATE AN INSTANCE OF THE NETWORK 
            //auto cuda_available = torch::cuda::is_available();
            //torch::Device device(cuda_available ? torch::kCUDA : torch::kCPU);
            //mNetFastMVCNNMLP=FastandHead(3,7,4,1,184,184,3,64,device); // not to change for the moment 
            //mNetFastMVCNNMLP->to(devicecuda);
            // Populate layers by learned weights and biases 
            mCNNPredictor->PopulateModelFastandHead(mNetFastMVCNNMLP);
            StdOut()<<"MODEL LOADED-------> "<<"\n";
            //mNetFastMVCNNMLP->to(torch::kCPU);
            mCNNWin=mCNNPredictor->GetWindowSizeFastandHead(mNetFastMVCNNMLP);
				
            //Add padding to maintain the same size as output 
            auto Fast=mNetFastMVCNNMLP->mFast; 
            
            // ACTIVATE PADDING (NOW DEACTIVATED)
            
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                {   //torch::nn::Conv2dImpl *mod=Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>();
                        //std::cout<<"condition verified on name of convolution "<<std::endl;
                    Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                }
            }
        }
        if(mArchitecture==TheFastArchDirectSim)
        {
            mCNNPredictor = new aCnnModelPredictor(TheFastArchDirectSim,mModelBinDir,mUseCuda);
            StdOut()<<"LOADING NETWORKKKK   ------> "<<"\n";
            mCNNPredictor->PopulateModelSimNet(mNetFastMVCNNDirectSIM);
            StdOut()<<"MODEL LOADED-SIMILARITY NETWORK    ------> "<<"\n";
            //mNetFastMVCNNMLP->to(torch::kCPU);
            mCNNWin=mCNNPredictor->GetWindowSizeSimNet(mNetFastMVCNNDirectSIM);
				
            //Add padding to maintain the same size as output 
            auto Fast=mNetFastMVCNNDirectSIM->mFast; 
            
            // ACTIVATE PADDING (NOW DEACTIVATED)
            
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                {   //torch::nn::Conv2dImpl *mod=Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>();
                        //std::cout<<"condition verified on name of convolution "<<std::endl;
                    Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                }
            }
        }
        if (mArchitecture==TheFastStandard)
        {
           mCNNPredictor = new aCnnModelPredictor(TheFastStandard,mModelBinDir,mUseCuda);
           
           // CREATE A CNN MODULE AND LOAD PARAMS 
            mNetFastStd->createModel(64,4,1,3);
            
            // Populate layers by learned weights and biases 
            mCNNPredictor->PopulateModelFromBinary(mNetFastStd);
            mCNNWin=mCNNPredictor->GetWindowSize(mNetFastStd);
            //Add padding to maintain the same size as input
            auto Fast=mNetFastStd->getFastSequential(); 
            
            size_t Sz=Fast->size();
            size_t cc=0;
            for (cc=0;cc<Sz;cc++)
            {
                std::string LayerName=Fast->named_children()[cc].key();
                if (LayerName.rfind(std::string("conv"),0)==0)
                    
                    {   //torch::nn::Conv2dImpl *mod=Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>();
                        //std::cout<<"condition verified on name of convolution "<<std::endl;
                        Fast->named_children()[cc].value().get()->as<torch::nn::Conv2dImpl>()->options.padding()=1;
                    }
	         }   // DO NOT APPLY PADDING TO GET A VECTOR EMBDEDDING OF THE PATCH 
	         // PADDING IS USED WHENEVER THE WHOLE TILE IS CONCERNED 
        }
        if(mArchitecture==TheUnetMlpCubeMatcher)
        {
            mCNNPredictor = new aCnnModelPredictor(TheUnetMlpCubeMatcher,mModelBinDir,mUseCuda);
            mCNNPredictor->PopulateModelFeatures(mMSAFF,mUseCuda);
            mCNNWin=cPt2di(1,1);
            if (mWithDecisionNet)
            {
              mCNNPredictor->PopulateModelDecision(mDecisionMLP,mUseCuda);
            }
            if (mWithMatcher3D)
            {
                // Enhance the  generated correlation coefficients using the last stage conv3d MATCHER
                //mCNNPredictor->PopulateModelMatcher(mMatcherNet);
            }
        }
    }   
}

void cAppliMatchMultipleOrtho::CorrelMaster
     (
         const cPt2di & aCenter,   // Central Pixel
	 int aKIm,                  // Num of Image
	 bool & AllOk,              // Is all Window in masq ?
	 float &aWeight,            //  Weight of inside pixel
	 float & aCorrel            // Correl
     )
{
    AllOk = true;
    aWeight = 0;

    cMatIner2Var<tElemOrtho> aMatI;
    for (int aKScale = 0 ; aKScale < mNbScale ; aKScale++)
    {
         const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(aKScale).DIm();
         const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(aKScale).DIm();
         const tDImOrtho & aDIO1 =  mVOrtho.at(0   ).at(aKScale).DIm();
         const tDImOrtho & aDIO2 =  mVOrtho.at(aKIm).at(aKScale).DIm();

	 double aPds = 1/(1+aKScale); // weight, more less arbitrary
         for (const auto & aLocNeigh : cRect2::BoxWindow(cPt2di(0,0),mSzW))  // Parse the window`
         {
              cPt2di  aNeigh = aCenter + aLocNeigh * (1<<aKScale);
              bool Ok = aDIM1.DefGetV(aNeigh,0) && aDIM2.DefGetV(aNeigh,0) ;  // Are both pixel valide
	      if (Ok)
	      {
                  aWeight++;
	          aMatI.Add(aPds,aDIO1.GetV(aNeigh),aDIO2.GetV(aNeigh));
	      }
	      else
	      {
                  AllOk=false;
	      }
         }
    }
    aCorrel =  aMatI.Correl(1e-15);
}

void cAppliMatchMultipleOrtho::ComputeSimilByCorrelMaster()
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
   for (const auto & aP : aDImSim)
   {
        // method : average of image all ok if any, else weighted average of partial corr
        float aSumCorAllOk = 0.0; // Sum of correl of image where point are all ok
        float aSumWeightAllOk = 0.0; //   Nb of All Ok
        float aSumCorPart  = 0.0; //  Sum of weighted partial correl
        float aSumWeightPart = 0.0; //  Sum of weight
	// Parse secondary images 
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
        bool AllOk;
	    float aWeight,aCorrel;
        CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
	    if (AllOk)
	    {
               aSumCorAllOk     += aCorrel;
	       aSumWeightAllOk  += 1;
	    }
	    else
	    {
               aSumCorPart     += aCorrel * aWeight;
	       aSumWeightPart  +=   aWeight;
	    }
	}
	float aAvgCorr =  (aSumWeightAllOk !=0)            ? 
                          (aSumCorAllOk / aSumWeightAllOk) :
                          (aSumCorPart / std::max(1e-5f,aSumWeightPart)) ;

	aDImSim.SetV(aP,1-aAvgCorr);
   }
}


void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMaster(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
	const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    auto MasterEmbedding=AllOrthosEmbeddings->at(0);
    int FeatSize=MasterEmbedding.size(0);
    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
        // method : average of image all ok if any, else weighted average of partial corr
        float aSumCorAllOk = 0.0; // Sum of correl of image where point are all ok
        float aSumWeightAllOk = 0.0; //   Nb of All Ok
        float aSumCorPart  = 0.0; //  Sum of weighted partial correl
        float aSumWeightPart = 0.0; //  Sum of weight
	// Parse secondary images 
	using namespace torch::indexing;
    auto aVecRef=MasterEmbedding.slice(0,0,FeatSize,1).slice(1,aP.y(),aP.y()+1,1).slice(2,aP.x(),aP.x()+1,1);
    //std::cout<<" reference vector "<<aVecRef<<std::endl;
    //int smpl=1;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
        bool AllOk;
	    float aWeight,aCorrel;
        //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
        // Compute cosine simialrity with respect to master ortho embeddings 
        
        /**************************************************************************************/
        AllOk = true;
        aWeight = 0;
        const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(  0).DIm();
        for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
        {
            bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
            if (Ok)
            {
                aWeight++;
            }
            else
            {
                AllOk=false;
            }
        }
        // Compute correl separately 
        //using namespace torch::indexing;
        auto aVecOther=AllOrthosEmbeddings->at(aKIm).slice(0,0,FeatSize,1).slice(1,aP.y(),aP.y()+1,1).slice(2,aP.x(),aP.x()+1,1);
        auto aSim=torch::mm(aVecRef.view({1,FeatSize}),aVecOther.view({FeatSize,1}));
        //std::cout<<" slave vector "<<aVecOther<<std::endl;
        aCorrel=(float)aSim.item<float>();
        //std::cout<<"correl val "<<aCorrel<<std::endl;
        /*if (smpl){
            std::cout<<"correl val "<<aCorrel<<std::endl;
            smpl--;
        }*/
        //std::cout<<" CORREL "<<aCorrel<<std::endl;
        /**************************************************************************************/  
	    if (AllOk)
	    {
           aSumCorAllOk     += aCorrel;
	       aSumWeightAllOk  += 1;
	    }
	    else
	    {
           aSumCorPart     += aCorrel * aWeight;
	       aSumWeightPart  +=   aWeight;
	    }
	}
	float aAvgCorr =  (aSumWeightAllOk !=0)            ? 
                          (aSumCorAllOk / aSumWeightAllOk) :
                          (aSumCorPart / std::max(1e-5f,aSumWeightPart)) ;

	aDImSim.SetV(aP,1-aAvgCorr);
   }
}

void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterEnhanced(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
	const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning 
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;;
    for (int k=1; k<mNbIm; k++)
    {
        // compute element wise cross product along feature size dimension
        torch::Tensor aCrossProd;
        if (mWithDecisionNet)
        {
            torch::Tensor MasterSlave=torch::cat({AllOrthosEmbeddings->at(0).unsqueeze(2),AllOrthosEmbeddings->at(k).unsqueeze(2)},0);
            aCrossProd=mCNNPredictor->PredictONCUBE(mDecisionMLP,MasterSlave).squeeze();
        }
        else
        {
            aCrossProd=at::cosine_similarity(AllOrthosEmbeddings->at(0),AllOrthosEmbeddings->at(k),0).squeeze();
            //std::cout<<"ORTHO EMBEDDINGS COSINE COMPUTED "<<std::endl;
        }
        //std::cout<<"    MAXXXX    "<<at::max(aCrossProd)<<"    MINNN "<<at::min(aCrossProd)<<std::endl;
        AllSimilarities->push_back(aCrossProd.to(torch::kCPU));
        // Here display similarity images of tiles 
    }
    
    // Free all ortho OneOrthoEmbeding 
    delete AllOrthosEmbeddings; 
    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
        // method : average of image all ok if any, else weighted average of partial corr
        float aSumCorAllOk = 0.0; // Sum of correl of image where point are all ok
        float aSumWeightAllOk = 0.0; //   Nb of All Ok
        float aSumCorPart  = 0.0; //  Sum of weighted partial correl
        float aSumWeightPart = 0.0; //  Sum of weight
	 // Parse secondary images 
	 using namespace torch::indexing;;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
            bool AllOk;
	    float aWeight,aCorrel;
            //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
            // Compute cosine simialrity with respect to master ortho embeddings

            /**************************************************************************************/
            AllOk = true;
            aWeight = 0;
            const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(0   ).DIm();
            for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
            {
                bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
                if (Ok)
                {
                    aWeight++;
                }
                else
                {
                    AllOk=false;
                }
            }
            // Compute correl separately
            //using namespace torch::indexing;
            auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
            //std::cout<<" slave vector "<<aSim<<std::endl;
            aCorrel=(float)aSim.item<float>();
            /**************************************************************************************/
	    if (AllOk)
	    {
           aSumCorAllOk     += aCorrel;
	       aSumWeightAllOk  += 1;
	    }
	    else
	    {
           aSumCorPart     += aCorrel * aWeight;
	       aSumWeightPart  +=   aWeight;
	    }
	}
	float aAvgCorr =  (aSumWeightAllOk !=0)            ? 
                          (aSumCorAllOk / aSumWeightAllOk) :
                          (aSumCorPart / std::max(1e-5f,aSumWeightPart)) ;

    aDImSim.SetV(aP,1.0-aAvgCorr);
   }

   // delete All Similarities 
   delete AllSimilarities;
}




void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterEnhancedMVS(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
     const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;

    for (int k=0; k<2*(mNbIm-1);k+=2)
      {
        //compute similarity maps by pair of as if it is in epipolar geometry
        torch::Tensor aCrossProd;
        if (mWithDecisionNet)
        {
            torch::Tensor MasterSlave=torch::cat({AllOrthosEmbeddings->at(k).unsqueeze(2),AllOrthosEmbeddings->at(k+1).unsqueeze(2)},0);
            aCrossProd=mCNNPredictor->PredictONCUBE(mDecisionMLP,MasterSlave).squeeze();
        }
        else
        {
            aCrossProd=at::cosine_similarity(AllOrthosEmbeddings->at(k),AllOrthosEmbeddings->at(k+1),0).squeeze();
        }
        //std::cout<<"    MAXXXX    "<<at::max(aCrossProd)<<"    MINNN "<<at::min(aCrossProd)<<std::endl;
        AllSimilarities->push_back(aCrossProd.to(torch::kCPU));
      }
    // Free all ortho OneOrthoEmbeding
    delete AllOrthosEmbeddings;
    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
        // method : average of image all ok if any, else weighted average of partial corr
        float aSumCorAllOk = 0.0; // Sum of correl of image where point are all ok
        float aSumWeightAllOk = 0.0; //   Nb of All Ok
        float aSumCorPart  = 0.0; //  Sum of weighted partial correl
        float aSumWeightPart = 0.0; //  Sum of weight
         // Parse secondary images
         using namespace torch::indexing;;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
        {
            bool AllOk;
            float aWeight,aCorrel;
            //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
            // Compute cosine simialrity with respect to master ortho embeddings

            /**************************************************************************************/
            AllOk = true;
            aWeight = 0;
            const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(0   ).DIm();
            for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
            {
                bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
                if (Ok)
                {
                    aWeight++;
                }
                else
                {
                    AllOk=false;
                }
            }
            // Compute correl separately
            //using namespace torch::indexing;
            auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
            //std::cout<<" slave vector "<<aSim<<std::endl;
            aCorrel=(float)aSim.item<float>();
            /**************************************************************************************/
            if (AllOk)
            {
           aSumCorAllOk     += aCorrel;
               aSumWeightAllOk  += 1;
            }
            else
            {
           aSumCorPart     += aCorrel * aWeight;
               aSumWeightPart  +=   aWeight;
            }
        }
        float aAvgCorr =  (aSumWeightAllOk !=0)            ?
                          (aSumCorAllOk / aSumWeightAllOk) :
                          (aSumCorPart / std::max(1e-5f,aSumWeightPart)) ;

    aDImSim.SetV(aP,1.0-aAvgCorr);
   }

   // delete All Similarities
   delete AllSimilarities;
}


/////////////////////////////////////////////////////////////////////////////////////////////////

void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterDecision()
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
    const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning 
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;
    auto MasterOrtho=mVOrtho.at(0); //vector<tImOrtho>
    for (unsigned int i=1;i<mVOrtho.size();i++)
    {
        cPt2di aSzOrtho=mVOrtho.at(i).at(0).DIm().Sz();
        auto aCrossProd=mCNNPredictor->PredictUNetWDecision(mMSAFF,MasterOrtho,mVOrtho.at(i),aSzOrtho);
        //std::cout<<"Shape of a single similartity Map  ========> "<<aCrossProd.sizes()<<endl;
        //std::cout<<"BORNES INF ET SUP DE LA CARTE DE SIM =======> "<<at::max(aCrossProd)<<"  "<<at::min(aCrossProd)<<std::endl;
        AllSimilarities->push_back(aCrossProd);     
    }

    for (const auto & aP : aDImSim)
      {
        // method : average of image all ok if any, else weighted average of partial corr
        float aSumCorAllOk = 0.0; // Sum of correl of image where point are all ok
        float aSumWeightAllOk = 0.0; //   Nb of All Ok
        float aSumCorPart  = 0.0; //  Sum of weighted partial correl
        float aSumWeightPart = 0.0; //  Sum of weight
        // Parse secondary images
        using namespace torch::indexing;;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
            bool AllOk;
	    float aWeight,aCorrel;
            //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
            // Compute cosine simialrity with respect to master ortho embeddings
            AllOk = true;
            aWeight = 0;
            const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(0   ).DIm();
            for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
            {
                bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
                if (Ok)
                {
                    aWeight++;
                }
                else
                {
                    AllOk=false;
                }
            }

            // Compute correl separately
            //using namespace torch::indexing;
            auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
            //std::cout<<" slave vector "<<aSim<<std::endl;
            aCorrel=(float)aSim.item<float>();

                if (AllOk)
                {
                    aSumCorAllOk     += aCorrel;
                    aSumWeightAllOk  += 1;
                }
                else
                {
                    aSumCorPart     += aCorrel * aWeight;
                    aSumWeightPart  +=   aWeight;
                }
	}
	double aAvgCorr =  (aSumWeightAllOk !=0)            ? 
                          (aSumCorAllOk / aSumWeightAllOk) :
                          (aSumCorPart / std::max(1e-5f,aSumWeightPart)) ;
    //std::cout<<"avant "<<aAvgCorr<<std::endl;
    // Interpolate correlation values 
    //InterpolatePos(spaceCorrDUBLIN,spaceProbDUBLIN,aAvgCorr);
    //std::cout<<"apres "<<aAvgCorr<<std::endl;
    aDImSim.SetV(aP,1.0-aAvgCorr);
   }
   // delete All Similarities 
   delete AllSimilarities;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterMaxMoy(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
    const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning 
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;;
    for (int k=1; k<mNbIm; k++)
    {
        
        // compute element wise cross product along feature size dimension 
        auto aCrossProd=at::cosine_similarity(AllOrthosEmbeddings->at(0),AllOrthosEmbeddings->at(k),0).squeeze();
        AllSimilarities->push_back(aCrossProd);
    }
    // Free all ortho OneOrthoEmbeding 
    delete AllOrthosEmbeddings; 

    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
	 // Parse secondary images 
        tREAL4 aTab[mNbIm-1];
        tREAL4 aPonder[mNbIm-1];
	 using namespace torch::indexing;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
            bool AllOk;
	    float aWeight,aCorrel;
            //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
            // Compute cosine simialrity with respect to master ortho embeddings

            /**************************************************************************************/
            AllOk = true;
            aWeight = 0;

            const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(0   ).DIm();
            for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
            {
                bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
                if (Ok)
                {
                    aWeight++;
                }
                else
                {
                    AllOk=false;
                }
            }
            // Compute correl separately
            //using namespace torch::indexing;
            auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
            aCorrel=(float)aSim.item<float>();
            /**************************************************************************************/
                if (AllOk)
                {
                aTab[aKIm-1]    = aCorrel;
                aPonder[aKIm-1] = 1.0;
                }
                else
                {
               aTab[aKIm-1]    = aCorrel ;
               aPonder[aKIm-1] = aWeight/(mCNNWin.x()*mCNNWin.y());
                }
	}
	// Moyennes deux  deux des corrlations
        tREAL4 AggCorr=-2.0;
        for (int j=0;j<mNbIm-2;j++)
        {
            for (int i=j+1;i<mNbIm-1;i++)
            {
                tREAL4 aCorr=(aTab[i]*aPonder[i]+ aTab[j]*aPonder[j])/std::max(1e-5f,aPonder[i]+aPonder[j]);
                if (AggCorr<aCorr)
                {
                    AggCorr=aCorr;
                }
            }
        }
        if(AggCorr==-2.0) AggCorr=0.5;   // no max is found
        aDImSim.SetV(aP,1-AggCorr);
   }

   // delete All Similarities 
   delete AllSimilarities;
}

void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterMaxMoyMulScale(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
    
    // Here we jointly fuse Similarity measures from Multi-Scale information 
    // Size of embeddings vector = 4 (scales)*features
    
    // Ortho 1
    // 0 --> Resol 1
    // 1 --> Resol / 2
    // 2 --> Resol / 4
    // 3 --> Resol / 8
    
    // Ortho 2
    // 4 --> Resol 1
    // 5 --> Resol / 2 
    // 6 --> Resol / 4
    // 7 --> Resol / 8
    
    //.....
    
    
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
	const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning 
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;;
    for (int scales=0;scales<4;scales++)
    {
        for (int k=1; k<mNbIm; k++)
        {
            // compute element wise cross product along feature size dimension 
            auto aCrossProd=at::cosine_similarity(AllOrthosEmbeddings->at(scales),AllOrthosEmbeddings->at(4*k+scales),0).squeeze();
            AllSimilarities->push_back(aCrossProd);
        }
    }
    
    // Free all ortho OneOrthoEmbeding 
    delete AllOrthosEmbeddings; 
    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
	 // Parse secondary images 
    tREAL4 aTab[(mNbIm-1)*4];
    tREAL4 aPonder[(mNbIm-1)*4];
    
	 using namespace torch::indexing;
     for (int aKIm=1 ; aKIm<=(mNbIm-1)*4 ; aKIm++)
	{
        bool AllOk;
	    float aWeight,aCorrel;
        //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
        // Compute cosine simialrity with respect to master ortho embeddings 
        
        /**************************************************************************************/
        AllOk = true;
        aWeight = 0;
        const tDImMasq & aDIM2  =  mVMasq.at(aKIm%(mNbIm-1) ? aKIm%(mNbIm-1) : (mNbIm-1)).at(0 ).DIm();
        for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
        {
            bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valid
            if (Ok)
            {
                aWeight++;
            }
            else
            {
                AllOk=false;
            }
        }
        // Compute correl separately 
        //using namespace torch::indexing;
        auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
        //std::cout<<" slave vector "<<aVecOther<<std::endl;
        aCorrel=(float)aSim.item<float>();
        /**************************************************************************************/  
	    if (AllOk)
	    {
            aTab[aKIm-1]    = aCorrel;
            aPonder[aKIm-1] = 1.0;
	    }
	    else
	    {
           aTab[aKIm-1]    = aCorrel ; 
           aPonder[aKIm-1] = aWeight/(mCNNWin.x()*mCNNWin.y());
	    }
	}
	// Moyennes deux  deux des corrlations
    tREAL4 AggCorr=-2.0;
    tREAL4 AggCorrMaxAllScales=-2.0;
    
    for (int scales=0;scales<4;scales++)
    {
        AggCorr=-2.0;
        for (int j=0;j<mNbIm-2;j++)
        {
            for (int i=j+1;i<mNbIm-1;i++)
            {
                tREAL4 aCorr=(aTab[i+(mNbIm-1)*scales]*aPonder[i+(mNbIm-1)*scales]+ aTab[j+(mNbIm-1)*scales]*aPonder[j+(mNbIm-1)*scales])/std::max(1e-5f,aPonder[i+(mNbIm-1)*scales]+aPonder[j+(mNbIm-1)*scales]); 
                if (AggCorr<aCorr)
                {
                    AggCorr=aCorr;
                }
            }
        }
        if (AggCorrMaxAllScales<AggCorr)
        {
            AggCorrMaxAllScales=AggCorr;
        }
    }
    if(AggCorrMaxAllScales==-2.0) AggCorrMaxAllScales=0.5;   // no max is found 
    aDImSim.SetV(aP,1-AggCorrMaxAllScales);
   }

   // delete All Similarities 
   delete AllSimilarities;
}


void cAppliMatchMultipleOrtho::ComputeSimilByLearnedCorrelMasterDempsterShafer(std::vector<torch::Tensor> * AllOrthosEmbeddings)
{
   MMVII_INTERNAL_ASSERT_strong(mIm1Mast,"DM4MatchMultipleOrtho, for now, only handle master image mode");

   tDImSimil & aDImSim = mImSimil.DIm();
   // Parse all pixels
	const tDImMasq & aDIM1  =  mVMasq.at(0   ).at(0   ).DIm();
    //compute similarity matrices at the beginning 
    std::vector<torch::Tensor> * AllSimilarities= new std::vector<torch::Tensor>;;
    for (int k=1; k<mNbIm; k++)
    {
        // compute element wise cross product along feature size dimension 
        auto aCrossProd=at::cosine_similarity(AllOrthosEmbeddings->at(0),AllOrthosEmbeddings->at(k),0).squeeze();
        AllSimilarities->push_back(aCrossProd);
    }
    // Free all ortho OneOrthoEmbeding 
    delete AllOrthosEmbeddings; 
    //std::cout<<" feature vector size : "<<FeatSize<<std::endl;
   for (const auto & aP : aDImSim)
   {
	 // Parse secondary images 
    tREAL4 aTab[mNbIm-1];
    tREAL4 aPonder[mNbIm-1];
	 using namespace torch::indexing;
        for (int aKIm=1 ; aKIm<mNbIm ; aKIm++)
	{
        bool AllOk;
	    float aWeight,aCorrel;
        //CorrelMaster(aP,aKIm,AllOk,aWeight,aCorrel);
        // Compute cosine simialrity with respect to master ortho embeddings 
        
        /**************************************************************************************/
        AllOk = true;
        aWeight = 0;
        const tDImMasq & aDIM2  =  mVMasq.at(aKIm).at(0   ).DIm();
        for (const auto & aPvoisin : cRect2::BoxWindow(aP,mCNNWin))  // Parse the window`
        {
            bool Ok = aDIM1.DefGetV(aPvoisin,0) && aDIM2.DefGetV(aPvoisin,0) ;  // Are both pixel valide
            if (Ok)
            {
                aWeight++;
            }
            else
            {
                AllOk=false;
            }
        }
        // Compute correl separately 
        auto aSim=AllSimilarities->at(aKIm-1).slice(0,aP.y(),aP.y()+1,1).slice(1,aP.x(),aP.x()+1,1);
        //std::cout<<" slave vector "<<aVecOther<<std::endl;
        aCorrel=(float)aSim.item<float>();
        /**************************************************************************************/  
	    if (AllOk)
	    {
            aTab[aKIm-1]    = aCorrel;
            aPonder[aKIm-1] = 1.0;
	    }
	    else
	    {
           aTab[aKIm-1]    = aCorrel ; 
           aPonder[aKIm-1] = aWeight/(mCNNWin.x()*mCNNWin.y());
	    }
	}
	// COmbinaison des corrlations par la mthode de D-S
	tREAL4 AggCorr;
    if (mNbIm==2) 
    {
        AggCorr=aTab[0];
    }
    else
    {
        AggCorr=ComputeJointMassBetween2Sets(aTab[0],aTab[1],aPonder[0],aPonder[1]);
        //std::cout<<" Value of correl "<<AggCorr<<std::endl;
        if (mNbIm>3)
        {
            for (int j=0;j<mNbIm-2;j++)
            {
                for (int i=(j==0) ? j+2:j+1;i<mNbIm-1;i++)
                {
                    AggCorr=ComputeJointMassBetween2Sets(AggCorr,aTab[i],1.0,aPonder[i]);
                }
            }
        }
    }
    //std::cout<<" Value of correl ))  "<<AggCorr<<std::endl;
    aDImSim.SetV(aP,1-AggCorr);
   }

   // delete All Similarities 
   delete AllSimilarities;
}

tREAL4 cAppliMatchMultipleOrtho::ComputeConflictBetween2SEts(tREAL4 aCorrel1, tREAL4 aCorrel2, tREAL4 aPonder1,tREAL4 aPonder2)
{
    return aPonder1*aCorrel1*(1-aPonder2*aCorrel2)+ (1-aPonder1*aCorrel1)+aPonder2*aCorrel2;
}
    
tREAL4 cAppliMatchMultipleOrtho::ComputeJointMassBetween2Sets(tREAL4 aCorrel1, tREAL4 aCorrel2, tREAL4 aPonder1,tREAL4 aPonder2)
{
    tREAL4 k=ComputeConflictBetween2SEts(aCorrel1,aCorrel2,aPonder1,aPonder2);
    //std::cout<<"Conflict between both values "<<k<<std::endl;
    if (k==1.0)  // conflict between 2 Correlations measures  ==> returm mean of correl
    {
        // for now return average but if there is a conflict between correl, it should be considered as an indicator !!!
        return (aCorrel1*aPonder1+aCorrel2*aPonder2)/std::max(1e-5f,aPonder1+aPonder2);
    }
    else
    {
        return aCorrel1*aPonder1*aPonder2*aCorrel2/(1-k);
    }
}

void cAppliMatchMultipleOrtho::MakeNormalizedIms()  // Possible errors here 
{
    // NORMALIZING IMAGES BEFORE INFERENCE 
    for( auto& MsOrth: mVOrtho)
    {
        for (auto& Im:MsOrth)
        {
            Im=NormalizedAvgDev(Im,1e-4);
        }
    }
}



int  cAppliMatchMultipleOrtho::ExeSubPixFeats()
{

   // Parse all Z
   // If using a model (CNN) Initialize the predictor 
   if (mArchitecture!="")
   {
        InitializePredictor();
   }
   for (int aZ=0 ; aZ<mNbZ ; aZ++)
   {
        mPrefixZ =  mPrefixGlob + "_Z" + ToStr(aZ);

        bool NoFile = ExistFile(mPrefixZ+ "_NoData");  // If no data in masq thie file exist
        bool WithFile = ExistFile(NameOrtho(0,0));
	// A little check
        MMVII_INTERNAL_ASSERT_strong(NoFile!=WithFile,"DM4MatchMultipleOrtho, incoherence file");
        if ((aZ==0)  && (true))
        {
             cDataFileIm2D aDF = cDataFileIm2D::Create(NameOrtho(0,0),false);
             StdOut() << " * NbI=" << mNbIm << " NbS=" <<  mNbScale << " NbZ=" <<  mNbZ << " Sz=" << aDF.Sz() << " SzW=" << mSzW << "\n";
        }
	if (WithFile)
        {
	    // Read  orthos and masq in  vectors of images
	    mSzIms = cPt2di(-1234,6789);
	    for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
	    {
                 mVOrtho.push_back(tVecOrtho());
                 mVMasq.push_back(tVecMasq());
                 for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                    {
                        mVOrtho.at(aKIm).push_back(tImOrtho::FromFile(NameOrtho(aKIm,aKScale)));
                        if ((aKIm==0) && (aKScale==0))
                            mSzIms = mVOrtho[0][0].DIm().Sz();  // Compute the size at level

                        mVMasq.at(aKIm).push_back(tImMasq::FromFile(NameMasq(aKIm,aKScale)));

                        // check all images have the same at a given level
                        MMVII_INTERNAL_ASSERT_strong(mVOrtho[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(ortho)");
                        MMVII_INTERNAL_ASSERT_strong(mVMasq [aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(masq)");
                    }
	    }

	    
	    // NORMALIZE IF LEARNING BASED CORRELATION 
        if (mWithExtCorr)
        {
           // MakeNormalizedIms();
        
        }
    
	    // Create similarity image with good size
	    mImSimil = tImSimil(mSzIms);
	    mImSimil.DIm().InitCste(1.0);

        if(mWithExtCorr)
        {
            std::vector<torch::Tensor> * OrthosEmbeddings= new std::vector<torch::Tensor>;
            if (!mWithDecisionNet)
            {
                // Inference based correlation 
                // Create Embeddings 
                // Calculate the EMBEDDINGS ONE TIME USING FOWARD OVER THE WHOLE TILEs
                for (unsigned int i=0;i<mVOrtho.size();i++)
                {
                    cPt2di aSzOrtho=mVOrtho.at(i).at(0).DIm().Sz();
                    torch::Tensor OneOrthoEmbeding;
                    if (mArchitecture==TheFastStandard)
                        {
                        OneOrthoEmbeding=mCNNPredictor->PredictTile(mNetFastStd,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheFastArch)
                        {
                        OneOrthoEmbeding=mCNNPredictor->PredictWithBNTile(mNetFastMVCNN,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheFastArchReg)
                        {
                            OneOrthoEmbeding=mCNNPredictor->PredictWithBNTileReg(mNetFastMVCNNReg,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheFastandPrjHead)
                        {
                        // std::cout<<"ORTOHS SIZES :  ====> "<<aSzOrtho<<std::endl;
                            OneOrthoEmbeding=mCNNPredictor->PredictPrjHead(mNetFastPrjHead,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheMSNet)
                        {
                        //  OneOrthoEmbeding=mCNNPredictor->PredictMSNetCommon(mMSNet,mVOrtho.at(i),aSzOrtho);
                        // OneOrthoEmbeding=mCNNPredictor->PredictMSNet(mMSNet,mVOrtho.at(i),aSzOrtho);

                            /*int Resol=1;
                            if (mResol!="")
                            {
                                Resol=std::atoi(mResol.c_str());
                            auto CommonEmbedding=mCNNPredictor->PredictMSNet(mMSNet,mVOrtho.at(i),aSzOrtho);
                            switch (Resol)
                            {
                                case 1:
                                    OneOrthoEmbeding=mCNNPredictor->PredictMSNet1(mMSNet,CommonEmbedding);
                                    break;
                                case 2:<<<<<<here>>>>>>
                                    OneOrthoEmbeding=mCNNPredictor->PredictMSNet2(mMSNet,CommonEmbedding);
                                    break;
                                case 4:
                                    OneOrthoEmbeding=mCNNPredictor->PredictMSNet3(mMSNet,CommonEmbedding);
                                    break;
                                case 8:
                                    OneOrthoEmbeding=mCNNPredictor->PredictMSNet4(mMSNet,CommonEmbedding);
                                    break;
                                default:
                                    // Full Resolution Inference
                                    OneOrthoEmbeding=mCNNPredictor->PredictMSNet1(mMSNet,CommonEmbedding);
                                    break;
                            }*/

                            //OneOrthoEmbeding=mCNNPredictor->PredictMSNetHead(mMSNet,mVOrtho.at(i),aSzOrtho);
                            OneOrthoEmbeding=mCNNPredictor->PredictMSNetAtt(mMSNet,mVOrtho.at(i),aSzOrtho);
                        }
                    else if (mArchitecture==TheFastArchWithMLP)
                        {
                            OneOrthoEmbeding=mCNNPredictor->PredictFastWithHead(mNetFastMVCNNMLP,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheFastArchDirectSim)
                        {
                            OneOrthoEmbeding=mCNNPredictor->PredictSimNetConv(mNetFastMVCNNDirectSIM,mVOrtho.at(i).at(0),aSzOrtho);
                        }
                    else if (mArchitecture==TheUnetMlpCubeMatcher)
                      {
                            OneOrthoEmbeding=mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mVOrtho.at(i),aSzOrtho);
                      }

                    //StdOut()  <<" EMBEDDING FOR VECTOR OR FULL RESOLUTION ORTHO : "<<i<<OneOrthoEmbeding.sizes()<<"\n";
                    // store in relevant vector 
                    OrthosEmbeddings->push_back(OneOrthoEmbeding);
                }

                //
                if (mArchitecture==TheUnetMlpCubeMatcher)
                {
                    //ComputeSimilByLearnedCorrelMasterMaxMoyMulScale(OrthosEmbeddings); // Size 4*numberofOrthos
                    ComputeSimilByLearnedCorrelMasterEnhanced(OrthosEmbeddings);
                    //ComputeSimilByLearnedCorrelMasterDecision(); <<<<<<here>>>>>>
                }

            }
            //StdOut()  <<" Size OF EMBEDDINGS MS : " <<OrthosEmbeddings->size()<<"\n";

            else
              {
                  // GIVEN THE ORTHOS EMBEDDINGS, Compute Correlation for each pixel in the similarity image => index work to get vectors from from tensors
                  if (mArchitecture==TheMSNet)
                  {
                      //ComputeSimilByLearnedCorrelMasterMaxMoyMulScale(OrthosEmbeddings); // Size 4*numberofOrthos
                      ComputeSimilByLearnedCorrelMasterEnhanced(OrthosEmbeddings);
                      //ComputeSimilByLearnedCorrelMasterDecision(); <<<<<<here>>>>>>
                  }
                  if (mArchitecture==TheUnetMlpCubeMatcher)
                  {
                      ComputeSimilByLearnedCorrelMasterDecision();
                  }
                  else
                  {
                     ComputeSimilByLearnedCorrelMasterMaxMoy(OrthosEmbeddings);
                  }
              }
            
        }
        else
        {
            ComputeSimilByCorrelMaster();    
        }
        
	    mImSimil.DIm().ToFile(mPrefixZ+ "_Sim.tif"); // Save similarities
	    mVOrtho.clear();
	    mVMasq.clear();
        }
   }
   return EXIT_SUCCESS;
}

double cAppliMatchMultipleOrtho::Interpol_Bilin(torch::Tensor & aMap, const cPt2dr & aLoc)
{
    using namespace torch::indexing;

    double InterpValue=0.0;
    double aLocX=(double)aLoc.x();
    double aLocY=(double)aLoc.y();
    int y_1 = floor(aLocY);
    int x_1 = floor(aLocX);
    int y_2 = ceil(aLocY);
    int x_2 = ceil(aLocX);
    //std::cout<<" 2D SLICE TO COMPUTE INTERPOL "<<aMap.sizes()<<std::endl;
    if (x_2<aMap.size(1) && y_2<aMap.size(0))
        {
            double aMap11=aMap.index({y_1,x_1}).item<double>();
            //double aMap11=aMap.slice(y_1,y_1+1).slice(x_1,x_1+1).item<double>();
            double aMap21=aMap.index({y_2,x_1}).item<double>() ;
            //double aMap21=aMap.slice(y_2,y_2+1).slice(x_1,x_1+1).item<double>();
            double aMap12=aMap.index({y_1,x_2}).item<double>() ;
            //double aMap12=aMap.slice(y_1,y_1+1).slice(x_2,x_2+1).item<double>();
            double aMap22=aMap.index({y_2,x_2}).item<double>() ;
            //double aMap22=aMap.slice(y_2,y_2+1).slice(x_2,x_2+1).item<double>();

            double y_2_y=(double)y_2-aLocY;
            double y_y_1=aLocY-(double)y_1;
            // Interpolate values

            InterpValue= ((double)x_2-aLocX)*(aMap11*y_2_y+aMap21*y_y_1)
                    + (aLocX-(double)x_1)*(aMap12*y_2_y+aMap22*y_y_1);
        }
    //std::cout<<"INTER    PPPP "<<InterpValue<<std::endl;
    return InterpValue;
}

torch::Tensor cAppliMatchMultipleOrtho::Gather2D(torch::Tensor & aFeatMap, torch::Tensor  anX,
                                                 torch::Tensor  anY)
{
    using namespace torch::indexing;
    // Gathers a tensor given mappings anX and anY
    // Out[F,j,k] = In[F,anY[j,k], anX[j,k]]
    /*std::cout<<"INITIAL OFFSETS SHAPE "<<anY.sizes()<<"   "<<anX.sizes()<<std::endl;
    auto index_y=anY.view(anY.size(0)*anY.size(1));
    auto index_x=anX.view(anX.size(0)*anX.size(1));
    auto IN=aFeatMap.contiguous();
    IN=IN.view({-1,IN.size(1)*IN.size(2)});
    auto aInterpolFeat= IN.index({Slice(0,None,1),index_y,index_x}).view({-1,anY.size(0),anY.size(1)});
    return aInterpolFeat;*/
    /*auto IN=aFeatMap.contiguous();
    torch::Tensor Lin_idx= anY + IN.size(-1) * anX;
    std::cout<<" Linear  index "<<Lin_idx.sizes()<<std::endl;
    IN=IN.view({-1,IN.size(1)*IN.size(2)});
    return torch::gather(IN,-1,Lin_idx).view({-1,anY.size(-2),anY.size(-1)});*/

    return torch::einsum("ijk->ijk",{aFeatMap.index({Slice(),anY,anX})});
}

torch::Tensor cAppliMatchMultipleOrtho::ToTensorGeo(tImOrtho & aGeoX,tImOrtho & aGeoY, cPt2di aDIM)
{
  using namespace torch::indexing;
  cPt2di aSzOrtho=aGeoX.DIm().Sz();
  // Generate tensor offsets
  tREAL4 ** mGeoXData=aGeoX.DIm().ExtractRawData2D();
  tREAL4 ** mGeoYData=aGeoY.DIm().ExtractRawData2D();
  // create offsets tensors for interpolation
  torch::Tensor aGeoXT=torch::from_blob((*mGeoXData), {aSzOrtho.y(),aSzOrtho.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));
  torch::Tensor aGeoYT=torch::from_blob((*mGeoYData), {aSzOrtho.y(),aSzOrtho.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));
   aGeoXT=aGeoXT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
   aGeoYT=aGeoYT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
   return torch::stack({aGeoXT.div((float)aDIM.x()/2),aGeoYT.div((float)aDIM.y()/2)},-1).sub(1.0).unsqueeze(0);
}

torch::Tensor cAppliMatchMultipleOrtho::ToTensorGeo(tImOrtho & aGeoX,tImOrtho & aGeoY)
{
  using namespace torch::indexing;
  cPt2di aSzOrtho=aGeoX.DIm().Sz();
  // Generate tensor offsets
  tREAL4 ** mGeoXData=aGeoX.DIm().ExtractRawData2D();
  tREAL4 ** mGeoYData=aGeoY.DIm().ExtractRawData2D();
  // create offsets tensors for interpolation
  torch::Tensor aGeoXT=torch::from_blob((*mGeoXData), {aSzOrtho.y(),aSzOrtho.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));
  torch::Tensor aGeoYT=torch::from_blob((*mGeoYData), {aSzOrtho.y(),aSzOrtho.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));
   //aGeoXT=aGeoXT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
   //aGeoYT=aGeoYT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
   return torch::stack({aGeoXT,aGeoYT},-1).unsqueeze(0);
}

torch::Tensor cAppliMatchMultipleOrtho::InterpolateFeatMap(torch::Tensor & aFeatMap,
                                                           tImOrtho aGeoX, tImOrtho aGeoY)
{
    cPt2di aSzOrtho=aGeoX.DIm().Sz();
    using namespace torch::indexing;
    auto FeatSz=aFeatMap.size(0);
    auto HFeatMap=aFeatMap.size(1);
    auto WFeatMap=aFeatMap.size(2);

    // Tensor Interpolate at once
    torch::Tensor anInterPolFeatMap=torch::zeros({FeatSz,aSzOrtho.y()-1,aSzOrtho.x()-1},
                                                 torch::TensorOptions().dtype(torch::kFloat32));

    // Generate tensor offsets
    tREAL4 ** mGeoXData=aGeoX.DIm().ExtractRawData2D();
    tREAL4 ** mGeoYData=aGeoY.DIm().ExtractRawData2D();

    // create offsets tensors for interpolation
    torch::Tensor aGeoXT=torch::from_blob((*mGeoXData), {aSzOrtho.y(),aSzOrtho.x()},
                                          torch::TensorOptions().dtype(torch::kFloat32));
    torch::Tensor aGeoYT=torch::from_blob((*mGeoYData), {aSzOrtho.y(),aSzOrtho.x()},
                                          torch::TensorOptions().dtype(torch::kFloat32));

     aGeoXT=aGeoXT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
     aGeoYT=aGeoYT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
    //std::cout<<"  OFFSETS DIMENSIONS ------   X"<<aGeoXT.sizes()<<"   Y  "<<aGeoYT.sizes()<<std::endl;

    // Get definition Tensors
    auto DEF_X=torch::mul((aGeoXT>=0), (aGeoXT<WFeatMap));
    auto DEF_Y=torch::mul((aGeoYT>=0), (aGeoYT<HFeatMap));

    // floor and ceil
    torch::Tensor Y_1=torch::floor(aGeoYT).mul(DEF_Y);
    torch::Tensor X_1=torch::floor(aGeoXT).mul(DEF_X);

    torch::Tensor Y_2=torch::ceil(aGeoYT).mul(DEF_Y);
    torch::Tensor X_2=torch::ceil(aGeoXT).mul(DEF_X);

    aGeoXT=aGeoXT.mul(DEF_X);
    aGeoYT=aGeoYT.mul(DEF_Y);

    Y_2=Y_2.mul(Y_2<HFeatMap);
    X_2=X_2.mul(X_2<WFeatMap);

    //std::cout<<" offsets limits "<<at::max(X_2)<<" Y_2 "<<at::max(Y_2)<<" X_1  "<<at::max(X_1)<<" Y_1 "<<at::max(Y_1)<<std::endl;

    //std::cout<<"  X_2 AND Y_2 DIMENSIONS ------   X"<<Y_2.sizes()<<"   Y  "<<X_2.sizes()<<std::endl;

    //auto alongx=torch::gather(aFeatMap,-2,X_1.unsqueeze(0).repeat_interleave(FeatSz,0).to(torch::kInt64));

    //std::cout<<"ALONG XXXX "<<alongx.sizes()<<std::endl;

    //auto aMAP_11= torch::gather(alongx,-1,Y_1.unsqueeze(0).repeat_interleave(FeatSz,0).to(torch::kInt64));
    //auto aMAP_11=torch::einsum("ijk->ijk",{aFeatMap.index({Slice(),Y_1.to(torch::kInt64),X_1.to(torch::kInt64)})});
    auto aMAP_11=aFeatMap.index({Slice(),Y_1.to(torch::kInt64),X_1.to(torch::kInt64)});
    //std::cout<<"  composed offsets "<<aMAP_11.sizes()<<std::endl;
    //auto aMAP_21=torch::einsum("ijk->ijk",{aFeatMap.index({Slice(),Y_2.to(torch::kInt64),X_1.to(torch::kInt64)})});
    auto aMAP_21=aFeatMap.index({Slice(),Y_2.to(torch::kInt64),X_1.to(torch::kInt64)});
    //auto aMAP_12=torch::einsum("ijk->ijk",{aFeatMap.index({Slice(),Y_1.to(torch::kInt64),X_2.to(torch::kInt64)})});
    auto aMAP_12=aFeatMap.index({Slice(),Y_1.to(torch::kInt64),X_2.to(torch::kInt64)});
    //auto aMAP_22=torch::einsum("ijk->ijk",{aFeatMap.index({Slice(),Y_2.to(torch::kInt64),X_2.to(torch::kInt64)})});
    auto aMAP_22=aFeatMap.index({Slice(),Y_2.to(torch::kInt64),X_2.to(torch::kInt64)});
    //std::cout<<"  MAP 22 DIMENSIONS ------   X"<<aMAP_22.sizes()<<"   Y  "<<aMAP_22.sizes()<<std::endl;

    /*bool oktest1=true;
    if (oktest1)
        {
            // Tests on feature warping routine correctness
            auto aFeat= aMAP_11.index({Slice(0,None,1),50,50});
            int y_ind=(int) Y_1.index({50,50}).item<double>();
            int x_ind=(int) X_1.index({50,50}).item<double>();
            auto aFeatFromIndices=aFeatMap.index({Slice(0,None,1),y_ind,x_ind});
            auto isEqual=torch::equal(aFeat,aFeatFromIndices);
            MMVII_INTERNAL_ASSERT_strong(isEqual, "PROBLEM WITH FEATURE WARPIGN BEFORE INTERPOLATION !!!");
        }*/

    // INTERPOLATE THE WHOLE FEATURE MAP

    //             InterpValue= ((double)x_2-aLocX)*(aMap11*y_2_y+aMap21*y_y_1)
    //              + (aLocX-(double)x_1)*(aMap12*y_2_y+aMap22*y_y_1);


//                               |aMAP11 aMAP21| |Y_2 - Y|
//   out = |X_2 - X , X - X_1 |  |             | |       |
//                               |aMAP12 aMAP22| |Y - Y_1|

    auto Y_1GEOYT=aGeoYT-Y_1;
    auto Y_2GEOYT=Y_2-aGeoYT;
    auto X_1GEOXT=aGeoXT-X_1;
    auto X_2GEOXT=X_2-aGeoXT;
    Y_2GEOYT.index_put_({Y_2GEOYT==0},1);
    X_2GEOXT.index_put_({X_2GEOXT==0},1);
    auto TERM_1= torch::einsum("ijk,jk->ijk",{aMAP_11,Y_2GEOYT})+torch::einsum("ijk,jk->ijk",{aMAP_21,Y_1GEOYT});
    auto TERM_2= torch::einsum("ijk,jk->ijk",{aMAP_12,Y_2GEOYT})+torch::einsum("ijk,jk->ijk",{aMAP_22,Y_1GEOYT});
    anInterPolFeatMap=torch::einsum("ijk,jk->ijk",{TERM_1,X_2GEOXT})+torch::einsum("ijk,jk->ijk",{TERM_2,X_1GEOXT});

    /*anInterPolFeatMap=(X_2-aGeoXT)*(aMAP_11.mul(Y_2-aGeoYT)+aMAP_21.mul(aGeoYT-Y_1))
            + (aGeoXT-X_1)*(aMAP_12.mul(Y_2-aGeoYT)+aMAP_22.mul(aGeoYT-Y_1)) ;*/

    // SOME CHECKS
    bool oktest=false;

    if (oktest)
        {

            std::cout<<"------------><<<<< CHECK  CORRECTNESS OF BILIN INTERPOL "<<std::endl;
            // Tests on feature warping routine correctness
            auto aFeat11= aMAP_11.index({Slice(0,None,1),50,50});
            auto aFeat21= aMAP_21.index({Slice(0,None,1),50,50});
            auto aFeat12= aMAP_12.index({Slice(0,None,1),50,50});
            auto aFeat22= aMAP_22.index({Slice(0,None,1),50,50});

            double y1_ind=Y_1.index({50,50}).item<double>();
            double x1_ind=X_1.index({50,50}).item<double>();
            double y2_ind=Y_2.index({50,50}).item<double>();
            double x2_ind=X_2.index({50,50}).item<double>();
            double XX=aGeoXT.index({50,50}).item<double>();
            double YY=aGeoYT.index({50,50}).item<double>();

            auto res =(x2_ind-XX)*(aFeat11.mul(y2_ind-YY)+aFeat21.mul(YY-y1_ind))
                    + (XX-x1_ind)*(aFeat12.mul(y2_ind-YY)+aFeat22.mul(YY-y1_ind)) ;
            float diff=torch::sum(res-anInterPolFeatMap.index({Slice(),50,50})).squeeze().item<float>();

            //std::cout<<"  by hand interpolation   ==>  "<<res<<std::endl;
            //std::cout<<"  bulk accessed with index interpol "<<anInterPolFeatMap.index({Slice(),50,50})<<std::endl;
            //std::cout<<"Difference ==> "<<torch::sum(res-anInterPolFeatMap.index({Slice(),50,50}))<<" condition on equality"<<isEqual<<std::endl;

            std::cout<<" Error check by comparing bulk interpolator with by sample one "<<diff<<std::endl;

            MMVII_INTERNAL_ASSERT_tiny(diff>0.001, "PROBLEM WITH FEATURE WARPIGN BEFORE INTERPOLATION !!!");
        }


    return anInterPolFeatMap;
}

torch::Tensor cAppliMatchMultipleOrtho::ResampleFeatureMap(torch::Tensor & aFeatMap, tImOrtho aGeoX, tImOrtho aGeoY)
{
    // Assuming aFeatMap of shape F, H, W
    // Interpolates an embedding at real valued locations
    //cInterpolateurIm2D<float> * anInt
    cPt2di aSzOrtho=aGeoX.DIm().Sz();
    std::cout<<"  ooooooo   "<<aFeatMap.sizes()<<std::endl;

    using namespace torch::indexing;

    auto FeatSz=aFeatMap.size(0);
    auto HFeatMap=aFeatMap.size(1);
    auto WFeatMap=aFeatMap.size(2);

    // Allocate tensor
    //std::cout<<FeatSz<<"   "<<HFeatMap<<"   "<<WFeatMap<<std::endl;
    //(*anInterPolFeatMap)=torch::empty({FeatSz,aSzOrtho.y,aSzOrtho.x}, torch::TensorOptions().dtype(torch::kFloat32));
    torch::Tensor anInterPolFeatMap=torch::zeros({FeatSz,aSzOrtho.y()-1,aSzOrtho.x()-1},torch::TensorOptions().dtype(torch::kFloat32));
    //std::cout<<" SDSDSDSDSD  "<<anInterPolFeatMap.sizes()<<std::endl;
    for (int fdim=0;fdim<FeatSz;fdim++)
        {
            // Get a 2d image like slice of the feature map tensor
            auto IM = aFeatMap.index({fdim,Slice(0,None,1),Slice(0,None,1)});
            //std::cout<<" IMIMIMIMIMI  "<<IM.sizes()<<std::endl;
            for (int x=0; x<aSzOrtho.x()-1; x++)
                {
                    for (int y=0;y<aSzOrtho.y()-1;y++)
                        {
                            // for each real valued location, interpolate features at Z
                            cPt2di anInd(x,y);
                            cPt2dr aPIm = cPt2dr( aGeoX.DIm().VD_GetV(anInd), aGeoY.DIm().VD_GetV(anInd));
                            // check if point in IM
                            if (aPIm.x()>0 && aPIm.x()<WFeatMap && aPIm.y()>0 && aPIm.y()<HFeatMap)
                                {
                                    //auto anElem=anInterPolFeatMap.index({fdim,y,x});
                                    //std::cout<<this->Interpol_Bilin(IM,aPIm)<<std::endl;
                                    //auto anElementTensor = torch::tensor({this->Interpol_Bilin(IM,aPIm)});
                                    //std::cout<<anElementTensor<<std::endl;
                                    //std::cout<<" test access to tensor element "<<anElem<<"  and the affected term  "<<torch::tensor(this->Interpol_Bilin(IM,aPIm))<<std::endl;

                                    anInterPolFeatMap.index({fdim,y,x}).copy_(torch::tensor(this->Interpol_Bilin(IM,aPIm)));
                                }
                         }
                }
        }
    return anInterPolFeatMap;
}


torch::Tensor cAppliMatchMultipleOrtho::ComputeEpipolarImage(tImOrtho & aNativeGeomImage, tImOrtho & aGeoX, tImOrtho & aGeoY)
{
  using namespace torch::indexing;
  namespace FFunc=torch::nn::functional;
  cPt2di aSzOrtho= aNativeGeomImage.DIm().Sz();
  cPt2di aSzGeo= aGeoX.DIm().Sz();
  tREAL4 ** mGeoXData=aGeoX.DIm().ExtractRawData2D();
  tREAL4 ** mGeoYData=aGeoY.DIm().ExtractRawData2D();
  tREAL4 ** mNativeData=aNativeGeomImage.DIm().ExtractRawData2D();

  // create offsets tensors for interpolation
  torch::Tensor aGeoXT=torch::from_blob((*mGeoXData), {aSzGeo.y(),aSzGeo.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));
  torch::Tensor aGeoYT=torch::from_blob((*mGeoYData), {aSzGeo.y(),aSzGeo.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32));

  torch::Tensor aNativeImT=torch::from_blob((*mNativeData), {aSzOrtho.y(),aSzOrtho.x()},
                                        torch::TensorOptions().dtype(torch::kFloat32)).unsqueeze(0).unsqueeze(0); // 1,1,H,W

   //aGeoXT=aGeoXT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});
   //aGeoYT=aGeoYT.index({Slice(0,aSzOrtho.y()-1,1),Slice(0,aSzOrtho.x()-1,1)});

   return FFunc::grid_sample(aNativeImT,
                             torch::stack({aGeoXT,aGeoYT},-1).unsqueeze(0), // 1,h,w,2
                              F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze(); //H,W
}

int  cAppliMatchMultipleOrtho::ExeProjectOrigEmbeddings()
{
  torch::Device device(mUseCuda ? torch::kCUDA : torch::kCPU);
   // Parse all Z
   // If using a model (CNN) Initialize the predictor
   if (mArchitecture!="")
   {
        InitializePredictor();
   }

   // load Original images
   bool WithFile = ExistFile(NameORIG(0,0));
   if (WithFile)
       {
           for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
           {
                mORIGIm.push_back(tVecOrtho());
                for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                   {
                       mORIGIm.at(aKIm).push_back(tImOrtho::FromFile(NameORIG(aKIm,aKScale)));
                   }
           }
        }

   // compute original embeddings
   std::vector<torch::Tensor> * OrigEmbeddings= new std::vector<torch::Tensor>;
   if (mWithExtCorr)
     {
       for (unsigned int i=0; i<mORIGIm.size();i++)
         {
           cPt2di aSzImOrig=mORIGIm.at(i).at(0).DIm().Sz();
           if (mArchitecture==TheUnetMlpCubeMatcher)
             {
                  OrigEmbeddings->push_back(mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mORIGIm.at(i),aSzImOrig));
             }
         }

     }

   // Load Displacement grids in X and Y directions to apply to each embedding
   for (int aZ=0 ; aZ<mNbZ ; aZ++)
   {
        mPrefixZ =  mPrefixGlob + "_Z" + ToStr(aZ);

        bool NoFile = ExistFile(mPrefixZ+ "_NoData");  // If no data in masq thie file exist
        WithFile = ExistFile(NameOrtho(0,0));
        // A little check
        MMVII_INTERNAL_ASSERT_strong(NoFile!=WithFile,"DM4MatchMultipleOrtho, incoherence file");
        if ((aZ==0)  && (true))
        {
             cDataFileIm2D aDF = cDataFileIm2D::Create(NameOrtho(0,0),false);
             StdOut() << " * NbI=" << mNbIm << " NbS=" <<  mNbScale << " NbZ=" <<  mNbZ << " Sz=" << aDF.Sz() << " SzW=" << mSzW << "\n";
        }
        if (WithFile)
        {
            // Read  orthos and masq in  vectors of images
            mSzIms = cPt2di(-1234,6789);
            for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
            {
                 mVOrtho.push_back(tVecOrtho());
                 mVMasq.push_back(tVecMasq());
                 mVGEOX.push_back(tVecOrtho());
                 mVGEOY.push_back(tVecOrtho());
                 for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                    {
                        mVOrtho.at(aKIm).push_back(tImOrtho::FromFile(NameOrtho(aKIm,aKScale)));
                        /*if (aKIm==2)
                          {
                            std::cout<<"NAME GEOX :"<<NameGeoX(aKIm,aKScale)<<std::endl;
                            std::cout<<"NAME GEOY :"<<NameGeoY(aKIm,aKScale)<<std::endl;
                          }*/
                        mVGEOX.at(aKIm).push_back(tImOrtho::FromFile(NameGeoX(aKIm,aKScale)));
                        mVGEOY.at(aKIm).push_back(tImOrtho::FromFile(NameGeoY(aKIm,aKScale)));
                        if ((aKIm==0) && (aKScale==0))
                            mSzIms = mVOrtho[0][0].DIm().Sz();  // Compute the size at level

                        mVMasq.at(aKIm).push_back(tImMasq::FromFile(NameMasq(aKIm,aKScale)));

                        // check all images have the same at a given level
                        MMVII_INTERNAL_ASSERT_strong(mVOrtho[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(ortho)");
                        MMVII_INTERNAL_ASSERT_strong(mVMasq [aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(masq)");
                    }
            }
              // Create similarity image with good size
              mImSimil = tImSimil(mSzIms);
              mImSimil.DIm().InitCste(1.0);   //  1.0 => correl of -1  (cube is filled with (1-corr)/2.0 when cos and 1-sim when sim)


        if(mWithExtCorr)
        {
          std::vector<torch::Tensor> * ProjectEmbeddings = new std::vector<torch::Tensor>;
              // Inference based correlation
              // Create Embeddings
              // Calculate the EMBEDDINGS ONE TIME USING FOWARD OVER THE WHOLE TILEs
              MMVII_INTERNAL_ASSERT_strong(mArchitecture==TheUnetMlpCubeMatcher, "TheUnetMlpCubeMatcher is the only option for Now");
              if (mArchitecture==TheUnetMlpCubeMatcher)
                 {
                      namespace FFunc=torch::nn::functional;
                      cPt2di aSzIm;
                      cPt2di aSzImOrig;
                      // project all except the master (i=0) embedding
                      MMVII_INTERNAL_ASSERT_strong(mVGEOX.size()>1,"No query image found!");
                      //ProjectEmbeddings->push_back(OrigEmbeddings->at(0));
                      //std::cout<<"##########################  "<<0<<"  "<<ProjectEmbeddings->at(0).sizes()<<"  ###########################"<<std::endl;
                      for (unsigned int i=0; i<mORIGIm.size();i++)
                        {
                          aSzIm=mVOrtho.at(i).at(0).DIm().Sz();
                          aSzImOrig=mORIGIm.at(i).at(0).DIm().Sz();
                          //ProjectEmbeddings->push_back(this->InterpolateFeatMap(OrigEmbeddings->at(i),mVGEOX[i][0],mVGEOY[i][0]));

                          ProjectEmbeddings->push_back(FFunc::grid_sample(OrigEmbeddings->at(i).unsqueeze(0),
                                                                          ToTensorGeo(mVGEOX[i][0],mVGEOY[i][0],aSzImOrig-cPt2di(1,1)).to(device),
                            FFunc::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());

                          //auto OrthoEmbedding=mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mVOrtho.at(i),aSzIm);
                          //auto COSINE=at::cosine_similarity(OrthoEmbedding,ProjectEmbeddings->at(i),0).squeeze();
                          //std::cout<<" CORRELATION CHECK >>>  "<<at::mean(COSINE)<<std::endl;
                          //std::cout<<"##########################  "<<i<<"  "<<ProjectEmbeddings->at(i).sizes()<<"  ###########################"<<std::endl;
                        }
                      ComputeSimilByLearnedCorrelMasterEnhanced(ProjectEmbeddings);
                 }

        }
        else
        {
            ComputeSimilByCorrelMaster();
        }

            mImSimil.DIm().ToFile(mPrefixZ+ "_Sim.tif"); // Save similarities
            mVOrtho.clear();
            mVGEOX.clear();
            mVGEOY.clear();
            mVMasq.clear();
        }
   }
   return EXIT_SUCCESS;
}




int  cAppliMatchMultipleOrtho::GotoEpipolar()
{
  torch::Device device(mUseCuda ? torch::kCUDA : torch::kCPU);
   // Parse all Z
   // If using a model (CNN) Initialize the predictor
   if (mArchitecture!="")
   {
        InitializePredictor();
   }

   // load Original images
   bool WithFile = ExistFile(NameORIG(0,0));
   bool WithEpipolar=ExistFile(NameORIGMASTEREpImGEOX(0,1,0));
   if (WithFile)
       {
           for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
           {
                mORIGIm.push_back(tVecOrtho());
                for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                   {
                       mORIGIm.at(aKIm).push_back(tImOrtho::FromFile(NameORIG(aKIm,aKScale)));
                   }
           }
        }

   // load image to epipolar maps and back
    //std::vector<tVecOrtho> mORIG_GEOX, mORIG_GEOY;
    std::vector<tVecOrtho>    mORIG_EpIm_GEOX, mORIG_EpIm_GEOY, mEPIPS;
    //std::vector<tVecMasq>  mORIG_MASQs;
    std::vector<tVecMasq> mORIG_EpIm_MASQs;

    if (WithEpipolar)
      {
        int aInd=0;
        for (int akIm=1; akIm<mNbIm ; akIm++ ) // ajouter une image pour le passage aux images pipolaires
          {
            // for each secondary image fille containers twice : one for master eipolar + one for secondary

            // 1. master epipolar
            //mORIG_GEOX.push_back(tVecOrtho());
            //mORIG_GEOY.push_back(tVecOrtho());
            //mORIG_MASQs.push_back(tVecMasq());

            mORIG_EpIm_GEOX.push_back(tVecOrtho());
            mORIG_EpIm_GEOY.push_back(tVecOrtho());
            mORIG_EpIm_MASQs.push_back(tVecMasq());
            mEPIPS.push_back(tVecOrtho());

            // 2. second epipolar

            aInd+=1;
            //mORIG_GEOX.push_back(tVecOrtho());
            //mORIG_GEOY.push_back(tVecOrtho());
            //mORIG_MASQs.push_back(tVecMasq());
            mEPIPS.push_back(tVecOrtho());
            mORIG_EpIm_GEOX.push_back(tVecOrtho());
            mORIG_EpIm_GEOY.push_back(tVecOrtho());
            mORIG_EpIm_MASQs.push_back(tVecMasq());

            for (int aKScale=0; aKScale<mNbScale; aKScale++)
              {
                // Master
                //mORIG_GEOX.at(aInd-1).push_back(tImOrtho::FromFile(NameORIGMASTERGEOX(0,akIm,aKScale)));
                //mORIG_GEOY.at(aInd-1).push_back(tImOrtho::FromFile(NameORIGMASTERGEOY(0,akIm,aKScale)));
                //mORIG_MASQs.at(aInd-1).push_back(tImMasq::FromFile(NameORIGMASTERMASQ(0,akIm,aKScale)));

                mORIG_EpIm_GEOX.at(aInd-1).push_back(tImOrtho::FromFile(NameORIGMASTEREpImGEOX(0,akIm,aKScale)));
                mORIG_EpIm_GEOY.at(aInd-1).push_back(tImOrtho::FromFile(NameORIGMASTEREpImGEOY(0,akIm,aKScale)));
                mORIG_EpIm_MASQs.at(aInd-1).push_back(tImMasq::FromFile(NameORIGMASTEREpImMASQ(0,akIm,aKScale)));
                // Secondary
                //mORIG_GEOX.at(aInd).push_back(tImOrtho::FromFile(NameORIGSECGEOX(akIm,aKScale)));
                //mORIG_GEOY.at(aInd).push_back(tImOrtho::FromFile(NameORIGSECGEOY(akIm,aKScale)));
                //mORIG_MASQs.at(aInd).push_back(tImMasq::FromFile(NameORIGSECMASQ(akIm,aKScale)));

                mORIG_EpIm_GEOX.at(aInd).push_back(tImOrtho::FromFile(NameORIGSECEpImGEOX(akIm,aKScale)));
                mORIG_EpIm_GEOY.at(aInd).push_back(tImOrtho::FromFile(NameORIGSECEpImGEOY(akIm,aKScale)));
                mORIG_EpIm_MASQs.at(aInd).push_back(tImMasq::FromFile(NameORIGSECEpImMASQ(akIm,aKScale)));

                // Load bare epips
                mEPIPS.at(aInd-1).push_back(tImOrtho::FromFile(NameMASTEREPIP(0,akIm,aKScale)));
                mEPIPS.at(aInd).push_back(tImOrtho::FromFile(NameSECEPIP(akIm,0,aKScale)));
              }
            aInd+=1;
          }
      }

   // compute original embeddings
   std::vector<torch::Tensor> * OrigEmbeddings= new std::vector<torch::Tensor>;
   if (WithEpipolar)
     {
       int anIndIm=1;
       for (int anInd=0;anInd<2*(mNbIm-1);anInd+=2,anIndIm++)
         {
           /*auto aMasterEpip=this->ComputeEpipolarImage(mORIGIm.at(0).at(0),
                                                       mORIG_GEOX.at(anInd).at(0),
                                                       mORIG_GEOY.at(anInd).at(0));
           auto aSecEpip=this->ComputeEpipolarImage(mORIGIm.at(anIndIm).at(0),
                                                    mORIG_GEOX.at(anInd+1).at(0),
                                                    mORIG_GEOY.at(anInd+1).at(0));
                                                    */
           // compute descriptors on the epipolar images directly

           if (mArchitecture==TheUnetMlpCubeMatcher)
             {
               namespace FFunc=torch::nn::functional;
               cPt2di aSzImEpipMaster=mEPIPS.at(anInd).at(0).DIm().Sz();
               cPt2di aSzImEpipSec =mEPIPS.at(anInd+1).at(0).DIm().Sz();
               auto MasterFeat=mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mEPIPS.at(anInd),aSzImEpipMaster);
               auto SecFeat   =mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mEPIPS.at(anInd+1),aSzImEpipSec);

               OrigEmbeddings->push_back(FFunc::grid_sample(MasterFeat.unsqueeze(0),
                                                            ToTensorGeo(mORIG_EpIm_GEOX[anInd][0],mORIG_EpIm_GEOY[anInd][0]).to(device),
              F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());

               OrigEmbeddings->push_back(FFunc::grid_sample(SecFeat.unsqueeze(0),
                                                            ToTensorGeo(mORIG_EpIm_GEOX[anInd+1][0],mORIG_EpIm_GEOY[anInd+1][0]).to(device),
              F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());


               if (0)
                 {
                   // Save some images rectified back to the original image
                   if (anInd==0)
                     {
                        auto aMasterImage=ComputeEpipolarImage(mEPIPS.at(anInd).at(0),mORIG_EpIm_GEOX[anInd][0],mORIG_EpIm_GEOY[anInd][0]);
                        auto aSecImage   =ComputeEpipolarImage(mEPIPS.at(anInd+1).at(0),mORIG_EpIm_GEOX[anInd+1][0],mORIG_EpIm_GEOY[anInd+1][0]);

                        // Write images
                        Tensor2Tiff(aMasterImage,"./MASTER_IM.tif");
                        Tensor2Tiff(aSecImage,"./SEC_IM.tif");
                     }

                 }

             }
           else
             {
               MMVII_INTERNAL_ASSERT_strong(false,"DM4MatchMultipleOrtho, Model architecture not taken into account !");
             }
         }
     }

   // Load Displacement grids in X and Y directions to apply to each embedding
   for (int aZ=0 ; aZ<mNbZ ; aZ++)
   {
        mPrefixZ =  mPrefixGlob + "_Z" + ToStr(aZ);

        bool NoFile = ExistFile(mPrefixZ+ "_NoData");  // If no data in masq thie file exist
        WithFile = ExistFile(NameMasq(0,0));
        // A little check
        MMVII_INTERNAL_ASSERT_strong(NoFile!=WithFile,"DM4MatchMultipleOrtho, incoherence file");
        if ((aZ==0)  && (true))
        {
             cDataFileIm2D aDF = cDataFileIm2D::Create(NameMasq(0,0),false);
             StdOut() << " * NbI=" << mNbIm << " NbS=" <<  mNbScale << " NbZ=" <<  mNbZ << " Sz=" << aDF.Sz() << " SzW=" << mSzW << "\n";
        }
         if (WithFile)
            {
                // Read  orthos and masq in  vectors of images
                mSzIms = cPt2di(-1234,6789);
                for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
                {
                     //mVOrtho.push_back(tVecOrtho());
                     mVMasq.push_back(tVecMasq());
                     mVGEOX.push_back(tVecOrtho());
                     mVGEOY.push_back(tVecOrtho());
                     for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                        {
                            //mVOrtho.at(aKIm).push_back(tImOrtho::FromFile(NameOrtho(aKIm,aKScale)));
                            /*if (aKIm==2)
                              {
                                std::cout<<"NAME GEOX :"<<NameGeoX(aKIm,aKScale)<<std::endl;
                                std::cout<<"NAME GEOY :"<<NameGeoY(aKIm,aKScale)<<std::endl;
                              }*/
                            mVGEOX.at(aKIm).push_back(tImOrtho::FromFile(NameGeoX(aKIm,aKScale)));
                            mVGEOY.at(aKIm).push_back(tImOrtho::FromFile(NameGeoY(aKIm,aKScale)));
                            mVMasq.at(aKIm).push_back(tImMasq::FromFile(NameMasq(aKIm,aKScale)));
                            if ((aKIm==0) && (aKScale==0))
                                mSzIms = mVMasq[0][0].DIm().Sz();  // Compute the size at level


                            // check all images have the same at a given level
                            //MMVII_INTERNAL_ASSERT_strong(mVOrtho[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(ortho)");
                            MMVII_INTERNAL_ASSERT_strong(mVMasq[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(masq)");
                        }
                }
                // Create similarity image with good size
                mImSimil = tImSimil(mSzIms);

                mImSimil.DIm().InitCste(1.0);

                if (mWithExtCorr)
                  {
                    std::vector<torch::Tensor> * ProjectEmbeddings = new std::vector<torch::Tensor>;
                      // Inference based correlation
                      // Create Embeddings
                      // Calculate the EMBEDDINGS ONE TIME USING FOWARD OVER THE WHOLE TILEs
                      MMVII_INTERNAL_ASSERT_strong(mArchitecture==TheUnetMlpCubeMatcher, "TheUnetMlpCubeMatcher is the only option for Now");
                      if (mArchitecture==TheUnetMlpCubeMatcher)
                         {
                              namespace FFunc=torch::nn::functional;
                              cPt2di aSzImOrig=mORIGIm.at(0).at(0).DIm().Sz();
                              MMVII_INTERNAL_ASSERT_strong(mVGEOX.size()>1,"No query image found!");

                              int id_im=1;
                              for (int i=0; i<2*(mNbIm-1);i+=2,id_im++) // parcourir par couple de paires pipolaires
                                {
                                // master sec images

                                  ProjectEmbeddings->push_back(FFunc::grid_sample(OrigEmbeddings->at(i).unsqueeze(0),
                                                                                  ToTensorGeo(mVGEOX[0][0],mVGEOY[0][0],aSzImOrig-cPt2di(1,1)).to(device),
                                    F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());

                                  cPt2di aSzImSec=mORIGIm.at(id_im).at(0).DIm().Sz();
                                  ProjectEmbeddings->push_back(FFunc::grid_sample(OrigEmbeddings->at(i+1).unsqueeze(0),
                                                                                  ToTensorGeo(mVGEOX[id_im][0],mVGEOY[id_im][0],aSzImSec-cPt2di(1,1)).to(device),
                                    F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());
                                }
                              ComputeSimilByLearnedCorrelMasterEnhancedMVS(ProjectEmbeddings);
                         }
                      else
                        {
                          MMVII_INTERNAL_ASSERT_strong(false, "TheUnetMlpCubeMatcher is the only option for Now");
                        }
                  }
                else
                  {
                     ComputeSimilByCorrelMaster();
                  }
            }
            else
            {
             MMVII_INTERNAL_ASSERT_strong(false, "MMV1 Orthos projected in the geometry of master image are not created !");
            }

                mImSimil.DIm().ToFile(mPrefixZ+ "_Sim.tif"); // Save similarities
                //mVOrtho.clear();
                mVGEOX.clear();
                mVGEOY.clear();
                mVMasq.clear();
        }
   //mORIG_GEOX.clear();
   //mORIG_GEOY.clear();
   mORIG_EpIm_GEOX.clear();
   mORIG_EpIm_GEOY.clear();
   mEPIPS.clear();
   //mORIG_MASQs.clear();
   mORIG_EpIm_MASQs.clear();
   //std::cout<<"Get Similarity maps "<<std::getchar();
   return EXIT_SUCCESS;
}

int  cAppliMatchMultipleOrtho::GotoHomography()
{
  torch::Device device(mUseCuda ? torch::kCUDA : torch::kCPU);
   // Parse all Z
   // If using a model (CNN) Initialize the predictor
   if (mArchitecture!="")
   {
        InitializePredictor();
   }

   // load Original images
   bool WithFile = ExistFile(NameORIG(0,0));
   bool WithHomography=ExistFile(NameORIGSECEpImGEOX(1,0));
   if (WithFile)
     {
         for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
         {
              mORIGIm.push_back(tVecOrtho());
              for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                 {
                     mORIGIm.at(aKIm).push_back(tImOrtho::FromFile(NameORIG(aKIm,aKScale)));
                 }
         }
      }

   // load image to HOMOGRAPHY maps and back
    //std::vector<tVecOrtho> mORIG_GEOX, mORIG_GEOY;
    std::vector<tVecOrtho> mORIG_EpIm_GEOX, mORIG_EpIm_GEOY, mEPIPS;
    //std::vector<tVecMasq>  mORIG_MASQs;
    std::vector<tVecMasq> mORIG_EpIm_MASQs;

    if (WithHomography)
      {
        for (int akIm=1; akIm<mNbIm ; akIm++ ) // ajouter une image pour le passage aux images pipolaires
          {
            // for each secondary image fille containers twice : one for master eipolar + one for secondary
            // 1. secondary images to homography homography
            //mORIG_GEOX.push_back(tVecOrtho());
            //mORIG_GEOY.push_back(tVecOrtho());
            //mORIG_MASQs.push_back(tVecMasq());
            mEPIPS.push_back(tVecOrtho());
            mORIG_EpIm_GEOX.push_back(tVecOrtho());
            mORIG_EpIm_GEOY.push_back(tVecOrtho());
            mORIG_EpIm_MASQs.push_back(tVecMasq());

            for (int aKScale=0; aKScale<mNbScale; aKScale++)
              {
                // Secondary
                //mORIG_GEOX.at(akIm-1).push_back(tImOrtho::FromFile(NameORIGSECGEOX(akIm,aKScale)));
                //mORIG_GEOY.at(akIm-1).push_back(tImOrtho::FromFile(NameORIGSECGEOY(akIm,aKScale)));
                //mORIG_MASQs.at(akIm-1).push_back(tImMasq::FromFile(NameORIGSECMASQ(akIm,aKScale)));

                mORIG_EpIm_GEOX.at(akIm-1).push_back(tImOrtho::FromFile(NameORIGSECEpImGEOX(akIm,aKScale)));
                mORIG_EpIm_GEOY.at(akIm-1).push_back(tImOrtho::FromFile(NameORIGSECEpImGEOY(akIm,aKScale)));
                mORIG_EpIm_MASQs.at(akIm-1).push_back(tImMasq::FromFile(NameORIGSECEpImMASQ(akIm,aKScale)));
                // Load bare homography warped tiles
                mEPIPS.at(akIm-1).push_back(tImOrtho::FromFile(NameSECEPIP(akIm,0,aKScale)));
              }
          }
      }

   // compute original embeddings
   std::vector<torch::Tensor> * OrigEmbeddings= new std::vector<torch::Tensor>;
   if (WithHomography)
     {
       cPt2di aSzImOrig=mORIGIm.at(0).at(0).DIm().Sz();
       auto MasterFeat=mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mORIGIm.at(0),aSzImOrig);
       OrigEmbeddings->push_back(MasterFeat.squeeze());
       for (int anInd=0;anInd<mNbIm-1;anInd++)
         {
           if (mArchitecture==TheUnetMlpCubeMatcher)
             {
               namespace FFunc=torch::nn::functional;
               cPt2di aSzImEpipSec =mEPIPS.at(anInd).at(0).DIm().Sz();
               auto SecFeat   =mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mEPIPS.at(anInd),aSzImEpipSec);
               OrigEmbeddings->push_back(FFunc::grid_sample(SecFeat.unsqueeze(0),
                                                            ToTensorGeo(mORIG_EpIm_GEOX[anInd][0],mORIG_EpIm_GEOY[anInd][0]).to(device),
              F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());
               if (0)
                 {
                   // Save some images rectified back to the original image
                   if (anInd==0)
                     {
                        auto aSecImage =ComputeEpipolarImage(mEPIPS.at(anInd).at(0),mORIG_EpIm_GEOX[anInd][0],mORIG_EpIm_GEOY[anInd][0]);

                        // Write images
                        //Tensor2Tiff(aMasterImage,"./MASTER_IM.tif");
                        Tensor2Tiff(aSecImage,"./SEC_IM.tif");
                     }
                 }
             }
           else
             {
               MMVII_INTERNAL_ASSERT_strong(false,"DM4MatchMultipleOrtho, Model architecture not taken into account !");
             }
         }
       std::cout<<"COMPUTED EMBEDDINGS =====>   ==============    "<<OrigEmbeddings->size()<<std::endl;
     }

   // Load Displacement grids in X and Y directions to apply to each embedding
   for (int aZ=0 ; aZ<mNbZ ; aZ++)
   {
        mPrefixZ =  mPrefixGlob + "_Z" + ToStr(aZ);

        bool NoFile = ExistFile(mPrefixZ+ "_NoData");  // If no data in masq thie file exist
        WithFile = ExistFile(NameMasq(0,0));
        // A little check
        MMVII_INTERNAL_ASSERT_strong(NoFile!=WithFile,"DM4MatchMultipleOrtho, incoherence file");
        if ((aZ==0)  && (true))
        {
             cDataFileIm2D aDF = cDataFileIm2D::Create(NameMasq(0,0),false);
             StdOut() << " * NbI=" << mNbIm << " NbS=" <<  mNbScale << " NbZ=" <<  mNbZ << " Sz=" << aDF.Sz() << " SzW=" << mSzW << "\n";
        }

        if (WithFile)
          {
                // Read  orthos and masq in  vectors of images
                mSzIms = cPt2di(-1234,6789);
                for (int aKIm=0 ; aKIm<mNbIm ; aKIm++)
                {
                     //mVOrtho.push_back(tVecOrtho());
                     mVMasq.push_back(tVecMasq());
                     mVGEOX.push_back(tVecOrtho());
                     mVGEOY.push_back(tVecOrtho());
                     for (int aKScale=0 ; aKScale<mNbScale ; aKScale++)
                        {
                            //mVOrtho.at(aKIm).push_back(tImOrtho::FromFile(NameOrtho(aKIm,aKScale)));
                            /*if (aKIm==2)
                              {
                                std::cout<<"NAME GEOX :"<<NameGeoX(aKIm,aKScale)<<std::endl;
                                std::cout<<"NAME GEOY :"<<NameGeoY(aKIm,aKScale)<<std::endl;
                              }*/
                            mVGEOX.at(aKIm).push_back(tImOrtho::FromFile(NameGeoX(aKIm,aKScale)));
                            mVGEOY.at(aKIm).push_back(tImOrtho::FromFile(NameGeoY(aKIm,aKScale)));
                            mVMasq.at(aKIm).push_back(tImMasq::FromFile(NameMasq(aKIm,aKScale)));
                            if ((aKIm==0) && (aKScale==0))
                                mSzIms = mVMasq[0][0].DIm().Sz();  // Compute the size at level

                            // check all images have the same size at a given level
                            //MMVII_INTERNAL_ASSERT_strong(mVOrtho[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(ortho)");
                            MMVII_INTERNAL_ASSERT_strong(mVMasq[aKIm][aKScale].DIm().Sz()==mSzIms,"DM4O : variable size(masq)");
                        }
                }
                // Create similarity image with good size
                mImSimil = tImSimil(mSzIms);
                //std::cout<<"mSzIms   ::::::  "<<mSzIms<<std::endl;

                mImSimil.DIm().InitCste(1.0);

                if (mWithExtCorr)
                  {
                    std::vector<torch::Tensor> * ProjectEmbeddings = new std::vector<torch::Tensor>;
                      // Inference based correlation
                      // Create Embeddings
                      // Calculate the EMBEDDINGS ONE TIME USING FOWARD OVER THE WHOLE TILEs
                      MMVII_INTERNAL_ASSERT_strong(mArchitecture==TheUnetMlpCubeMatcher, "TheUnetMlpCubeMatcher is the only option for Now");
                      if (mArchitecture==TheUnetMlpCubeMatcher)
                         {
                          namespace FFunc=torch::nn::functional;
                          cPt2di aSzImOrig;
                          // project all except the master (i=0) embedding
                          MMVII_INTERNAL_ASSERT_strong(mVGEOX.size()>1,"No query image found!");
                          //ProjectEmbeddings->push_back(OrigEmbeddings->at(0));
                          //std::cout<<"##########################  "<<0<<"  "<<ProjectEmbeddings->at(0).sizes()<<"  ###########################"<<std::endl;
                          for (int i=0; i<mNbIm;i++)
                            {
                              aSzImOrig=mORIGIm.at(i).at(0).DIm().Sz();
                              //ProjectEmbeddings->push_back(this->InterpolateFeatMap(OrigEmbeddings->at(i),mVGEOX[i][0],mVGEOY[i][0]));

                              ProjectEmbeddings->push_back(FFunc::grid_sample(OrigEmbeddings->at(i).unsqueeze(0),
                                                                              ToTensorGeo(mVGEOX[i][0],mVGEOY[i][0],aSzImOrig-cPt2di(1,1)).to(device),
                                FFunc::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true)).squeeze());

                              //auto OrthoEmbedding=mCNNPredictor->PredictUnetFeaturesOnly(mMSAFF,mVOrtho.at(i),aSzIm);
                              //auto COSINE=at::cosine_similarity(OrthoEmbedding,ProjectEmbeddings->at(i),0).squeeze();
                              //std::cout<<" CORRELATION CHECK >>>  "<<at::mean(COSINE)<<std::endl;
                              //std::cout<<"##########################  "<<i<<"  "<<ProjectEmbeddings->at(i).sizes()<<"  ###########################"<<std::endl;
                            }
                          //std::cout<<"PROJECTED EMBEDDINGS     ===================>   "<<ProjectEmbeddings->size()<<std::endl;
                              ComputeSimilByLearnedCorrelMasterEnhanced(ProjectEmbeddings);
                         }
                      else
                        {
                          MMVII_INTERNAL_ASSERT_strong(false, "TheUnetMlpCubeMatcher is the only option for Now");
                        }


                  }
                else
                  {
                     ComputeSimilByCorrelMaster();
                  }
            }
            else
            {
             MMVII_INTERNAL_ASSERT_strong(false, "MMV1 Orthos projected in the geometry of master image are not created !");
            }

                mImSimil.DIm().ToFile(mPrefixZ+ "_Sim.tif"); // Save similarities
                //mVOrtho.clear();
                mVGEOX.clear();
                mVGEOY.clear();
                mVMasq.clear();
        }
   //mORIG_GEOX.clear();
   //mORIG_GEOY.clear();
   mORIG_EpIm_GEOX.clear();
   mORIG_EpIm_GEOY.clear();
   mEPIPS.clear();
   //mORIG_MASQs.clear();
   mORIG_EpIm_MASQs.clear();
   return EXIT_SUCCESS;
}

int cAppliMatchMultipleOrtho::Exe()
{
  int aResol=std::atoi(mResol.c_str());
  if (aResol==1)
    {
      return GotoEpipolar();
      //return GotoHomography();
      //return ExeProjectOrigEmbeddings();
    }
  else
    {
      //return GotoHomography();
      return GotoEpipolar();
      //return ExeProjectOrigEmbeddings();
    }
}

};

/* =============================================== */
/*                                                 */
/*                       ::                        */
/*                                                 */
/* =============================================== */
using namespace  cNS_MatchMultipleOrtho;

tMMVII_UnikPApli Alloc_MatchMultipleOrtho(const std::vector<std::string> &  aVArgs,const cSpecMMVII_Appli & aSpec)
{
   return tMMVII_UnikPApli(new cAppliMatchMultipleOrtho(aVArgs,aSpec));
}

cSpecMMVII_Appli  TheSpecMatchMultipleOrtho
(
     "DM4MatchMultipleOrtho",
      Alloc_MatchMultipleOrtho,
      "Compute similarite of overlapping ortho images",
      {eApF::Match},
      {eApDT::Image},
      {eApDT::Image},
      __FILE__
);



};
