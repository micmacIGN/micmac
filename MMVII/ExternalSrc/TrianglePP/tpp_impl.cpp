/**
  @file  tpp_impl.cpp
  @brief The implementation of the Delaunay class and iterators of the Triangle++ wrapper

  The Delaunay class and its iterators wrap the J.R. Shevchuk's original C code of Triangle package (aka TriLib).

  @author  Marek Krajewski (mrkkrj), www.ib-krajewski.de / others (@see tpp_interface.hpp)
*/

// configuaration of the Triangle.h (i.e. TriLib's code):
#define NO_TIMER
#define DREDUCED
#define ANSI_DECLARATORS
#define TRILIBRARY
#define TRILIB_EXIT_BY_EXCEPTION
#define TRIFILES_OUTPUT_SUPPORT
#define TRIFILES_READ_SUPPORT
// #define CDT_ONLY // no, we want all algorithms!

#ifndef TRIANGLE_NO_TRILIB_SELFCHECK
// self-debug for TriLib - it will check and throw exceptions instead of crashing/looping endelessly!
#define SELF_CHECK
#endif

#ifndef _WIN64
// the MS x64 compilers do not use FPU (as SSE is the default) thus no extended precision problems!
#define CPU86
#endif

#ifndef _WIN32
#define LINUX
#undef CPU86
#endif

// trace support:
// #define TRIANGLE_DBG_TO_FILE 1
// #undef TRIANGLE_DBG_TO_FILE // TEST:::

#include "tpp_trace.hpp"

// 1. wrapped library (TriLib)
#include "triangle_impl.hpp"

// 2. the wrapper itself (TrianglePP)
#include "tpp_interface.hpp"

#include <iostream>
#include <sstream>
#include <algorithm>

// helper macros
#include "tpp_triangle_macros.hpp"

// custom specialization of std::hash for Delaunay::Points
namespace std
{
	template <>
	struct hash<tpp::Delaunay::Point>
	{
		std::size_t operator()(const tpp::Delaunay::Point &p) const
		{
			std::size_t h1 = std::hash<double>{}(p[0]);
			std::size_t h2 = std::hash<double>{}(p[1]);
			return h1 ^ (h2 << 1); // combine hashes
		}
	};
}

namespace tpp
{

	// trace support
	FILE *g_debugFile = nullptr; // OPEN TODO:: decouple, move to separate file!
	std::string g_debugFileName; // dito

	// impl. constant
	const char *c_trppFileComment = "\n# Generated by Triangle++";

	// public methods

	Delaunay::Delaunay(const std::vector<Point> &points, bool enableMeshIndexing)
		: m_triangleWrap(nullptr),
		  m_in(nullptr),
		  m_pmesh(nullptr),
		  m_pbehavior(nullptr),
		  m_vorout(nullptr),
		  m_triAlgorithm(DivideConquer),
		  m_minAngle(0.0f),
		  m_maxArea(0.0f),
		  m_convexHullWithSegments(false),
		  m_extraVertexAttr(enableMeshIndexing),
		  m_triangulated(false)
	{
		m_pointList.assign(points.begin(), points.end());
	}

	Delaunay::~Delaunay()
	{
		freeTriangleDataStructs();
	}

	void Delaunay::Triangulate(bool quality, DebugOutputLevel traceLvl)
	{
		std::string options = "nz"; // n: need neighbors, z: index from 0

		setQualityOptions(options, quality);
		setDebugLevelOption(options, traceLvl);

		invokeTriLib(options);
	}

	void Delaunay::TriangulateConf(bool quality, DebugOutputLevel traceLvl)
	{
		std::string options = "nz"; // n: need neighbors, z: index from 0

		setQualityOptions(options, quality);
		options.append("D"); // conforming Delaunay!
		setDebugLevelOption(options, traceLvl);

		invokeTriLib(options);
	}

	void Delaunay::Tesselate(bool useConformingDelaunay, DebugOutputLevel traceLvl)
	{
		std::string options = "nz"; // n: need neighbors, z: index from 0
		setDebugLevelOption(options, traceLvl);

		// "If the triangulated domain is"
		//"  convex and has no holes, you can use -D switch to force Triangle to"
		//"  construct a conforming Delaunay triangulation instead of a CCDT, so the"
		//"  Voronoi diagram will be valid."

		// options.append("D"); // Voronoi precondition ??? not really!!!

		if (useConformingDelaunay)
		{
			options.append("D");
		}
		options.append("v"); // Voronoi

		invokeTriLib(options);

		// now use the triangulation for a Voronoi diagram
		TP_MESH_BEHAVIOR_WRAP();

		// OPEN TODO::: check those preconditions??
		if (tpmesh->holes != 0)
		{
			/* ............ */
		}

		m_vorout = new triangulateio;
		TP_VOROUT();

		tpvorout->numberofpoints = tpmesh->triangles.items;
		tpvorout->numberofpointattributes = tpmesh->nextras;
		tpvorout->numberofedges = tpmesh->edges;

		tpvorout->pointlist = nullptr;
		tpvorout->pointattributelist = nullptr;
		tpvorout->pointmarkerlist = nullptr;
		tpvorout->numberofsegments = 0;
		tpvorout->numberofholes = 0;
		tpvorout->numberofregions = 0;
		tpvorout->regionlist = nullptr;
		tpvorout->edgelist = nullptr;
		tpvorout->edgemarkerlist = nullptr;
		tpvorout->normlist = nullptr;

		pTriangleWrap->writevoronoi(
			tpmesh, tpbehavior,
			&tpvorout->pointlist, &tpvorout->pointattributelist,
			&tpvorout->pointmarkerlist, &tpvorout->edgelist,
			&tpvorout->edgemarkerlist, &tpvorout->normlist);
	}

	bool Delaunay::checkConstraints(bool &possible) const
	{
		//"     If the minimum angle is 28.6"
		//"        degrees or smaller, Triangle is mathematically guaranteed to"
		//"        terminate (assuming infinite precision arithmetic--Triangle may"
		//"        fail to terminate if you run out of precision).  In practice,"
		//"        Triangle often succeeds for minimum angles up to 34 degrees.  For"
		//"        some meshes, however, you might need to reduce the minimum angle to"
		//"        avoid problems associated with insufficient floating-point"
		//"        precision."
		if (m_minAngle <= 28.6f)
		{
			return true;
		}
		else
		{
			possible = (m_minAngle <= 34.0f);
			return false;
		}
	}

	bool Delaunay::checkConstraintsOpt(bool relaxed) const
	{
		bool possible = false;
		bool ret = checkConstraints(possible);

		if (!ret && relaxed)
		{
			return possible;
		}
		else
		{
			return ret;
		}
	}

	void Delaunay::getMinAngleBoundaries(float &guaranteed, float &possible)
	{
		// see above:
		guaranteed = 28.6f;
		possible = 34.0f;
	}

	void Delaunay::setQualityConstraints(float angle, float area)
	{
		setMinAngle(angle);
		setMaxArea(area);
	}

	bool Delaunay::setSegmentConstraint(const std::vector<Point> &segments)
	{
		m_segmentList.clear();
		m_segmentList.reserve(segments.size());

		// OPEN TODO::: optimize - unquadrat it...
		for (size_t i = 0; i < segments.size(); ++i)
		{
			const std::vector<Point>::iterator it = std::find(m_pointList.begin(), m_pointList.end(), segments[i]);
			if (it == m_pointList.end())
			{
				m_segmentList.clear();
				return false;
			}
			else
			{
				m_segmentList.push_back(std::distance(m_pointList.begin(), it)); // OPEN TODO:: warning !!!
			}
		}

		// OPEN TODO::: check for intersections ???
		//  - seems to be not needed, re-read what the documentiation of TriLibrary says!!!!

		return true;
	}

	bool Delaunay::setSegmentConstraint(const std::vector<int> &segmentPointIndexes, DebugOutputLevel traceLvl)
	{
		m_segmentList.clear();
		m_segmentList.reserve(segmentPointIndexes.size());

		for (size_t i = 0; i < segmentPointIndexes.size(); ++i)
		{
			const int &pointIdx = segmentPointIndexes[i];
			if (pointIdx < 0 ||
				unsigned(pointIdx) >= m_pointList.size())
			{
				m_segmentList.clear();
				return false;
			}
			else
			{
				m_segmentList.push_back(pointIdx);
			}
		}

		// OPEN TODO::: check for intersections ???
		//  - seems to be not needed (???), re-read what the documentiation of TriLibrary says!!!!

		// sanitize inputs
		std::unordered_map<int, int> duplicates = checkForDuplicatePoints();

		if (!duplicates.empty())
		{
			sanitizeInputData(duplicates, traceLvl);
		}

		return true;
	}

	void Delaunay::enableMeshIndexGeneration()
	{
		m_extraVertexAttr = true;
	}

	void Delaunay::setAlgorithm(AlgorithmType alg)
	{
		m_triAlgorithm = alg;
	}

	void Delaunay::useConvexHullWithSegments(bool useConvexHull)
	{
#if 0
    // --> Yejneshwar commented on 26 Feb 22
    //Hi,
    //    Thank you for this implementation.
    //    could you please add support for the D tag ?
    //    i.e.remove concavities
    //
    //    EDIT :
    //    I have fixed the issue, will be submitting a pull request soon.
    //    Support for it existed but internally the "c" tag would still be added which caused the concavities to not be removed.

    TriangulateConf(options); //created a new function just for the -D tag, because the -c tag doesn't remove concavities with a boundary defined through the segment list.
#endif

		m_convexHullWithSegments = useConvexHull; // with/without convex hull (credits Yejneshwar!)
	}

	bool Delaunay::setHolesConstraint(const std::vector<Point> &holes)
	{
		m_holesList = holes;

		// OPEN TODO::: check the intersection constraints ... ???

		return true;
	}

	bool Delaunay::setRegionsConstraint(const std::vector<Point> &regions, const std::vector<float> &areas)
	{
		if (regions.size() != areas.size())
		{
			return false;
		}

		m_regionsConstrList.clear();

		for (size_t i = 0; i < regions.size(); ++i)
		{
			auto &r = regions[i];
			double arr[] = {r[0], r[1], areas[i], areas[i]}; // if no region attr - copy the area therein
			m_regionsConstrList.emplace_back(Point4(arr));
		}

		return true;
	}

	bool Delaunay::setRegionsConstraint(const std::vector<Point4> &regionConstr)
	{
		m_regionsConstrList = regionConstr;
		return true; // OPEN TODO::: check something?
	}

	void Delaunay::writeoff(std::string &fname)
	{
		if (!m_triangulated)
		{
			std::cerr << "ERROR: Write called before triangulation!";
			throw std::runtime_error("Write called before triangulation");
		}

		TP_MESH_BEHAVIOR_WRAP();

		char *pfname = new char[fname.size() + 1];
		strcpy(pfname, fname.c_str());

		pTriangleWrap->writeoff(tpmesh, tpbehavior, pfname, 0, nullptr);
		delete[] pfname;
	}

	bool Delaunay::savePoints(const std::string &filePath)
	{
		if (!m_triangulated)
		{
			struct triangulateio input;
			triangulateio *pin = (struct triangulateio *)&input;

			initTriangleInputData(pin, m_pointList);

			if (!m_triangleWrap)
			{
				Assert(!m_pmesh && !m_pbehavior, "");
				initTriangleDataForPoints();
			}

			TP_MESH_BEHAVIOR_WRAP();

			pTriangleWrap->transfernodes(
				tpmesh, tpbehavior, pin->pointlist,
				pin->pointattributelist,
				pin->pointmarkerlist, pin->numberofpoints,
				pin->numberofpointattributes);
		}

		TP_MESH_BEHAVIOR_WRAP();
		const char *comments[] = {c_trppFileComment};

		pTriangleWrap->writenodes2file(tpmesh, tpbehavior, const_cast<char *>(filePath.c_str()),
									   sizeof(comments) / sizeof(const char *),
									   const_cast<char **>(comments));
		return true;
	}

	bool Delaunay::saveSegments(const std::string &filePath)
	{
		if (m_holesList.empty())
		{
			if (!m_triangulated)
			{
				// must triangulate for writenodes2file() etc to work
				Triangulate();
			}
		}
		else
		{
			// re-triangualte w/o holes (as not to infect segments!!!)
			auto holes = m_holesList;
			m_holesList.clear();

			Triangulate();

			m_holesList = holes;

			TP_INPUT();
			pin->numberofholes = (int)m_holesList.size();
			pin->holelist = static_cast<double *>((void *)(&m_holesList[0]));
		}

		TP_MESH_BEHAVIOR_WRAP();

		// first write nodes
		char *polyfileName = const_cast<char *>(filePath.c_str());
		pTriangleWrap->writenodes2file(tpmesh, tpbehavior, polyfileName, 0, nullptr);

		// OPEN TODO:::: regions support???
		int numberofregions = 0;
		double *regionlist = nullptr;

		// holes?
		int numberofholes = 0;
		double *holelist = nullptr;

		if (!m_holesList.empty())
		{
			numberofholes = (int)m_holesList.size();
			holelist = static_cast<double *>((void *)(&m_holesList[0]));
		}

		bool append = true; // write into a single file!
		const char *comments[] = {c_trppFileComment};

		pTriangleWrap->writepoly2file(tpmesh, tpbehavior, polyfileName,
									  holelist, numberofholes, regionlist, numberofregions,
									  append,
									  sizeof(comments) / sizeof(const char *),
									  const_cast<char **>(comments));

		return true;
	}

	bool Delaunay::readPoints(const std::string &filePath, std::vector<Delaunay::Point> &points)
	{
		if (!m_triangleWrap)
		{
			Assert(!m_pmesh && !m_pbehavior, "");
			initTriangleDataForPoints();
		}

		TP_MESH_BEHAVIOR_WRAP();

		tpbehavior->poly = 0; // poly file not provided!
		tpbehavior->usesegments = 0;
		FILE *polyfile = nullptr;
		char *polyfileName = nullptr; // no poly file!

		pTriangleWrap->readnodes(tpmesh, tpbehavior, const_cast<char *>(filePath.c_str()), polyfileName, &polyfile);

		// read points from the mesh data
		readPointsFromMesh(m_pointList);

		points = m_pointList; // OPEN TODO::: make optional parameter?????
		return true;
	}

	bool Delaunay::readSegments(
		const std::string &filePath,
		std::vector<Delaunay::Point> &points,
		std::vector<int> &segmentEndpoints,
		std::vector<Delaunay::Point> &holeMarkers,
		std::vector<Point4> &regionConstr,
		int *duplicatePointCount,
		DebugOutputLevel traceLvl)
	{
		if (!m_triangleWrap)
		{
			Assert(!m_pmesh && !m_pbehavior, "");
			initTriangleDataForPoints();
		}

		TP_MESH_BEHAVIOR_WRAP();

		tpbehavior->poly = 1; // poly file provided!
		tpbehavior->usesegments = 1;

		tpmesh->steinerleft = tpbehavior->steiner;

		FILE *polyfile = nullptr;
		char *polyfileName = const_cast<char *>(filePath.c_str());
		pTriangleWrap->readnodes(tpmesh, tpbehavior, nullptr, polyfileName, &polyfile);

		// get points from the mesh data
		readPointsFromMesh(m_pointList);
		points = m_pointList; // OPEN TODO::: make it optional param????

		auto duplicates = checkForDuplicatePoints();
		if (!duplicates.empty())
		{
			// read file directly
			//  - Trilib's code doesn't support duplicate points!
			if (!readSegmentsFromFile(polyfileName, polyfile, m_segmentList))
			{
				fclose(polyfile);
				return false;
			}

			// rebase to start with 0
			if (tpbehavior->firstnumber != 0)
			{
				for (auto &index : m_segmentList)
				{
					index -= tpbehavior->firstnumber;
					Assert(index >= 0, "");
				}
			}

			sanitizeInputData(duplicates, traceLvl);

			points = m_pointList;			  // OPEN TODO::: make it optional param????
			segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
		}
		else
		{
#if 0 // OPEN TODO::: not working (on Windows!), mysterious file reading problems!!! :-O
	  // triangulate to ensure formskeleton() will read segments!
        tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

        // Ensure that no vertex can be mistaken for a triangular bounding box
        // vertex in insertvertex()!
        tpmesh->infvertex1 = nullptr;
        tpmesh->infvertex2 = nullptr;
        tpmesh->infvertex3 = nullptr;

        tpmesh->checksegments = 1;

        // no holes yet:
        tpmesh->holes = 0;
        tpmesh->regions = 0;

        pTriangleWrap->formskeleton4file(tpmesh, tpbehavior, polyfile, polyfileName);

        // get segments from the mesh data
        readSegmentsFromMesh(m_segmentList);
#else
			if (!readSegmentsFromFile(polyfileName, polyfile, m_segmentList))
			{
				fclose(polyfile);
				return false;
			}
#endif

			// rebase to start with 0
			if (tpbehavior->firstnumber != 0)
			{
				for (auto &index : m_segmentList)
				{
					index -= tpbehavior->firstnumber;
				}
			}

			segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
		}

		if (duplicatePointCount)
		{
			*duplicatePointCount = duplicates.size();
		}

		// get hole marker points
		readHolesFromFile(polyfileName, polyfile, m_holesList, m_regionsConstrList);

		holeMarkers = m_holesList;			// OPEN TODO::: make it optional param????
		regionConstr = m_regionsConstrList; // OPEN TODO::: make it optional param????

		// ready
		fclose(polyfile);
		return true;
	}

	void Delaunay::enableFileIOTrace(bool enable)
	{
		if (enable)
		{
			INIT_TRACE("tpp_fileIO.out.txt");
			TRACE("File IO trace: \n");
		}
		else
		{
			END_TRACE("tpp_fileIO.out.txt");
		}
	}

	int Delaunay::edgeCount() const
	{
		return TP_MESH_PTR()->edges;
	}

	int Delaunay::triangleCount() const
	{
		return TP_MESH_PTR()->triangles.items;
	}

	int Delaunay::verticeCount() const
	{
		TP_MESH_BEHAVIOR();
		int outvertices;

		if (tpbehavior->jettison)
		{
			outvertices = tpmesh->vertices.items - tpmesh->undeads;
		}
		else
		{
			outvertices = tpmesh->vertices.items;
		}

		return outvertices;
	}

	int Delaunay::hullSize() const
	{
		return TP_MESH_PTR()->hullsize;
	}

	int Delaunay::voronoiEdgeCount() const
	{
		TP_VOROUT();

		return !tpvorout ? 0 : tpvorout->numberofedges;
	}

	int Delaunay::voronoiPointCount() const
	{
		TP_VOROUT();

		return !tpvorout ? 0 : tpvorout->numberofpoints;
	}

	int Delaunay::holeCount() const
	{
		return TP_MESH_PTR()->holes;
	}

	bool Delaunay::hasTriangulation() const
	{
		return m_triangulated;
	}

	FaceIterator Delaunay::fbegin()
	{
		return FaceIterator(this);
	}

	FaceIterator Delaunay::fend()
	{
		FaceIterator fit;
		fit.floop.tri = (double ***)nullptr;
		return fit;
	}

	FacesList Delaunay::faces()
	{
		return FacesList(this);
	};

	FaceIterator FacesList::begin()
	{
		return m_delaunay->fbegin();
	}

	FaceIterator FacesList::end()
	{
		return m_delaunay->fend();
	}

	VertexIterator Delaunay::vbegin()
	{
		return VertexIterator(this);
	}

	VertexIterator Delaunay::vend()
	{
		VertexIterator vit;
		vit.vloop = ((Triwrap::vertex) nullptr);
		return vit;
	}

	VertexList Delaunay::vertices()
	{
		return VertexList(this);
	};

	VertexList::VertexListIterator VertexList::begin()
	{
		return m_delaunay->vbegin();
	}

	VertexList::VertexListIterator VertexList::end()
	{
		return m_delaunay->vend();
	}

	VoronoiVertexIterator Delaunay::vvbegin()
	{
		return VoronoiVertexIterator(this);
	}

	VoronoiVertexIterator Delaunay::vvend()
	{
		VoronoiVertexIterator vvit;

		vvit.vvloop = nullptr;
		vvit.vvindex = 0;
		vvit.vvcount = 0;
		vvit.m_delaunay = nullptr;

		return vvit;
	}

	VoronoiEdgeIterator Delaunay::vebegin()
	{
		return VoronoiEdgeIterator(this);
	}

	VoronoiEdgeIterator Delaunay::veend()
	{
		VoronoiEdgeIterator veit;

		veit.veloop = nullptr;
		veit.veindex = 0;
		veit.vecount = 0;
		veit.m_delaunay = nullptr;

		return veit;
	}

	void Delaunay::getMinMaxPoints(double &minX, double &minY, double &maxX, double &maxY) const
	{
		TP_MESH();

		minX = tpmesh->xmin;
		minY = tpmesh->ymin;
		maxX = tpmesh->xmax;
		maxY = tpmesh->ymax;
	}

	const Delaunay::Point &Delaunay::pointAtVertexId(int i) const
	{
		Assert((i >= 0) && (unsigned(i) < m_pointList.size()), "Point index out of bounds!");

		return m_pointList[i];
	}

	TriangulationMesh Delaunay::mesh()
	{
		return TriangulationMesh(this);
	}

	bool Delaunay::OrderPoints::operator()(const Point &lhs, const Point &rhs) const
	{
		// first sort on X, then on Y coordinates!

		if (lhs[0] < rhs[0])
		{
			return true;
		}

		if (lhs[0] == rhs[0] && lhs[1] < rhs[1])
		{
			return true;
		}

		return false;
	}

	// private methods

	void Delaunay::invokeTriLib(std::string &triswitches)
	{
		INIT_TRACE("triangle.out.txt");
		TRACE("Triangulate ->");

		if (m_triangulated)
		{
			freeTriangleDataStructs();
		}

		m_in = new triangulateio;
		TP_INPUT();

		initTriangleInputData(pin, m_pointList);

		if (!m_segmentList.empty()) // OPEN:: a separate option to enable segment constraitns???
		{
			pin->numberofsegments = (int)m_segmentList.size() / 2;
			pin->segmentlist = m_segmentList.data();
			pin->segmentmarkerlist = nullptr;

			triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
			triswitches.append("B"); // but no boundary info at the moment!

			if (m_convexHullWithSegments)
			{
				triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boudnaries in carveholes())
										 //   --> Note: refining not supported yet!
										 // If you are refining a mesh, this switch works differently; it generates the set of
										 // boundary edges of the mesh, including boundaries of holes.
			}
		}

		if (!m_holesList.empty())
		{
			pin->numberofholes = (int)m_holesList.size();
			pin->holelist = static_cast<double *>((void *)(&m_holesList[0]));

			if (m_segmentList.empty())
			{
				triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
				triswitches.append("B"); // but no boundary info at the moment!

				if (m_convexHullWithSegments)
				{
					triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boundaries in carveholes())
				}
			}
		}

		if (!m_regionsConstrList.empty() && triswitches.find("q") != std::string::npos)
		{
			pin->numberofregions = (int)m_regionsConstrList.size();
			pin->regionlist = static_cast<double *>((void *)(&m_regionsConstrList[0]));
			triswitches.append("a");
		}

		TRACE2s(" -- switches:", triswitches.c_str());

		// parse the options:
		triswitches.push_back('\0');
		char *pTriswitches = &triswitches[0];

		m_pmesh = new Triwrap::__pmesh;
		m_pbehavior = new Triwrap::__pbehavior;
		m_triangleWrap = new Triwrap;

		TP_MESH_BEHAVIOR_WRAP();

		pTriangleWrap->parsecommandline(1, &pTriswitches, tpbehavior);

		// initialize data structs
		pTriangleWrap->triangleinit(tpmesh);
		tpmesh->steinerleft = tpbehavior->steiner;

		pTriangleWrap->transfernodes(
			tpmesh, tpbehavior, pin->pointlist,
			pin->pointattributelist,
			pin->pointmarkerlist, pin->numberofpoints,
			pin->numberofpointattributes);

		// MAIN work: triangulate!
		tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

		// OPEN TODO::
		//    if(concave hull) - compute concave hull with the chi-algorithm,
		//                     - use it as segments in formskeleton()!!

		// Ensure that no vertex can be mistaken for a triangular bounding box
		// vertex in insertvertex()!
		tpmesh->infvertex1 = nullptr;
		tpmesh->infvertex2 = nullptr;
		tpmesh->infvertex3 = nullptr;

		// support for the "-q" option
		if (tpbehavior->usesegments && (tpmesh->triangles.items > 0))
		{
			tpmesh->checksegments = 1;

			if (!tpbehavior->refine)
			{
				// Insert PSLG segments and/or convex hull segments.
				pTriangleWrap->formskeleton(tpmesh, tpbehavior, pin->segmentlist,
											pin->segmentmarkerlist, pin->numberofsegments);
			}
		}

		// carve out the holes before enforcing quality constr!
		if (tpbehavior->poly && (tpmesh->triangles.items > 0))
		{
			tpmesh->holes = pin->numberofholes;
			double *holelist = pin->holelist;

			tpmesh->regions = pin->numberofregions;
			double *regionlist = pin->regionlist;

			if (!tpbehavior->refine)
			{
				// Carve out holes and concavities.
				pTriangleWrap->carveholes(tpmesh, tpbehavior, holelist, tpmesh->holes, regionlist, tpmesh->regions);
			}
		}

		if (tpbehavior->quality && (tpmesh->triangles.items > 0))
		{
			// Enforce angle and area constraints
			pTriangleWrap->enforcequality(tpmesh, tpbehavior);
		}

		// Calculate the number of edges.
		tpmesh->edges = (3l * tpmesh->triangles.items + tpmesh->hullsize) / 2l;

		pTriangleWrap->numbernodes(tpmesh, tpbehavior);
		TRACE2i("<- Triangulate: triangles= ", tpmesh->triangles.items);

		m_triangulated = true;
		END_TRACE("triangle.out.txt");
	}

	void Delaunay::setDebugLevelOption(std::string &options, DebugOutputLevel traceLvl)
	{
		switch (traceLvl)
		{
		case None:
			options.append("Q"); // Q: no trace, no debug
			break;
		case Info:
			options.append("V"); // basic trace & debug
			break;
		case Vertex:
			options.append("VV"); // detailed trace & debug
			break;
		case Debug:
			options.append("VVVV"); // much, much more - too much?
			break;
		default:
			Assert(false, "unknown trace level");
		}
	}

	void Delaunay::setQualityOptions(std::string &options, bool quality)
	{
		if (quality)
		{
			auto formatFloatConstraint = [](float f)
			{
				std::ostringstream ss;
				ss << f;
				return ss.str();
			};

			options.append("q");

			if (m_minAngle > 0)
			{
				options.append(formatFloatConstraint(m_minAngle));
			}

			if (m_maxArea > 0)
			{
				options.append("a" + formatFloatConstraint(m_maxArea));
			}
		}

		// TEST::: algorithm
		// OPEN TODO::: own method???
		//  -- or ditch the workaround with the option string altogether???

		switch (m_triAlgorithm)
		{
		case Incremental:
			options.append("i");
			break;

		case Sweepline:
			options.append("F");
			break;

		case DivideConquer:
			// it's the default!
			break;

		default:
			Assert(false, "unknown algorithm type");
		}
	}

	void Delaunay::freeTriangleDataStructs()
	{
		if (m_in == nullptr && m_vorout == nullptr &&
			m_triangleWrap == nullptr && m_pmesh == nullptr &&
			m_pbehavior == nullptr)
		{
			return; // already freed!
		}

		// struct triangulateio* pin = (struct triangulateio*) m_in;

		TP_MESH_BEHAVIOR_WRAP();
		TP_INPUT();
		TP_VOROUT();

		pTriangleWrap->triangledeinit(tpmesh, tpbehavior);

		delete tpmesh;
		delete tpbehavior;
		delete pin;
		delete tpvorout;
		delete pTriangleWrap;

		m_in = nullptr;
		m_vorout = nullptr;
		m_triangleWrap = nullptr;
		m_pmesh = nullptr;
		m_pbehavior = nullptr;
	}

	void Delaunay::initTriangleDataForPoints()
	{
		Assert(!m_triangleWrap && !m_pmesh && !m_pbehavior, "Expected empty instance!");

		m_triangleWrap = new Triwrap;
		m_pmesh = new Triwrap::__pmesh;
		m_pbehavior = new Triwrap::__pbehavior;

		TP_MESH_BEHAVIOR_WRAP();

		*tpmesh = {}; // OPEN TODO::: .............. {} too big for the stack, warning by VisualStudio!?
		*tpbehavior = {};

		// nonzero defaults:
		tpbehavior->firstnumber = 1;
		tpbehavior->dwyer = 1;
		tpbehavior->steiner = -1;
		tpbehavior->order = 1;
		tpbehavior->maxarea = -1.0;
		tpbehavior->quiet = 1;

		pTriangleWrap->triangleinit(tpmesh);
	}

	void Delaunay::initTriangleInputData(triangulateio *pin, const std::vector<Point> &points) /*const*/
	{
		pin->numberofpoints = (int)points.size();
		pin->numberofpointattributes = m_extraVertexAttr ? 1 : 0;
		pin->pointlist = static_cast<double *>((void *)(&points[0]));

		if (m_extraVertexAttr)
		{
			m_defaultExtraAttrs.clear();
			m_defaultExtraAttrs.insert(m_defaultExtraAttrs.begin(), points.size(), -1.0);

			pin->pointattributelist = static_cast<double *>((void *)(&m_defaultExtraAttrs[0]));
		}
		else
		{
			pin->pointattributelist = nullptr;
		}

		pin->pointmarkerlist = nullptr;
		pin->numberofsegments = 0;
		pin->numberofholes = 0;
		pin->numberofregions = 0;
		pin->regionlist = nullptr;
	}

	void Delaunay::sanitizeInputData(std::unordered_map<int, int> duplicatePointsMap, DebugOutputLevel traceLvl)
	{
		// don't use duplicated points in segment definitions
		//  - replace with "originals"

		if (traceLvl != None)
			std::cout << "Warning: " << duplicatePointsMap.size() << " duplicate vertexes found - trying to sanitize input data!" << std::endl;

		for (size_t i = 0; i < m_segmentList.size(); ++i)
		{
			auto &pointIdx = m_segmentList[i];
			auto iter = duplicatePointsMap.find(pointIdx);

			if (iter != duplicatePointsMap.end())
			{
				TRACE2i(" -- sanitize: duplicate point as segment endpoint detected, index=", pointIdx);
				TRACE2i(" --           replaced with index=", iter->second);

				if (traceLvl != None)
				{
					printf("Warning:  segments[%zd] - a duplicate vertex (index=%d) replaced by original (index=%d).\n",
						   i / 2, pointIdx, iter->second);
				}

				pointIdx = iter->second;
			}
		}

		// remove point duplicates
		std::vector<int> duplicatePts(duplicatePointsMap.size());
		std::transform(duplicatePointsMap.begin(), duplicatePointsMap.end(), duplicatePts.begin(), [](auto &pair)
					   { return pair.first; });
		std::sort(duplicatePts.begin(), duplicatePts.end());

		for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter)
		{
			m_pointList.erase(m_pointList.begin() + *iter);

			if (traceLvl != None)
			{
				printf("Warning:  A duplicate vertex point deleted at index=%d.\n", *iter);
			}
		}

		// corrections for removed points
		for (auto &pointIdx : m_segmentList)
		{
			int i = 0;
			for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter, ++i)
			{
				if (pointIdx > *iter)
				{
					if (traceLvl != None)
					{
						printf("Warning:  Correction for segment endpoint - iter=%d pointIdx=%d, new_pointIdx=%zd.\n",
							   *iter, pointIdx, pointIdx - (duplicatePts.size() - i));
					}

					pointIdx -= (duplicatePts.size() - i); // OPEN TODO:: warning !!!
					break;
				}
			}
		}
	}

	void Delaunay::readPointsFromMesh(std::vector<Point> &points) const
	{
		TP_MESH_BEHAVIOR_WRAP();

		points.clear();
		points.reserve(tpmesh->invertices);

		int vertexnumber = tpbehavior->firstnumber;
		Triwrap::__pmesh *m = tpmesh; // needed for Triwrap's macros vertextype()/setvertexmark()

		pTriangleWrap->traversalinit(&tpmesh->vertices);
		Triwrap::vertex vertexloop = pTriangleWrap->vertextraverse(tpmesh);

		while (vertexloop != nullptr)
		{
			if (!tpbehavior->jettison || (vertextype(vertexloop) != UNDEADVERTEX))
			{
				/* X and Y coordinates. */
				points.push_back({vertexloop[0], vertexloop[1]});

#if 0 // --> not yet supported!
            /* Vertex attributes. */
            for (i = 0; i < tpmesh->nextras; i++) {
                palist[attribindex++] = vertexloop[2 + i];
            }
            if (!tpbehavior->nobound) {
                /* Copy the boundary marker. */
                pmlist[vertexnumber - tpbehavior->firstnumber] = vertexmark(vertexloop);
            }
#endif
				setvertexmark(vertexloop, vertexnumber);
				vertexnumber++;
			}

			vertexloop = pTriangleWrap->vertextraverse(tpmesh);
		}
	}

	void Delaunay::readSegmentsFromMesh(std::vector<int> &segmentEndpoints) const
	{
		TP_MESH_BEHAVIOR_WRAP();

		segmentEndpoints.clear();
		segmentEndpoints.reserve(tpmesh->insegments * 2);

		struct Triwrap::osub subsegloop;
		Triwrap::vertex endpoint1, endpoint2;
		long subsegnumber;

		pTriangleWrap->traversalinit(&tpmesh->subsegs);
		subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
		subsegloop.ssorient = 0;
		subsegnumber = tpbehavior->firstnumber;

		Triwrap::__pmesh *m = tpmesh;	// needed for Triwrap's macro vertexmark()
		typedef Triwrap::vertex vertex; // same!

		while (subsegloop.ss != nullptr)
		{
			sorg(subsegloop, endpoint1);
			sdest(subsegloop, endpoint2);

			// Copy indices of the segment's two endpoints
			segmentEndpoints.push_back(vertexmark(endpoint1));
			segmentEndpoints.push_back(vertexmark(endpoint2));

#if 0 // --> not yet supported!
        if (!b->nobound) {
            /* Copy the boundary marker. */
            smlist[subsegnumber - b->firstnumber] = mark(subsegloop);
        }
#endif

			subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
			subsegnumber++;
		}
	}

	void Delaunay::readHolesFromFile(
		char *polyfileName,
		FILE *polyfile,
		std::vector<Point> &holeMarkers,
		std::vector<Point4> &regionConstr) const
	{
		TP_MESH_BEHAVIOR_WRAP();

		REAL *holearray = nullptr;
		REAL *regionarray = nullptr;

		holeMarkers.clear();

		// read also the regions!
		int regionattrib = tpbehavior->regionattrib;
		tpbehavior->regionattrib = 1;
		int regionCt = -1;

		try
		{
			pTriangleWrap->readholes(tpmesh, tpbehavior, polyfile, polyfileName,
									 &holearray, &tpmesh->holes, &regionarray, &regionCt);
			tpmesh->regions = regionCt;
		}
		catch (...)
		{
			// maybe no regions in file ???
			if (regionCt == -1)
			{
				tpmesh->regions = 0;
			}
			else
			{
				// real parsing problem
				throw;
			}
		}

		tpbehavior->regionattrib = regionattrib;

		for (int i = 0; i < 2 * tpmesh->holes; i += 2)
		{
			holeMarkers.emplace_back(holearray[i], holearray[i + 1]);
		}

		if (tpmesh->holes > 0)
		{
			pTriangleWrap->trifree((VOID *)holearray);
		}

		regionConstr.clear();

		for (int i = 0; i < 4 * tpmesh->regions; i += 4)
		{
			double arr[] = {regionarray[i], regionarray[i + 1], regionarray[i + 2], regionarray[i + 3]};
			regionConstr.emplace_back(arr);
		}

		if (tpmesh->regions > 0)
		{
			pTriangleWrap->trifree((VOID *)regionarray);
		}
	}

	std::unordered_map<int, int> Delaunay::checkForDuplicatePoints() const
	{
		std::unordered_map<Delaunay::Point, size_t> uniqueMap;
		std::unordered_map<int, int> duplicateMap;

		for (size_t i = 0; i < m_pointList.size(); ++i)
		{
			auto &point = m_pointList[i];

			auto iter = uniqueMap.find(point);
			if (iter == uniqueMap.end())
			{
				uniqueMap.insert({point, i});
			}
			else
			{
				duplicateMap.insert({i, iter->second}); // OPEN TODO:: warning !!!
			}
		}

		return duplicateMap;
	}

	bool Delaunay::readSegmentsFromFile(char *polyfileName, FILE *polyfile, std::vector<int> &segmentEndpoints)
	{
		TRACE(" -> readSegmentsFromFile()");

		char inputline[INPUTLINESIZE];
		char *stringptr;
		int segmentmarkers;
		int end1, end2;
		int boundmarker [[maybe_unused]];
		int i;

		TP_MESH_BEHAVIOR_WRAP();

		stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
		int insegments = (int)strtol(stringptr, &stringptr, 0);

		stringptr = pTriangleWrap->findfield(stringptr);
		segmentmarkers = (*stringptr == '\0')
							 ? 0
							 : (int)strtol(stringptr, &stringptr, 0);
		boundmarker = 0;

		// Read and insert the segments.
		segmentEndpoints.clear();
		segmentEndpoints.reserve(tpmesh->insegments * 2);

		for (i = 0; i < /*m->*/ insegments; i++)
		{
			stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
			stringptr = pTriangleWrap->findfield(stringptr);
			if (*stringptr == '\0')
			{
				printf("Error:  Segment %d has no endpoints in %s.\n",
					   tpbehavior->firstnumber + i, polyfileName);
				return false;
			}
			else
			{
				end1 = (int)strtol(stringptr, &stringptr, 0);
			}

			stringptr = pTriangleWrap->findfield(stringptr);
			if (*stringptr == '\0')
			{
				printf("Error:  Segment %d is missing its second endpoint in %s.\n",
					   tpbehavior->firstnumber + i, polyfileName);
				return false;
			}
			else
			{
				end2 = (int)strtol(stringptr, &stringptr, 0);
			}

			if (segmentmarkers)
			{
				stringptr = pTriangleWrap->findfield(stringptr);
				boundmarker = (*stringptr == '\0')
								  ? 0
								  : (int)strtol(stringptr, &stringptr, 0);
			}

			if ((end1 < tpbehavior->firstnumber) ||
				(end1 >= tpbehavior->firstnumber + tpmesh->invertices))
			{
				if (!tpbehavior->quiet)
				{
					printf("Warning:  Invalid first endpoint of segment %d in %s.\n",
						   tpbehavior->firstnumber + i, polyfileName);
				}
			}
			else if ((end2 < tpbehavior->firstnumber) ||
					 (end2 >= tpbehavior->firstnumber + tpmesh->invertices))
			{
				if (!tpbehavior->quiet)
				{
					printf("Warning:  Invalid second endpoint of segment %d in %s.\n",
						   tpbehavior->firstnumber + i, polyfileName);
				}
			}
			else
			{
				// OPEN TODO:::  one last check? ????
#if 0
            /* Find the vertices numbered `end1' and `end2'. */
            Triwrap::vertex endpoint1 = pTriangleWrap->getvertex(m, b, end1);
            Triwrap::vertex endpoint2 = pTriangleWrap->getvertex(m, b, end2);
            if ((endpoint1[0] == endpoint2[0]) && (endpoint1[1] == endpoint2[1])) 
            {
                if (!tpbehavior->quiet) 
                {
                    printf("Warning:  Endpoints of segment %d are coincident in %s.\n",
                           b->firstnumber + i, polyfilename);
                }
            }
            else 
            {
                insertsegment(m, b, endpoint1, endpoint2, boundmarker);
            }
#endif
				segmentEndpoints.push_back(end1);
				segmentEndpoints.push_back(end2);
			}
		}

		return true;
	}

	void Delaunay::SetPoint(Point &point, /*Triwrap::vertex*/ double *vertexptr)
	{
		// -- HACK:: double* as not to export internal impl.
		// OPEN TODO: compile test type check - Triwrap::vertex == double* ???

		point[0] = (vertexptr)[0]; // = x
		point[1] = (vertexptr)[1]; // = y
	}

	int Delaunay::GetFirstIndexNumber() const
	{
		Triwrap::__pbehavior *pbehavior = (Triwrap::__pbehavior *)m_pbehavior;
		return pbehavior->firstnumber;
	}

	//  Iterators and Mesh methods

	typedef Triwrap::vertex vertex;
	typedef Triwrap::triangle triangle;
	typedef Triwrap::__otriangle trianglelooptype; // i.e. oriented triangle

	///////////////////////////////
	//
	//  Face Iterator impl.
	//
	///////////////////////////////

	FaceIterator::FaceIterator(Delaunay *triangulator)
		: m_delaunay(triangulator),
		  meshPointCount(0)
	{
		floop.tri = nullptr;

		TP_MESH_WRAP_ITER();
		TP_PLOOP_ITER();

		pTriangleWrap->traversalinit(&(tpmesh->triangles));

		ploop->tri = pTriangleWrap->triangletraverse(tpmesh);
		ploop->orient = 0;
	}

	FaceIterator &FaceIterator::operator++()
	{
		// cout << "++ called\n";

		TP_MESH_WRAP_ITER();
		TP_PLOOP_ITER();

		ploop->tri = pTriangleWrap->triangletraverse(tpmesh);

		// cout << "tri val = " << ploop->tri << endl;

		return *this;
	}

	FaceIterator FaceIterator::operator++(int)
	{
		FaceIterator copy(*this);
		++*this;
		return copy;
	}

	bool FaceIterator::isGhost() const
	{
		TP_MESH_ITER();
		TP_PLOOP_ITER();

		return (ploop->tri == tpmesh->dummytri);
	}

	bool FaceIterator::isdummy() const
	{
		// deprected, will be removed!!!
		return isGhost();
	}

	bool FaceIterator::empty() const
	{
		return floop.tri == nullptr;
	}

	bool FaceIterator::hasSteinerPoints() const
	{
		return Org() == -1 ||
			   Dest() == -1 ||
			   Apex() == -1;
	}

	int FaceIterator::Org(Delaunay::Point *point) const
	{
		vertex vertexptr = nullptr;
		org(*TP_PLOOP_PTR((*this)), vertexptr);

		if (point)
			Delaunay::SetPoint(*point, vertexptr);
		return getVertexIndex(vertexptr);
	}

	int FaceIterator::Dest(Delaunay::Point *point) const
	{
		vertex vertexptr = nullptr;
		dest(*TP_PLOOP_PTR((*this)), vertexptr);

		if (point)
			Delaunay::SetPoint(*point, vertexptr);
		return getVertexIndex(vertexptr);
	}

	int FaceIterator::Apex(Delaunay::Point *point) const
	{
		vertex vertexptr = nullptr;
		apex(*TP_PLOOP_PTR((*this)), vertexptr);

		if (point)
			Delaunay::SetPoint(*point, vertexptr);
		return getVertexIndex(vertexptr);
	}

	void FaceIterator::Org(Delaunay::Point &point, int &meshIndex) const
	{
		Assert(m_delaunay->m_extraVertexAttr, "");

		vertex vertexptr = nullptr;
		org(*TP_PLOOP_PTR((*this)), vertexptr);

		Delaunay::SetPoint(point, vertexptr);
		meshIndex = getMeshVertexIndex(vertexptr);
	}

	void FaceIterator::Dest(Delaunay::Point &point, int &meshIndex) const
	{
		Assert(m_delaunay->m_extraVertexAttr, "");

		vertex vertexptr = nullptr;
		dest(*TP_PLOOP_PTR((*this)), vertexptr);

		Delaunay::SetPoint(point, vertexptr);
		meshIndex = getMeshVertexIndex(vertexptr);
	}

	void FaceIterator::Apex(Delaunay::Point &point, int &meshIndex) const
	{
		Assert(m_delaunay->m_extraVertexAttr, "");

		vertex vertexptr = nullptr;
		apex(*TP_PLOOP_PTR((*this)), vertexptr);

		Delaunay::SetPoint(point, vertexptr);
		meshIndex = getMeshVertexIndex(vertexptr);
	}

	double FaceIterator::area() const
	{
		Delaunay::Point torg, tdest, tapex;

		(void)Org(&torg);
		(void)Dest(&tdest);
		(void)Apex(&tapex);

		double dxod(torg[0] - tdest[0]);
		double dyod(torg[1] - tdest[1]);
		double dxda(tdest[0] - tapex[0]);
		double dyda(tdest[1] - tapex[1]);

		double area = 0.5 * (dxod * dyda - dyod * dxda);
		return area;
	}

	int FaceIterator::getVertexIndex(/*Triwrap::vertex*/ double *vertexptr) const
	{
		// OPEN TODO: compile test type check - Triwrap::vertex == double* ???

		TP_MESH_ITER();
		TP_BEHAVIOR_ITER();

		int ret =
			(((int *)(vertexptr))[tpmesh->vertexmarkindex]) -
			tpbehavior->firstnumber;

		return ((unsigned)ret < m_delaunay->m_pointList.size()) ? ret : -1;
	}

	int FaceIterator::getMeshVertexIndex(/*Triwrap::vertex*/ double *vertexptr) const
	{
		if (!m_delaunay->m_extraVertexAttr)
		{
			std::cerr << "ERROR: Mesh indexing not enabled!\n";
			throw std::runtime_error("Mesh indexing not enabled");
		}

		Assert(meshPointCount >= 0, "");

		if (getVertexIndex(vertexptr) >= 0)
		{
			// extra attr. initialized to -1!
			if ((vertexptr)[2] < 0)
			{
				(vertexptr)[2] = meshPointCount++;
			}
		}
		else
		{
			// extra attr. initialized to -1!
			if ((vertexptr)[2] < 0)
			{
				Assert((vertexptr)[2] == -1.00, "");

				(vertexptr)[2] = meshPointCount++;
			}
		}

		int idx = (vertexptr)[2]; // OPEN TODO:: warning !!!
		Assert(idx >= 0, "");

		return idx;
	}

	bool operator==(FaceIterator const &fit1, FaceIterator const &fit2)
	{
		return (fit1.floop.tri == fit2.floop.tri);
	}

	bool operator!=(FaceIterator const &fit1, FaceIterator const &fit2)
	{
		return !(operator==(fit1, fit2));
	}

	bool operator<(FaceIterator const &fit1, FaceIterator const &fit2)
	{
		return (fit1.floop.tri < fit2.floop.tri);
	}

	///////////////////////////////
	//
	//  Vertex Iterator impl.
	//
	///////////////////////////////

	VertexIterator::VertexIterator(Delaunay *triangulator)
	{
		m_delaunay = triangulator;

		TP_MESH_WRAP_ITER();
		TP_BEHAVIOR_ITER();

		pTriangleWrap->traversalinit(&(tpmesh->vertices));
		vloop = pTriangleWrap->vertextraverse(tpmesh);

		while (
			tpbehavior->jettison ||
			(((int *)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX))
		{
			vloop = (void *)pTriangleWrap->vertextraverse(tpmesh);
		}
	}

	VertexIterator VertexIterator::operator++()
	{
		TP_MESH_WRAP_ITER();
		TP_BEHAVIOR_ITER();

		while (
			tpbehavior->jettison ||
			(((int *)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX))
		{
			vloop = (void *)pTriangleWrap->vertextraverse(tpmesh);
		}

		vloop = (void *)pTriangleWrap->vertextraverse(tpmesh);

		VertexIterator vit;
		vit.vloop = vloop;
		vit.m_delaunay = m_delaunay;

		return vit;
	}

	int VertexIterator::vertexId() const
	{
		TP_MESH_ITER();
		return ((int *)vloop)[tpmesh->vertexmarkindex];
	}

	double VertexIterator::x() const
	{
		return ((Delaunay::Point *)vloop)->operator[](0);
	}

	double VertexIterator::y() const
	{
		return ((Delaunay::Point *)vloop)->operator[](1);
	}

	Delaunay::Point &VertexIterator::operator*() const
	{
		return *((Delaunay::Point *)vloop);
	}

	bool operator==(VertexIterator const &vit1, VertexIterator const &vit2)
	{
		if (vit1.vloop == vit2.vloop)
			return true;
		return false;
	}

	bool operator!=(VertexIterator const &vit1, VertexIterator const &vit2)
	{
		if (vit1.vloop != vit2.vloop)
			return true;
		return false;
	}

	/////////////////////////////////
	//
	//  Voronoi Point Iterator impl.
	//
	/////////////////////////////////

	VoronoiVertexIterator::VoronoiVertexIterator()
		: m_delaunay(nullptr),
		  vvloop(nullptr),
		  vvindex(0),
		  vvcount(0)
	{
	}

	VoronoiVertexIterator::VoronoiVertexIterator(Delaunay *triangulator)
	{
		m_delaunay = triangulator;
		triangulateio *pvorout = (struct triangulateio *)triangulator->m_vorout;

		// TEST::: I hope so!
		Assert(triangulator->GetFirstIndexNumber() == 0, "");

		vvloop = pvorout->pointlist;
		vvindex = 0;
		vvcount = pvorout->numberofpoints;
	}

	VoronoiVertexIterator VoronoiVertexIterator::operator++()
	{
		VoronoiVertexIterator vit;

		vit.vvloop = vvloop;
		vit.vvindex = vvindex;
		vit.m_delaunay = m_delaunay;

		advance(1);
		return vit;
	}

	Delaunay::Point &VoronoiVertexIterator::operator*() const
	{
		Delaunay::Point::NT *pointlist = (Delaunay::Point::NT *)vvloop;

		// UB! -> but also in original code...  OPEN TODO::: !!!
		return *((Delaunay::Point *)(pointlist + vvindex));
	}

	void VoronoiVertexIterator::advance(int steps)
	{
		int stepSize = 2;
		Assert(Delaunay::Point().dim() == stepSize, "");

		if (vvindex / stepSize + steps < vvcount)
		{
			vvindex += steps * stepSize;
		}
		else
		{
			// at end
			vvindex = 0;
			vvloop = nullptr;
		}

		Assert(vvindex / stepSize < vvcount, "");
	}

	bool operator==(VoronoiVertexIterator const &lhs, VoronoiVertexIterator const &rhs)
	{
		if (lhs.vvloop == rhs.vvloop && lhs.vvindex == rhs.vvindex)
			return true;

		return false;
	}

	bool operator!=(VoronoiVertexIterator const &lhs, VoronoiVertexIterator const &rhs)
	{
		return !(lhs == rhs);
	}

	/////////////////////////////////
	//
	//  Voronoi Edge Iterator impl.
	//
	/////////////////////////////////

	VoronoiEdgeIterator::VoronoiEdgeIterator()
		: m_delaunay(nullptr),
		  veloop(nullptr),
		  veindex(0),
		  vecount(0)
	{
	}

	VoronoiEdgeIterator::VoronoiEdgeIterator(Delaunay *triangulator)
	{
		m_delaunay = triangulator;
		triangulateio *pvorout = (struct triangulateio *)triangulator->m_vorout;

		// TEST::: I hope so!
		Assert(triangulator->GetFirstIndexNumber() == 0, "");

		veloop = pvorout->edgelist;
		veindex = 0;
		vecount = pvorout->numberofedges;
	}

	VoronoiEdgeIterator VoronoiEdgeIterator::operator++()
	{
		VoronoiEdgeIterator veit;

		veit.veloop = veloop;
		veit.veindex = veindex;
		veit.m_delaunay = m_delaunay;

		// an edge is represented as 2 integer indexes!
		if (veindex / 2 + 1 < vecount)
		{
			veindex += 2;
		}
		else
		{
			veindex = 0;
			veloop = nullptr;
		}

		Assert(veindex / 2 < vecount, "");
		return veit;
	}

	int VoronoiEdgeIterator::startPointId() const
	{
		if (!veloop)
		{
			Assert(false, "");
			return -1;
		}

		auto edgelist = (int *)veloop;
		return edgelist[veindex];
	}

	int VoronoiEdgeIterator::endPointId(Delaunay::Point &normvec) const
	{
		if (!veloop)
		{
			Assert(false, "");
			return -1;
		}

		Assert(veindex / 2 < vecount, "");
		auto edgelist = (int *)veloop;
		int idx = edgelist[veindex + 1];

		if (idx == -1)
		{
			triangulateio *pvorout = (struct triangulateio *)m_delaunay->m_vorout;
			auto normlist = pvorout->normlist;

			// normlist has same no. of elements as edgelist!
			normvec[0] = normlist[veindex];
			normvec[1] = normlist[veindex + 1];

			Assert(!(normvec[0] == 0.0 && normvec[1] == 0.0), "");
		}
		else
		{
			normvec[0] = 0.0;
			normvec[1] = 0.0;
		}

		return idx;
	}

	const Delaunay::Point &VoronoiEdgeIterator::Org()
	{
		auto pointId = startPointId();

		VoronoiVertexIterator vit = m_delaunay->vvbegin();
		vit.advance(pointId);
		return *vit;
	}

	Delaunay::Point VoronoiEdgeIterator::Dest(bool &finiteEdge)
	{
		// OPEN TODO::: optimization --- use const& as return value!
		//  -> don't uderstand this anymore, needed????

		Delaunay::Point normvec;

		auto pointId = endPointId(normvec);
		finiteEdge = pointId != -1;

		if (pointId == -1)
		{
			Assert(normvec.sqr_length() != 0.0, "");
			return normvec;
		}
		else
		{
			Assert(normvec.sqr_length() == 0.0, "");

			VoronoiVertexIterator vit = m_delaunay->vvbegin();
			vit.advance(pointId);
			return *vit;
		}
	}

	bool operator==(VoronoiEdgeIterator const &lhs, VoronoiEdgeIterator const &rhs)
	{
		if (lhs.veloop == rhs.veloop && lhs.veindex == rhs.veindex)
			return true;

		return false;
	}

	bool operator!=(VoronoiEdgeIterator const &lhs, VoronoiEdgeIterator const &rhs)
	{
		return !(lhs == rhs);
	}

	/////////////////////////////////
	//
	//  TriangulationMesh impl.
	//
	/////////////////////////////////

	TriangulationMesh::TriangulationMesh(Delaunay *triangulator)
		: m_delaunay(triangulator)
	{
	}

	int TriangulationMesh::Sym(FaceIterator const &fit, char i) const
	{
		TP_MESH_PLOOP(fit);

		char oval = (char)ploop->orient;
		ploop->orient = i;

		trianglelooptype top;
		triangle ptr; // Temporary variable used by sym() macro!
		sym(*ploop, top);
		ploop->orient = oval;

		if (top.tri != tpmesh->dummytri)
		{
			vertex farvertex;
			apex(top, farvertex);
			return ((int *)farvertex)[tpmesh->vertexmarkindex];
		}

		return -1;
	}

	FaceIterator TriangulationMesh::Sym(FaceIterator const &fit) const
	{
		FaceIterator retval;
		retval.m_delaunay = fit.m_delaunay;

		TP_MESH_PLOOP(fit);

		trianglelooptype top;
		triangle ptr; // Temporary variable used by sym() macro!
		sym(*ploop, top);

		if (top.tri != tpmesh->dummytri)
		{
			retval.floop.tri = top.tri;
			retval.floop.orient = top.orient;
			return retval;
		}

		retval.floop.tri = nullptr;
		retval.floop.orient = 0;
		return retval;
	}

	FaceIterator TriangulationMesh::locate(int vertexid)
	{
		FaceIterator retval;
		retval.m_delaunay = this->m_delaunay;

		TP_MESH_WRAP_ITER();
		TP_BEHAVIOR_ITER();

		trianglelooptype horiz; // temp. variables for locate() & sym() macros!
		triangle ptr;

		horiz.tri = tpmesh->dummytri;
		horiz.orient = 0;
		symself(horiz);

		double dv[2];
		dv[0] = m_delaunay->m_pointList[vertexid][0];
		dv[1] = m_delaunay->m_pointList[vertexid][1];

		// Search for a triangle containing `newvertex'
		int intersect = pTriangleWrap->locate(tpmesh, tpbehavior, dv, &horiz);
		Assert(intersect == Triwrap::ONVERTEX, "Something went wrong in point location");

		if (intersect != Triwrap::ONVERTEX)
		{
			// Not on vertex!
			std::cerr << "ERROR: Something went wrong in point location!\n";
			pTriangleWrap->triexit(1);
		}

		retval.floop.tri = horiz.tri;
		retval.floop.orient = horiz.orient;

		return retval;
	}

	FaceIterator TriangulationMesh::Lnext(FaceIterator const &fit)
	{
		FaceIterator retval;
		retval.m_delaunay = m_delaunay;

		lnext(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

		return retval;
	}

	FaceIterator TriangulationMesh::Lprev(FaceIterator const &fit)
	{
		FaceIterator retval;
		retval.m_delaunay = m_delaunay;

		lprev(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

		return retval;
	}

	FaceIterator TriangulationMesh::Onext(FaceIterator const &fit)
	{
		triangle ptr;
		FaceIterator retval;
		retval.m_delaunay = m_delaunay;

		// cout << "Onext called:\n "
		//	 << Org(fit) << "\t" << Dest(fit) << "\t" << Apex(fit) << "";

		onext(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

		// retval could be dummy!
		return retval;
	}

	FaceIterator TriangulationMesh::Oprev(FaceIterator const &fit)
	{
		triangle ptr;
		FaceIterator retval;
		retval.m_delaunay = m_delaunay;

		oprev(*TP_PLOOP_PTR(fit), *TP_PLOOP_PTR(retval));

		return retval;
	}

	void TriangulationMesh::trianglesAroundVertex(int vertexid, std::vector<int> &ivv)
	{
		FaceIterator fit = locate(vertexid);
		ivv.clear();

		int start = fit.Dest();
		int linkn = fit.Apex();

		ivv.push_back(vertexid);
		ivv.push_back(start);
		ivv.push_back(linkn);

		FaceIterator nfit = fit;
		FaceIterator pnfit = fit; // follows nfit by one triangle

		while (linkn != start)
		{
			nfit = Onext(nfit);
			if (nfit.isGhost())
			{
				// Do another algorithm
				ivv.clear();

				// use oprev now...
				fit = pnfit;
				nfit = fit;

				start = fit.Apex();
				linkn = fit.Dest();

				ivv.push_back(vertexid);
				ivv.push_back(linkn);
				ivv.push_back(start);

				while (linkn != start)
				{
					nfit = Oprev(nfit);
					if (nfit.isGhost())
						return;
					int a = nfit.Org();
					int b = nfit.Dest();
					int c = nfit.Apex();
					ivv.push_back(a);
					ivv.push_back(b);
					ivv.push_back(c);
					linkn = nfit.Dest();
				}

				return;
			}

			pnfit = nfit;

			int a = nfit.Org();
			int b = nfit.Dest();
			int c = nfit.Apex();

			// cout << "Triangle: " << a << "\t"  << b << "\t"  << c << "\n";

			ivv.push_back(a);
			ivv.push_back(b);
			ivv.push_back(c);

			linkn = nfit.Apex();
		}
	}

} // namespace tpp
